diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/core_esp8266_postmortem.cpp ./framework-arduinoespressif8266/cores/esp8266/core_esp8266_postmortem.cpp
83c83,88
< static void ets_printf_P(const char *str, ...) {
---
> 
> // exported for using in custom_crash_callback()
> extern void ___static_ets_printf_P(const char *str, ...);
> #define ets_printf_P ___static_ets_printf_P
> 
> void ___static_ets_printf_P(const char *str, ...) {
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/FS.h ./framework-arduinoespressif8266/cores/esp8266/FS.h
269c269
< extern fs::FS SPIFFS __attribute__((deprecated("SPIFFS has been deprecated. Please consider moving to LittleFS or other filesystems.")));
---
> extern fs::FS SPIFFS; // __attribute__((deprecated("SPIFFS has been deprecated. Please consider moving to LittleFS or other filesystems.")));
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/HardwareSerial.h ./framework-arduinoespressif8266/cores/esp8266/HardwareSerial.h
206a207,209
> #ifdef HAVE_KFC_FIRMWARE_VERSION
> extern Stream &Serial;
> #else
207a211
> #endif
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString/WString.cpp ./framework-arduinoespressif8266/cores/esp8266/WString/WString.cpp
0a1,2
> 
> #include "WStringEx.cpp"
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString/WStringEx.cpp ./framework-arduinoespressif8266/cores/esp8266/WString/WStringEx.cpp
0a1,865
> /*
>  WString.cpp - String library for Wiring & Arduino
>  ...mostly rewritten by Paul Stoffregen...
>  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
>  Copyright 2011, Paul Stoffregen, paul@pjrc.com
>  Modified by Ivan Grokhotkov, 2014 - esp8266 support
>  Modified by Michael C. Miller, 2015 - esp8266 progmem support
> 
>  This library is free software; you can redistribute it and/or
>  modify it under the terms of the GNU Lesser General Public
>  License as published by the Free Software Foundation; either
>  version 2.1 of the License, or (at your option) any later version.
> 
>  This library is distributed in the hope that it will be useful,
>  but WITHOUT ANY WARRANTY; without even the implied warranty of
>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
>  Lesser General Public License for more details.
> 
>  You should have received a copy of the GNU Lesser General Public
>  License along with this library; if not, write to the Free Software
>  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
>  */
> 
> #ifdef _MSC_VER
> #include <Arduino_compat.h>
> #include "cores/esp8266/WString.h"
> #include "util/stdlib_noniso.h"
> #else
> #include <Arduino.h>
> #include "WString.h"
> #include "stdlib_noniso.h"
> #endif
> 
>  /*********************************************/
>  /*  Constructors                             */
>  /*********************************************/
> 
> String::String(const char *cstr) {
>     init();
>     if (cstr)
>         copy(cstr, strlen(cstr));
> }
> 
> String::String(const String &value) {
>     init();
>     *this = value;
> }
> 
> String::String(const __FlashStringHelper *pstr) {
>     init();
>     *this = pstr; // see operator =
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String::String(String &&rval) {
>     init();
>     move(rval);
> }
> 
> String::String(StringSumHelper &&rval) {
>     init();
>     move(rval);
> }
> #endif
> 
> String::String(char c) {
>     init();
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     *this = buf;
> }
> 
> String::String(unsigned char value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned char)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(int value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(int)];
>     if (base == 10) {
>         sprintf(buf, "%d", value);
>     }
>     else {
>         itoa(value, buf, base);
>     }
>     *this = buf;
> }
> 
> String::String(unsigned int value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned int)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(long value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(long)];
>     if (base == 10) {
>         sprintf(buf, "%ld", value);
>     }
>     else {
>         ltoa(value, buf, base);
>     }
>     *this = buf;
> }
> 
> String::String(unsigned long value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned long)];
>     ultoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(float value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::String(double value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::~String() {
>     invalidate();
> }
> 
> // /*********************************************/
> // /*  Memory Management                        */
> // /*********************************************/
> 
> inline void String::init(void) {
>     setSSO(true);
>     setLen(0);
>     wbuffer()[0] = 0;
> }
> 
> void String::invalidate(void) {
>     if (!isSSO() && wbuffer())
>         free(wbuffer());
>     init();
> }
> 
> unsigned char String::reserve(unsigned int size) {
>     if (buffer() && capacity() >= size)
>         return 1;
>     if (changeBuffer(size)) {
>         if (len() == 0)
>             wbuffer()[0] = 0;
>         return 1;
>     }
>     return 0;
> }
> 
> unsigned char String::changeBuffer(unsigned int maxStrLen) {
>     // Can we use SSO here to avoid allocation?
>     if (maxStrLen < sizeof(sso.buff) - 1) {
>         if (isSSO() || !buffer()) {
>             // Already using SSO, nothing to do
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             return 1;
>         }
>         else { // if bufptr && !isSSO()
>          // Using bufptr, need to shrink into sso.buff
>             char temp[sizeof(sso.buff)];
>             memcpy(temp, buffer(), maxStrLen);
>             free(wbuffer());
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             memcpy(wbuffer(), temp, maxStrLen);
>             return 1;
>         }
>     }
>     // Fallthrough to normal allocator
>     size_t newSize = (maxStrLen + 16) & (~0xf);
>     // Make sure we can fit newsize in the buffer
>     if (newSize > CAPACITY_MAX) {
>         return false;
>     }
>     uint16_t oldLen = len();
>     char *newbuffer = (char *)realloc(isSSO() ? nullptr : wbuffer(), newSize);
>     if (newbuffer) {
>         size_t oldSize = capacity() + 1; // include NULL.
>         if (isSSO()) {
>             // Copy the SSO buffer into allocated space
>             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
>         }
>         if (newSize > oldSize)
>         {
>             memset(newbuffer + oldSize, 0, newSize - oldSize);
>         }
>         setSSO(false);
>         setCapacity(newSize - 1);
>         setLen(oldLen); // Needed in case of SSO where len() never existed
>         setBuffer(newbuffer);
>         return 1;
>     }
>     return 0;
> }
> 
> // /*********************************************/
> // /*  Copy and Move                            */
> // /*********************************************/
> 
> String &String::copy(const char *cstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memmove_P(wbuffer(), cstr, length + 1);
>     return *this;
> }
> 
> String &String::copy(const __FlashStringHelper *pstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> void String::move(String &rhs) {
>     if (buffer()) {
>         if (capacity() >= rhs.len()) {
>             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
>             setLen(rhs.len());
>             rhs.invalidate();
>             return;
>         }
>         else {
>             if (!isSSO()) {
>                 free(wbuffer());
>                 setBuffer(nullptr);
>             }
>         }
>     }
>     if (rhs.isSSO()) {
>         setSSO(true);
>         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
>     }
>     else {
>         setSSO(false);
>         setBuffer(rhs.wbuffer());
>     }
>     setCapacity(rhs.capacity());
>     setLen(rhs.len());
>     rhs.setSSO(false);
>     rhs.setCapacity(0);
>     rhs.setLen(0);
>     rhs.setBuffer(nullptr);
> }
> #endif
> 
> String &String::operator =(const String &rhs) {
>     if (this == &rhs)
>         return *this;
> 
>     if (rhs.buffer())
>         copy(rhs.buffer(), rhs.len());
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String &String::operator =(String &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> 
> String &String::operator =(StringSumHelper &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> #endif
> 
> String &String::operator =(const char *cstr) {
>     if (cstr)
>         copy(cstr, strlen(cstr));
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> String &String::operator = (const __FlashStringHelper *pstr)
> {
>     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
>     else invalidate();
> 
>     return *this;
> }
> 
> // /*********************************************/
> // /*  concat                                   */
> // /*********************************************/
> 
> unsigned char String::concat(const String &s) {
>     // Special case if we're concatting ourself (s += s;) since we may end up
>     // realloc'ing the buffer and moving s.buffer in the method called
>     if (&s == this) {
>         unsigned int newlen = 2 * len();
>         if (!s.buffer())
>             return 0;
>         if (s.len() == 0)
>             return 1;
>         if (!reserve(newlen))
>             return 0;
>         memmove_P(wbuffer() + len(), buffer(), len());
>         setLen(newlen);
>         wbuffer()[len()] = 0;
>         return 1;
>     }
>     else {
>         return concat(s.buffer(), s.len());
>     }
> }
> 
> unsigned char String::concat(const char *cstr, unsigned int length) {
>     unsigned int newlen = len() + length;
>     if (!cstr)
>         return 0;
>     if (length == 0)
>         return 1;
>     if (!reserve(newlen))
>         return 0;
>     memmove_P(wbuffer() + len(), cstr, length + 1);
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return 1;
> }
> 
> unsigned char String::concat(const char *cstr) {
>     if (!cstr)
>         return 0;
>     return concat(cstr, strlen(cstr));
> }
> 
> unsigned char String::concat(char c) {
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     return concat(buf, 1);
> }
> 
> unsigned char String::concat(unsigned char num) {
>     char buf[1 + 3 * sizeof(unsigned char)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(int num) {
>     char buf[2 + 3 * sizeof(int)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned int num) {
>     char buf[1 + 3 * sizeof(unsigned int)];
>     utoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(long num) {
>     char buf[2 + 3 * sizeof(long)];
>     sprintf(buf, "%ld", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned long num) {
>     char buf[1 + 3 * sizeof(unsigned long)];
>     ultoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(float num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(double num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(const __FlashStringHelper *str) {
>     if (!str) return 0;
>     int length = strlen_P((PGM_P)str);
>     if (length == 0) return 1;
>     unsigned int newlen = len() + length;
>     if (!reserve(newlen)) return 0;
>     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
>     setLen(newlen);
>     return 1;
> }
> 
> /*********************************************/
> /*  Concatenate                              */
> /*********************************************/
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs.buffer(), rhs.len()))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!cstr || !a.concat(cstr, strlen(cstr)))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, char c) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(c))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, float num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, double num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs))
>         a.invalidate();
>     return a;
> }
> 
> // /*********************************************/
> // /*  Comparison                               */
> // /*********************************************/
> 
> int String::compareTo(const String &s) const {
>     if (!buffer() || !s.buffer()) {
>         if (s.buffer() && s.len() > 0)
>             return 0 - *(unsigned char *)s.buffer();
>         if (buffer() && len() > 0)
>             return *(unsigned char *)buffer();
>         return 0;
>     }
>     return strcmp(buffer(), s.buffer());
> }
> 
> 
> unsigned char String::operator<(const String &rhs) const {
>     return compareTo(rhs) < 0;
> }
> 
> unsigned char String::operator>(const String &rhs) const {
>     return compareTo(rhs) > 0;
> }
> 
> unsigned char String::operator<=(const String &rhs) const {
>     return compareTo(rhs) <= 0;
> }
> 
> unsigned char String::operator>=(const String &rhs) const {
>     return compareTo(rhs) >= 0;
> }
> 
> unsigned char String::equalsConstantTime(const String &s2) const {
>     // To avoid possible time-based attacks present function
>     // compares given strings in a constant time.
>     if (len() != s2.len())
>         return 0;
>     //at this point lengths are the same
>     if (len() == 0)
>         return 1;
>     //at this point lenghts are the same and non-zero
>     const char *p1 = buffer();
>     const char *p2 = s2.buffer();
>     unsigned int equalchars = 0;
>     unsigned int diffchars = 0;
>     while (*p1) {
>         if (*p1 == *p2)
>             ++equalchars;
>         else
>             ++diffchars;
>         ++p1;
>         ++p2;
>     }
>     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
>     unsigned char equalcond = (equalchars == len());
>     unsigned char diffcond = (diffchars == 0);
>     return (equalcond & diffcond); //bitwise AND
> }
> 
> // unsigned char String::startsWith(const String &s2) const {
> //     if(len() < s2.len())
> //         return 0;
> //     return startsWith(s2, 0);
> // }
> 
> // unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> //     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> //         return 0;
> //     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> // }
> 
> // /*********************************************/
> // /*  Character Access                         */
> // /*********************************************/
> 
> char String::charAt(unsigned int loc) const {
>     return operator[](loc);
> }
> 
> void String::setCharAt(unsigned int loc, char c) {
>     if (loc < len())
>         wbuffer()[loc] = c;
> }
> 
> char &String::operator[](unsigned int index) {
>     static char dummy_writable_char;
>     if (index >= len() || !buffer()) {
>         dummy_writable_char = 0;
>         return dummy_writable_char;
>     }
>     return wbuffer()[index];
> }
> 
> char String::operator[](unsigned int index) const {
>     if (index >= len() || !buffer())
>         return 0;
>     return buffer()[index];
> }
> 
> void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
>     if (!bufsize || !buf)
>         return;
>     if (index >= len()) {
>         buf[0] = 0;
>         return;
>     }
>     unsigned int n = bufsize - 1;
>     if (n > len() - index)
>         n = len() - index;
>     strncpy((char *)buf, buffer() + index, n);
>     buf[n] = 0;
> }
> 
> // /*********************************************/
> // /*  Search                                   */
> // /*********************************************/
> 
> int String::indexOf(char ch, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *temp = strchr(buffer() + fromIndex, ch);
>     if (temp == NULL)
>         return -1;
>     return temp - buffer();
> }
> 
> int String::indexOf(const String &s2) const {
>     return indexOf(s2, 0);
> }
> 
> int String::indexOf(const String &s2, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *found = strstr(buffer() + fromIndex, s2.buffer());
>     if (found == NULL)
>         return -1;
>     return found - buffer();
> }
> 
> String String::substring(unsigned int left, unsigned int right) const {
>     if (left > right) {
>         unsigned int temp = right;
>         right = left;
>         left = temp;
>     }
>     String out;
>     if (left >= len())
>         return out;
>     if (right > len())
>         right = len();
>     char temp = buffer()[right];  // save the replaced character
>     wbuffer()[right] = '\0';
>     out = wbuffer() + left;  // pointer arithmetic
>     wbuffer()[right] = temp;  //restore character
>     return out;
> }
> 
> // /*********************************************/
> // /*  Modification                             */
> // /*********************************************/
> 
> bool String::insert(size_t pos, PGM_P insert, size_t insertLen) {
>     size_t len;
>     if (insertLen == 0 || (len = length()) == 0 || pos >= len) {
>         return false;
>     }
>     auto requiredLen = len + insertLen;
>     if (!reserve(requiredLen)) {
>         return false;
>     }
>     setLen(requiredLen);
>     memmove(wbuffer() + pos + insertLen, wbuffer() + pos, len - pos/* + 1 NUL byte*/);
>     memmove_P(wbuffer() + pos, insert, insertLen);
>     wbuffer()[requiredLen] = 0;
>     return true;
> }
> 
> 
> bool String::replace(char find, char replace)
> {
>     if (!buffer())
>         return true;
>     for (char *p = wbuffer(); *p; p++) {
>         if (*p == find) {
>             *p = replace;
>         }
>     }
>     return true;
> }
> 
> bool String::_replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen)
> {
>     if (length() == 0 || findLen == 0 || !find) {
>         return false;
>     }
>     int diff = replaceLen - findLen;
>     char *readFrom = wbuffer();
>     char *foundAt;
>     if (diff == 0) {
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             memmove_P(foundAt, replace, replaceLen);
>             readFrom = foundAt + replaceLen;
>         }
>     }
>     else if (diff < 0) {
>         char *writeTo = wbuffer();
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             unsigned int n = foundAt - readFrom;
>             memmove(writeTo, readFrom, n);
>             writeTo += n;
>             memmove_P(writeTo, replace, replaceLen);
>             writeTo += replaceLen;
>             readFrom = foundAt + findLen;
>             setLen(len() + diff);
>         }
>         memmove(writeTo, readFrom, strlen(readFrom) + 1);
>     }
>     else {
>         unsigned int size = len(); // compute size needed for result
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             readFrom = foundAt + findLen;
>             size += diff;
>         }
>         if (size == len()) {
>             return true;
>         }
>         if (size > capacity() && !changeBuffer(size)) {
>             return false;
>         }
>         int index = len() - 1;
>         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
>             readFrom = wbuffer() + index + findLen;
>             memmove(readFrom + diff, readFrom, len() - (readFrom - buffer()));
>             int newLen = len() + diff;
>             memmove_P(wbuffer() + index, replace, replaceLen);
>             setLen(newLen);
>             wbuffer()[newLen] = 0;
>             index--;
>         }
>     }
>     return true;
> }
> 
> void String::remove(unsigned int index) {
>     // Pass the biggest integer as the count. The remove method
>     // below will take care of truncating it at the end of the
>     // string.
>     remove(index, (unsigned int)-1);
> }
> 
> void String::remove(unsigned int index, unsigned int count) {
>     if (index >= len()) {
>         return;
>     }
>     if (count <= 0) {
>         return;
>     }
>     if (count > len() - index) {
>         count = len() - index;
>     }
>     char *writeTo = wbuffer() + index;
>     unsigned int newlen = len() - count;
>     setLen(newlen);
>     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
>     wbuffer()[newlen] = 0;
> }
> 
> String &String::toLowerCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = tolower(*p);
>     }
>     return *this;
> }
> 
> String &String::toUpperCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = toupper(*p);
>     }
>     return *this;
> }
> 
> 
> String &String::_trim(TrimType type)
> {
>     auto len = length();
>     if (len == 0) {
>         return *this;
>     }
>     char *begin = wbuffer();
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         while (isspace(*begin)) {
>             begin++;
>         }
>     }
>     char *end = wbuffer() + len - 1;
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (isspace(*end) && end >= begin) {
>             end--;
>         }
>     }
>     unsigned int newlen = end + 1 - begin;
>     if (begin > buffer()) {
>         memmove(wbuffer(), begin, newlen);
>     }
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return *this;
> }
> 
> String &String::_trim(TrimType type, PGM_P characters, size_t charLen)
> {
>     auto len = length();
>     if (!len || !characters || !charLen) {
>         return *this;
>     }
>     charLen++; // use memchr instead of strchr to avoid additional NUL byte check
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (len && memchr_P(characters, buffer()[len - 1], charLen)) {
>             len--;
>         }
>         setLen(len);
>     }
> 
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         size_t remove = 0;
>         while (memchr_P(characters, buffer()[remove], charLen)) {
>             remove++;
>         }
>         this->remove(0, remove); // remove adds NUL byte
>     }
>     else {
>         wbuffer()[len] = 0;
>     }
>     return *this;
> }
> 
> 
> // /*********************************************/
> // /*  Parsing / Conversion                     */
> // /*********************************************/
> 
> long String::toInt(void) const
> {
>     if (buffer()) {
>         return atol(buffer());
>     }
>     return 0;
> }
> 
> float String::toFloat(void) const
> {
>     if (buffer()) {
>         return atof(buffer());
>     }
>     return 0;
> }
> 
> // global empty string to allow returning const String& with nothing
> 
> const String emptyString;
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString.cpp ./framework-arduinoespressif8266/cores/esp8266/WString.cpp
1,7d0
< /*
<  WString.cpp - String library for Wiring & Arduino
<  ...mostly rewritten by Paul Stoffregen...
<  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
<  Copyright 2011, Paul Stoffregen, paul@pjrc.com
<  Modified by Ivan Grokhotkov, 2014 - esp8266 support
<  Modified by Michael C. Miller, 2015 - esp8266 progmem support
9,856c2
<  This library is free software; you can redistribute it and/or
<  modify it under the terms of the GNU Lesser General Public
<  License as published by the Free Software Foundation; either
<  version 2.1 of the License, or (at your option) any later version.
< 
<  This library is distributed in the hope that it will be useful,
<  but WITHOUT ANY WARRANTY; without even the implied warranty of
<  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<  Lesser General Public License for more details.
< 
<  You should have received a copy of the GNU Lesser General Public
<  License along with this library; if not, write to the Free Software
<  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
<  */
< 
< #include <Arduino.h>
< #include "WString.h"
< #include "stdlib_noniso.h"
< 
< /*********************************************/
< /*  Constructors                             */
< /*********************************************/
< 
< String::String(const char *cstr) {
<     init();
<     if (cstr)
<         copy(cstr, strlen(cstr));
< }
< 
< String::String(const String &value) {
<     init();
<     *this = value;
< }
< 
< String::String(const __FlashStringHelper *pstr) {
<     init();
<     *this = pstr; // see operator =
< }
< 
< #ifdef __GXX_EXPERIMENTAL_CXX0X__
< String::String(String &&rval) {
<     init();
<     move(rval);
< }
< 
< String::String(StringSumHelper &&rval) {
<     init();
<     move(rval);
< }
< #endif
< 
< String::String(char c) {
<     init();
<     char buf[2];
<     buf[0] = c;
<     buf[1] = 0;
<     *this = buf;
< }
< 
< String::String(unsigned char value, unsigned char base) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned char)];
<     utoa(value, buf, base);
<     *this = buf;
< }
< 
< String::String(int value, unsigned char base) {
<     init();
<     char buf[2 + 8 * sizeof(int)];
<     if (base == 10) {
<         sprintf(buf, "%d", value);
<     } else {
<         itoa(value, buf, base);
<     }
<     *this = buf;
< }
< 
< String::String(unsigned int value, unsigned char base) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned int)];
<     utoa(value, buf, base);
<     *this = buf;
< }
< 
< String::String(long value, unsigned char base) {
<     init();
<     char buf[2 + 8 * sizeof(long)];
<     if (base==10) {
<         sprintf(buf, "%ld", value);
<     } else {
<         ltoa(value, buf, base);
<     }
<     *this = buf;
< }
< 
< String::String(unsigned long value, unsigned char base) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned long)];
<     ultoa(value, buf, base);
<     *this = buf;
< }
< 
< String::String(float value, unsigned char decimalPlaces) {
<     init();
<     char buf[33];
<     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
< }
< 
< String::String(double value, unsigned char decimalPlaces) {
<     init();
<     char buf[33];
<     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
< }
< 
< String::~String() {
<     invalidate();
< }
< 
< // /*********************************************/
< // /*  Memory Management                        */
< // /*********************************************/
< 
< inline void String::init(void) {
<     setSSO(true);
<     setLen(0);
<     wbuffer()[0] = 0;
< }
< 
< void String::invalidate(void) {
<     if(!isSSO() && wbuffer())
<         free(wbuffer());
<     init();
< }
< 
< unsigned char String::reserve(unsigned int size) {
<     if(buffer() && capacity() >= size)
<         return 1;
<     if(changeBuffer(size)) {
<         if(len() == 0)
<             wbuffer()[0] = 0;
<         return 1;
<     }
<     return 0;
< }
< 
< unsigned char String::changeBuffer(unsigned int maxStrLen) {
<     // Can we use SSO here to avoid allocation?
<     if (maxStrLen < sizeof(sso.buff) - 1) {
<         if (isSSO() || !buffer()) {
<             // Already using SSO, nothing to do
<             uint16_t oldLen = len();
<             setSSO(true);
<             setLen(oldLen);
<             return 1;
<         } else { // if bufptr && !isSSO()
<             // Using bufptr, need to shrink into sso.buff
<             char temp[sizeof(sso.buff)];
<             memcpy(temp, buffer(), maxStrLen);
<             free(wbuffer());
<             uint16_t oldLen = len();
<             setSSO(true);
<             setLen(oldLen);
<             memcpy(wbuffer(), temp, maxStrLen);
<             return 1;
<         }
<     }
<     // Fallthrough to normal allocator
<     size_t newSize = (maxStrLen + 16) & (~0xf);
<     // Make sure we can fit newsize in the buffer
<     if (newSize > CAPACITY_MAX) {
<         return false;
<     }
<     uint16_t oldLen = len();
<     char *newbuffer = (char *) realloc(isSSO() ? nullptr : wbuffer(), newSize);
<     if (newbuffer) {
<         size_t oldSize = capacity() + 1; // include NULL.
<         if (isSSO()) {
<             // Copy the SSO buffer into allocated space
<             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
<         }
<         if (newSize > oldSize)
<         {
<             memset(newbuffer + oldSize, 0, newSize - oldSize);
<         }
<         setSSO(false);
<         setCapacity(newSize - 1);
<         setLen(oldLen); // Needed in case of SSO where len() never existed
<         setBuffer(newbuffer);
<         return 1;
<     }
<     return 0;
< }
< 
< // /*********************************************/
< // /*  Copy and Move                            */
< // /*********************************************/
< 
< String & String::copy(const char *cstr, unsigned int length) {
<     if (!reserve(length)) {
<         invalidate();
<         return *this;
<     }
<     setLen(length);
<     memmove_P(wbuffer(), cstr, length + 1);
<     return *this;
< }
< 
< String & String::copy(const __FlashStringHelper *pstr, unsigned int length) {
<     if (!reserve(length)) {
<         invalidate();
<         return *this;
<     }
<     setLen(length);
<     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
<     return *this;
< }
< 
< #ifdef __GXX_EXPERIMENTAL_CXX0X__
< void String::move(String &rhs) {
<     if (buffer()) {
<         if (capacity() >= rhs.len()) {
<             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
<             setLen(rhs.len());
<             rhs.invalidate();
<             return;
<         } else {
<             if (!isSSO()) {
<                 free(wbuffer());
<                 setBuffer(nullptr);
<             }
<         }
<     }
<     if (rhs.isSSO()) {
<         setSSO(true);
<         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
<     } else {
<         setSSO(false);
<         setBuffer(rhs.wbuffer());
<     }
<     setCapacity(rhs.capacity());
<     setLen(rhs.len());
<     rhs.setSSO(false);
<     rhs.setCapacity(0);
<     rhs.setLen(0);
<     rhs.setBuffer(nullptr);
< }
< #endif
< 
< String & String::operator =(const String &rhs) {
<     if (this == &rhs)
<         return *this;
< 
<     if (rhs.buffer())
<         copy(rhs.buffer(), rhs.len());
<     else
<         invalidate();
< 
<     return *this;
< }
< 
< #ifdef __GXX_EXPERIMENTAL_CXX0X__
< String & String::operator =(String &&rval) {
<     if (this != &rval)
<         move(rval);
<     return *this;
< }
< 
< String & String::operator =(StringSumHelper &&rval) {
<     if (this != &rval)
<         move(rval);
<     return *this;
< }
< #endif
< 
< String & String::operator =(const char *cstr) {
<     if (cstr)
<         copy(cstr, strlen(cstr));
<     else
<         invalidate();
< 
<     return *this;
< }
< 
< String & String::operator = (const __FlashStringHelper *pstr)
< {
<     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
<     else invalidate();
< 
<     return *this;
< }
< 
< // /*********************************************/
< // /*  concat                                   */
< // /*********************************************/
< 
< unsigned char String::concat(const String &s) {
<     // Special case if we're concatting ourself (s += s;) since we may end up
<     // realloc'ing the buffer and moving s.buffer in the method called
<     if (&s == this) {
<         unsigned int newlen = 2 * len();
<         if (!s.buffer())
<             return 0;
<         if (s.len() == 0)
<             return 1;
<         if (!reserve(newlen))
<             return 0;
<         memmove_P(wbuffer() + len(), buffer(), len());
<         setLen(newlen);
<         wbuffer()[len()] = 0;
<         return 1;
<     } else {
<         return concat(s.buffer(), s.len());
<     }
< }
< 
< unsigned char String::concat(const char *cstr, unsigned int length) {
<     unsigned int newlen = len() + length;
<     if (!cstr)
<         return 0;
<     if (length == 0)
<         return 1;
<     if (!reserve(newlen))
<         return 0;
<     memmove_P(wbuffer() + len(), cstr, length + 1);
<     setLen(newlen);
<     wbuffer()[newlen] = 0;
<     return 1;
< }
< 
< unsigned char String::concat(const char *cstr) {
<     if (!cstr)
<         return 0;
<     return concat(cstr, strlen(cstr));
< }
< 
< unsigned char String::concat(char c) {
<     char buf[2];
<     buf[0] = c;
<     buf[1] = 0;
<     return concat(buf, 1);
< }
< 
< unsigned char String::concat(unsigned char num) {
<     char buf[1 + 3 * sizeof(unsigned char)];
<     sprintf(buf, "%d", num);
<     return concat(buf, strlen(buf));
< }
< 
< unsigned char String::concat(int num) {
<     char buf[2 + 3 * sizeof(int)];
<     sprintf(buf, "%d", num);
<     return concat(buf, strlen(buf));
< }
< 
< unsigned char String::concat(unsigned int num) {
<     char buf[1 + 3 * sizeof(unsigned int)];
<     utoa(num, buf, 10);
<     return concat(buf, strlen(buf));
< }
< 
< unsigned char String::concat(long num) {
<     char buf[2 + 3 * sizeof(long)];
<     sprintf(buf, "%ld", num);
<     return concat(buf, strlen(buf));
< }
< 
< unsigned char String::concat(unsigned long num) {
<     char buf[1 + 3 * sizeof(unsigned long)];
<     ultoa(num, buf, 10);
<     return concat(buf, strlen(buf));
< }
< 
< unsigned char String::concat(float num) {
<     char buf[20];
<     char* string = dtostrf(num, 4, 2, buf);
<     return concat(string, strlen(string));
< }
< 
< unsigned char String::concat(double num) {
<     char buf[20];
<     char* string = dtostrf(num, 4, 2, buf);
<     return concat(string, strlen(string));
< }
< 
< unsigned char String::concat(const __FlashStringHelper * str) {
<     if (!str) return 0;
<     int length = strlen_P((PGM_P)str);
<     if (length == 0) return 1;
<     unsigned int newlen = len() + length;
<     if (!reserve(newlen)) return 0;
<     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
<     setLen(newlen);
<     return 1;
< }
< 
< /*********************************************/
< /*  Concatenate                              */
< /*********************************************/
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(rhs.buffer(), rhs.len()))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!cstr || !a.concat(cstr, strlen(cstr)))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, char c) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(c))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(num))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, int num) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(num))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(num))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, long num) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(num))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(num))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, float num) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(num))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator +(const StringSumHelper &lhs, double num) {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(num))
<         a.invalidate();
<     return a;
< }
< 
< StringSumHelper & operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
< {
<     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
<     if (!a.concat(rhs))
<         a.invalidate();
<     return a;
< }
< 
< // /*********************************************/
< // /*  Comparison                               */
< // /*********************************************/
< 
< int String::compareTo(const String &s) const {
<     if(!buffer() || !s.buffer()) {
<         if(s.buffer() && s.len() > 0)
<             return 0 - *(unsigned char *) s.buffer();
<         if(buffer() && len() > 0)
<             return *(unsigned char *) buffer();
<         return 0;
<     }
<     return strcmp(buffer(), s.buffer());
< }
< 
< unsigned char String::equals(const String &s2) const {
<     return (len() == s2.len() && compareTo(s2) == 0);
< }
< 
< unsigned char String::equals(const char *cstr) const {
<     if (len() == 0)
<         return (cstr == NULL || *cstr == 0);
<     if (cstr == NULL)
<         return buffer()[0] == 0;
<     return strcmp(buffer(), cstr) == 0;
< }
< 
< unsigned char String::operator<(const String &rhs) const {
<     return compareTo(rhs) < 0;
< }
< 
< unsigned char String::operator>(const String &rhs) const {
<     return compareTo(rhs) > 0;
< }
< 
< unsigned char String::operator<=(const String &rhs) const {
<     return compareTo(rhs) <= 0;
< }
< 
< unsigned char String::operator>=(const String &rhs) const {
<     return compareTo(rhs) >= 0;
< }
< 
< unsigned char String::equalsIgnoreCase(const String &s2) const {
<     if (this == &s2)
<         return 1;
<     if (len() != s2.len())
<         return 0;
<     if (len() == 0)
<         return 1;
<     const char *p1 = buffer();
<     const char *p2 = s2.buffer();
<     while (*p1) {
<         if (tolower(*p1++) != tolower(*p2++))
<             return 0;
<     }
<     return 1;
< }
< 
< unsigned char String::equalsConstantTime(const String &s2) const {
<     // To avoid possible time-based attacks present function
<     // compares given strings in a constant time.
<     if (len() != s2.len())
<         return 0;
<     //at this point lengths are the same
<     if (len() == 0)
<         return 1;
<     //at this point lenghts are the same and non-zero
<     const char *p1 = buffer();
<     const char *p2 = s2.buffer();
<     unsigned int equalchars = 0;
<     unsigned int diffchars = 0;
<     while (*p1) {
<         if (*p1 == *p2)
<             ++equalchars;
<         else
<             ++diffchars;
<         ++p1;
<         ++p2;
<     }
<     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
<     unsigned char equalcond = (equalchars == len());
<     unsigned char diffcond = (diffchars == 0);
<     return (equalcond & diffcond); //bitwise AND
< }
< 
< unsigned char String::startsWith(const String &s2) const {
<     if(len() < s2.len())
<         return 0;
<     return startsWith(s2, 0);
< }
< 
< unsigned char String::startsWith(const String &s2, unsigned int offset) const {
<     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
<         return 0;
<     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
< }
< 
< unsigned char String::endsWith(const String &s2) const {
<     if(len() < s2.len() || !buffer() || !s2.buffer())
<         return 0;
<     return strcmp(&buffer()[len() - s2.len()], s2.buffer()) == 0;
< }
< 
< // /*********************************************/
< // /*  Character Access                         */
< // /*********************************************/
< 
< char String::charAt(unsigned int loc) const {
<     return operator[](loc);
< }
< 
< void String::setCharAt(unsigned int loc, char c) {
<     if (loc < len())
<         wbuffer()[loc] = c;
< }
< 
< char & String::operator[](unsigned int index) {
<     static char dummy_writable_char;
<     if (index >= len() || !buffer()) {
<         dummy_writable_char = 0;
<         return dummy_writable_char;
<     }
<     return wbuffer()[index];
< }
< 
< char String::operator[](unsigned int index) const {
<     if (index >= len() || !buffer())
<         return 0;
<     return buffer()[index];
< }
< 
< void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
<     if (!bufsize || !buf)
<         return;
<     if (index >= len()) {
<         buf[0] = 0;
<         return;
<     }
<     unsigned int n = bufsize - 1;
<     if (n > len() - index)
<         n = len() - index;
<     strncpy((char *) buf, buffer() + index, n);
<     buf[n] = 0;
< }
< 
< // /*********************************************/
< // /*  Search                                   */
< // /*********************************************/
< 
< int String::indexOf(char c) const {
<     return indexOf(c, 0);
< }
< 
< int String::indexOf(char ch, unsigned int fromIndex) const {
<     if (fromIndex >= len())
<         return -1;
<     const char* temp = strchr(buffer() + fromIndex, ch);
<     if (temp == NULL)
<         return -1;
<     return temp - buffer();
< }
< 
< int String::indexOf(const String &s2) const {
<     return indexOf(s2, 0);
< }
< 
< int String::indexOf(const String &s2, unsigned int fromIndex) const {
<     if (fromIndex >= len())
<         return -1;
<     const char *found = strstr(buffer() + fromIndex, s2.buffer());
<     if (found == NULL)
<         return -1;
<     return found - buffer();
< }
< 
< int String::lastIndexOf(char theChar) const {
<     return lastIndexOf(theChar, len() - 1);
< }
< 
< int String::lastIndexOf(char ch, unsigned int fromIndex) const {
<     if (fromIndex >= len())
<         return -1;
<     char tempchar = buffer()[fromIndex + 1];
<     wbuffer()[fromIndex + 1] = '\0';
<     char* temp = strrchr(wbuffer(), ch);
<     wbuffer()[fromIndex + 1] = tempchar;
<     if (temp == NULL)
<         return -1;
<     return temp - buffer();
< }
< 
< int String::lastIndexOf(const String &s2) const {
<     return lastIndexOf(s2, len() - s2.len());
< }
< 
< int String::lastIndexOf(const String &s2, unsigned int fromIndex) const {
<     if (s2.len() == 0 || len() == 0 || s2.len() > len())
<         return -1;
<     if (fromIndex >= len())
<         fromIndex = len() - 1;
<     int found = -1;
<     for (char *p = wbuffer(); p <= wbuffer() + fromIndex; p++) {
<         p = strstr(p, s2.buffer());
<         if (!p)
<             break;
<         if ((unsigned int) (p - wbuffer()) <= fromIndex)
<             found = p - buffer();
<     }
<     return found;
< }
< 
< String String::substring(unsigned int left, unsigned int right) const {
<     if (left > right) {
<         unsigned int temp = right;
<         right = left;
<         left = temp;
<     }
<     String out;
<     if (left >= len())
<         return out;
<     if (right > len())
<         right = len();
<     char temp = buffer()[right];  // save the replaced character
<     wbuffer()[right] = '\0';
<     out = wbuffer() + left;  // pointer arithmetic
<     wbuffer()[right] = temp;  //restore character
<     return out;
< }
< 
< // /*********************************************/
< // /*  Modification                             */
< // /*********************************************/
< 
< void String::replace(char find, char replace) {
<     if (!buffer())
<         return;
<     for (char *p = wbuffer(); *p; p++) {
<         if (*p == find)
<             *p = replace;
<     }
< }
< 
< void String::replace(const String& find, const String& replace) {
<     if (len() == 0 || find.len() == 0)
<         return;
<     int diff = replace.len() - find.len();
<     char *readFrom = wbuffer();
<     char *foundAt;
<     if (diff == 0) {
<         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
<             memmove_P(foundAt, replace.buffer(), replace.len());
<             readFrom = foundAt + replace.len();
<         }
<     } else if (diff < 0) {
<         char *writeTo = wbuffer();
<         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
<             unsigned int n = foundAt - readFrom;
<             memmove_P(writeTo, readFrom, n);
<             writeTo += n;
<             memmove_P(writeTo, replace.buffer(), replace.len());
<             writeTo += replace.len();
<             readFrom = foundAt + find.len();
<             setLen(len() + diff);
<         }
<         memmove_P(writeTo, readFrom, strlen(readFrom)+1);
<     } else {
<         unsigned int size = len(); // compute size needed for result
<         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
<             readFrom = foundAt + find.len();
<             size += diff;
<         }
<         if (size == len())
<             return;
<         if (size > capacity() && !changeBuffer(size))
<             return; // XXX: tell user!
<         int index = len() - 1;
<         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
<             readFrom = wbuffer() + index + find.len();
<             memmove_P(readFrom + diff, readFrom, len() - (readFrom - buffer()));
<             int newLen = len() + diff;
<             memmove_P(wbuffer() + index, replace.buffer(), replace.len());
<             setLen(newLen);
<             wbuffer()[newLen] = 0;
<             index--;
<         }
<     }
< }
< 
< void String::remove(unsigned int index) {
<     // Pass the biggest integer as the count. The remove method
<     // below will take care of truncating it at the end of the
<     // string.
<     remove(index, (unsigned int) -1);
< }
< 
< void String::remove(unsigned int index, unsigned int count) {
<     if (index >= len()) {
<         return;
<     }
<     if (count <= 0) {
<         return;
<     }
<     if (count > len() - index) {
<         count = len() - index;
<     }
<     char *writeTo = wbuffer() + index;
<     unsigned int newlen = len() - count;
<     setLen(newlen);
<     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
<     wbuffer()[newlen] = 0;
< }
< 
< void String::toLowerCase(void) {
<     if (!buffer())
<         return;
<     for (char *p = wbuffer(); *p; p++) {
<         *p = tolower(*p);
<     }
< }
< 
< void String::toUpperCase(void) {
<     if (!buffer())
<         return;
<     for (char *p = wbuffer(); *p; p++) {
<         *p = toupper(*p);
<     }
< }
< 
< void String::trim(void) {
<     if (!buffer() || len() == 0)
<         return;
<     char *begin = wbuffer();
<     while (isspace(*begin))
<         begin++;
<     char *end = wbuffer() + len() - 1;
<     while (isspace(*end) && end >= begin)
<         end--;
<     unsigned int newlen = end + 1 - begin;
<     setLen(newlen);
<     if (begin > buffer())
<         memmove_P(wbuffer(), begin, newlen);
<     wbuffer()[newlen] = 0;
< }
< 
< // /*********************************************/
< // /*  Parsing / Conversion                     */
< // /*********************************************/
< 
< long String::toInt(void) const {
<     if (buffer())
<         return atol(buffer());
<     return 0;
< }
< 
< float String::toFloat(void) const {
<     if (buffer())
<         return atof(buffer());
<     return 0;
< }
< 
< double String::toDouble(void) const
< {
<     if (buffer())
<         return atof(buffer());
<     return 0.0;
< }
< 
< // global empty string to allow returning const String& with nothing
< 
< const String emptyString;
---
> #include "WString/WStringEX.cpp"
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString.h ./framework-arduinoespressif8266/cores/esp8266/WString.h
21a22,23
> #pragma once
> 
25a28,30
> #ifdef _MSC_VER
> #include <misc_string.h>
> #else
29a35,36
> #include "KFCBaseLibrary/include/misc_string.h"
> #endif
31,32c38,39
< // An inherited class for holding the result of a concatenation.  These
< // result objects are assumed to be writable by subsequent concatenations.
---
>  // An inherited class for holding the result of a concatenation.  These
>  // result objects are assumed to be writable by subsequent concatenations.
37a45
> #ifndef FPSTR
38a47,48
> #endif
> #ifndef F
39a50
> #endif
43,58c54,69
<         // use a function pointer to allow for "if (s)" without the
<         // complications of an operator bool(). for more information, see:
<         // http://www.artima.com/cppsource/safebool.html
<         typedef void (String::*StringIfHelperType)() const;
<         void StringIfHelper() const {
<         }
< 
<     public:
<         // constructors
<         // creates a copy of the initial value.
<         // if the initial value is null or invalid, or if memory allocation
<         // fails, the string will be marked as invalid (i.e. "if (s)" will
<         // be false).
<         String(const char *cstr = nullptr);
<         String(const String &str);
<         String(const __FlashStringHelper *str);
---
>     // use a function pointer to allow for "if (s)" without the
>     // complications of an operator bool(). for more information, see:
>     // http://www.artima.com/cppsource/safebool.html
>     typedef void (String:: *StringIfHelperType)() const;
>     void StringIfHelper() const {
>     }
> 
> public:
>     // constructors
>     // creates a copy of the initial value.
>     // if the initial value is null or invalid, or if memory allocation
>     // fails, the string will be marked as invalid (i.e. "if (s)" will
>     // be false).
>     String(const char *cstr = nullptr);
>     String(const String &str);
>     String(const __FlashStringHelper *str);
60,61c71,72
<         String(String &&rval);
<         String(StringSumHelper &&rval);
---
>     String(String &&rval);
>     String(StringSumHelper &&rval);
63,97c74,109
<         explicit String(char c);
<         explicit String(unsigned char, unsigned char base = 10);
<         explicit String(int, unsigned char base = 10);
<         explicit String(unsigned int, unsigned char base = 10);
<         explicit String(long, unsigned char base = 10);
<         explicit String(unsigned long, unsigned char base = 10);
<         explicit String(float, unsigned char decimalPlaces = 2);
<         explicit String(double, unsigned char decimalPlaces = 2);
<         ~String(void);
< 
<         // memory management
<         // return true on success, false on failure (in which case, the string
<         // is left unchanged).  reserve(0), if successful, will validate an
<         // invalid string (i.e., "if (s)" will be true afterwards)
<         unsigned char reserve(unsigned int size);
<         inline unsigned int length(void) const {
<             if(buffer()) {
<                 return len();
<             } else {
<                 return 0;
<             }
<         }
<         inline void clear(void) {
<             setLen(0);
<         }
<         inline bool isEmpty(void) const {
<             return length() == 0;
<         }
< 
<         // creates a copy of the assigned value.  if the value is null or
<         // invalid, or if the memory allocation fails, the string will be
<         // marked as invalid ("if (s)" will be false).
<         String & operator =(const String &rhs);
<         String & operator =(const char *cstr);
<         String & operator = (const __FlashStringHelper *str);
---
>     explicit String(char c);
>     explicit String(unsigned char, unsigned char base = 10);
>     explicit String(int, unsigned char base = 10);
>     explicit String(unsigned int, unsigned char base = 10);
>     explicit String(long, unsigned char base = 10);
>     explicit String(unsigned long, unsigned char base = 10);
>     explicit String(float, unsigned char decimalPlaces = 2);
>     explicit String(double, unsigned char decimalPlaces = 2);
>     ~String(void);
> 
>     // memory management
>     // return true on success, false on failure (in which case, the string
>     // is left unchanged).  reserve(0), if successful, will validate an
>     // invalid string (i.e., "if (s)" will be true afterwards)
>     unsigned char reserve(unsigned int size);
>     inline unsigned int length(void) const {
>         if (buffer()) {
>             return len();
>         }
>         else {
>             return 0;
>         }
>     }
>     inline void clear(void) {
>         setLen(0);
>     }
>     inline bool isEmpty(void) const {
>         return length() == 0;
>     }
> 
>     // creates a copy of the assigned value.  if the value is null or
>     // invalid, or if the memory allocation fails, the string will be
>     // marked as invalid ("if (s)" will be false).
>     String &operator =(const String &rhs);
>     String &operator =(const char *cstr);
>     String &operator = (const __FlashStringHelper *str);
99,100c111,112
<         String & operator =(String &&rval);
<         String & operator =(StringSumHelper &&rval);
---
>     String &operator =(String &&rval);
>     String &operator =(StringSumHelper &&rval);
103c115
<         // concatenate (works w/ built-in types)
---
>     // concatenate (works w/ built-in types)
105,318c117,891
<         // returns true on success, false on failure (in which case, the string
<         // is left unchanged).  if the argument is null or invalid, the
<         // concatenation is considered unsuccessful.
<         unsigned char concat(const String &str);
<         unsigned char concat(const char *cstr);
<         unsigned char concat(char c);
<         unsigned char concat(unsigned char c);
<         unsigned char concat(int num);
<         unsigned char concat(unsigned int num);
<         unsigned char concat(long num);
<         unsigned char concat(unsigned long num);
<         unsigned char concat(float num);
<         unsigned char concat(double num);
<         unsigned char concat(const __FlashStringHelper * str);
<         unsigned char concat(const char *cstr, unsigned int length);
< 
<         // if there's not enough memory for the concatenated value, the string
<         // will be left unchanged (but this isn't signalled in any way)
<         String & operator +=(const String &rhs) {
<             concat(rhs);
<             return (*this);
<         }
<         String & operator +=(const char *cstr) {
<             concat(cstr);
<             return (*this);
<         }
<         String & operator +=(char c) {
<             concat(c);
<             return (*this);
<         }
<         String & operator +=(unsigned char num) {
<             concat(num);
<             return (*this);
<         }
<         String & operator +=(int num) {
<             concat(num);
<             return (*this);
<         }
<         String & operator +=(unsigned int num) {
<             concat(num);
<             return (*this);
<         }
<         String & operator +=(long num) {
<             concat(num);
<             return (*this);
<         }
<         String & operator +=(unsigned long num) {
<             concat(num);
<             return (*this);
<         }
<         String & operator +=(float num) {
<             concat(num);
<             return (*this);
<         }
<         String & operator +=(double num) {
<             concat(num);
<             return (*this);
<         }
<         String & operator += (const __FlashStringHelper *str){
<             concat(str);
<             return (*this);
<         }
< 
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, char c);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, int num);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, long num);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, float num);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, double num);
<         friend StringSumHelper & operator +(const StringSumHelper &lhs, const __FlashStringHelper *rhs);
< 
<         // comparison (only works w/ Strings and "strings")
<         operator StringIfHelperType() const {
<             return buffer() ? &String::StringIfHelper : 0;
<         }
<         int compareTo(const String &s) const;
<         unsigned char equals(const String &s) const;
<         unsigned char equals(const char *cstr) const;
<         unsigned char operator ==(const String &rhs) const {
<             return equals(rhs);
<         }
<         unsigned char operator ==(const char *cstr) const {
<             return equals(cstr);
<         }
<         unsigned char operator !=(const String &rhs) const {
<             return !equals(rhs);
<         }
<         unsigned char operator !=(const char *cstr) const {
<             return !equals(cstr);
<         }
<         unsigned char operator <(const String &rhs) const;
<         unsigned char operator >(const String &rhs) const;
<         unsigned char operator <=(const String &rhs) const;
<         unsigned char operator >=(const String &rhs) const;
<         unsigned char equalsIgnoreCase(const String &s) const;
<         unsigned char equalsConstantTime(const String &s) const;
<         unsigned char startsWith(const String &prefix) const;
<         unsigned char startsWith(const char * prefix) const {
<             return this->startsWith(String(prefix));
<         }
<         unsigned char startsWith(const __FlashStringHelper * prefix) const {
<             return this->startsWith(String(prefix));
<         }
<         unsigned char startsWith(const String &prefix, unsigned int offset) const;
<         unsigned char endsWith(const String &suffix) const;
<         unsigned char endsWith(const char * suffix) const {
<             return this->endsWith(String(suffix));
<         }
<         unsigned char endsWith(const __FlashStringHelper * suffix) const {
<             return this->endsWith(String(suffix));
<         }
< 
<         // character access
<         char charAt(unsigned int index) const;
<         void setCharAt(unsigned int index, char c);
<         char operator [](unsigned int index) const;
<         char& operator [](unsigned int index);
<         void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
<         void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
<             getBytes((unsigned char *) buf, bufsize, index);
<         }
<         const char* c_str() const { return buffer(); }
<         char* begin() { return wbuffer(); }
<         char* end() { return wbuffer() + length(); }
<         const char* begin() const { return c_str(); }
<         const char* end() const { return c_str() + length(); }
< 
<         // search
<         int indexOf(char ch) const;
<         int indexOf(char ch, unsigned int fromIndex) const;
<         int indexOf(const String &str) const;
<         int indexOf(const String &str, unsigned int fromIndex) const;
<         int lastIndexOf(char ch) const;
<         int lastIndexOf(char ch, unsigned int fromIndex) const;
<         int lastIndexOf(const String &str) const;
<         int lastIndexOf(const String &str, unsigned int fromIndex) const;
<         String substring(unsigned int beginIndex) const {
<             return substring(beginIndex, len());
<         }
<         ;
<         String substring(unsigned int beginIndex, unsigned int endIndex) const;
< 
<         // modification
<         void replace(char find, char replace);
<         void replace(const String& find, const String& replace);
<         void replace(const char * find, const String& replace) {
<             this->replace(String(find), replace);
<         }
<         void replace(const __FlashStringHelper * find, const String& replace) {
<             this->replace(String(find), replace);
<         }
<         void replace(const char * find, const char * replace) {
<             this->replace(String(find), String(replace));
<         }
<         void replace(const __FlashStringHelper * find, const char * replace) {
<             this->replace(String(find), String(replace));
<         }
<         void replace(const __FlashStringHelper * find, const __FlashStringHelper * replace) {
<             this->replace(String(find), String(replace));
<         }
<         void remove(unsigned int index);
<         void remove(unsigned int index, unsigned int count);
<         void toLowerCase(void);
<         void toUpperCase(void);
<         void trim(void);
< 
<         // parsing/conversion
<         long toInt(void) const;
<         float toFloat(void) const;
< 	double toDouble(void) const;
< 
<     protected:
<         // Contains the string info when we're not in SSO mode
<         struct _ptr { 
<             char *   buff;
<             uint16_t cap;
<             uint16_t len;
<         };
<         // This allows strings up up to 11 (10 + \0 termination) without any extra space.
<         enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
<         struct _sso {
<             char     buff[SSOSIZE];
<             unsigned char len   : 7; // Ensure only one byte is allocated by GCC for the bitfields
<             unsigned char isSSO : 1;
<         } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
<         enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
<         union {
<             struct _ptr ptr;
<             struct _sso sso;
<         };
<         // Accessor functions
<         inline bool isSSO() const { return sso.isSSO; }
<         inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
<         inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
<         inline void setSSO(bool set) { sso.isSSO = set; }
<         inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
<         inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
< 	inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
<         // Buffer accessor functions
<         inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
<         inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
< 
<     protected:
<         void init(void);
<         void invalidate(void);
<         unsigned char changeBuffer(unsigned int maxStrLen);
< 
<         // copy and move
<         String & copy(const char *cstr, unsigned int length);
<         String & copy(const __FlashStringHelper *pstr, unsigned int length);
---
>     // returns true on success, false on failure (in which case, the string
>     // is left unchanged).  if the argument is null or invalid, the
>     // concatenation is considered unsuccessful.
>     unsigned char concat(const String &str);
>     unsigned char concat(const char *cstr);
>     unsigned char concat(char c);
>     unsigned char concat(unsigned char c);
>     unsigned char concat(int num);
>     unsigned char concat(unsigned int num);
>     unsigned char concat(long num);
>     unsigned char concat(unsigned long num);
>     unsigned char concat(float num);
>     unsigned char concat(double num);
>     unsigned char concat(const __FlashStringHelper *str);
>     unsigned char concat(const char *cstr, unsigned int length);
> 
>     // if there's not enough memory for the concatenated value, the string
>     // will be left unchanged (but this isn't signalled in any way)
>     String &operator +=(const String &rhs) {
>         concat(rhs);
>         return (*this);
>     }
>     String &operator +=(const char *cstr) {
>         concat(cstr);
>         return (*this);
>     }
>     String &operator +=(char c) {
>         concat(c);
>         return (*this);
>     }
>     String &operator +=(unsigned char num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(int num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(unsigned int num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(long num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(unsigned long num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(float num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(double num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator += (const __FlashStringHelper *str) {
>         concat(str);
>         return (*this);
>     }
> 
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, char c);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, int num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, long num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, float num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, double num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, const __FlashStringHelper *rhs);
> 
>     // comparison (only works w/ Strings and "strings")
>     operator StringIfHelperType() const {
>         return buffer() ? &String::StringIfHelper : 0;
>     }
>     unsigned char operator ==(char ch) const {
>         return equals(ch);
>     }
>     unsigned char operator ==(const String &rhs) const {
>         return equals(rhs);
>     }
>     unsigned char operator ==(const char *cstr) const {
>         return equals(cstr);
>     }
>     unsigned char operator ==(const __FlashStringHelper *fstr) const {
>         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) == 0;
>     }
>     unsigned char operator !=(char ch) const {
>         return !equals(ch);
>     }
>     unsigned char operator !=(const String &rhs) const {
>         return !equals(rhs);
>     }
>     unsigned char operator !=(const char *cstr) const {
>         return !equals(cstr);
>     }
>     unsigned char operator !=(const __FlashStringHelper *fstr) const {
>         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) != 0;
>     }
> 
>     unsigned char operator <(const String &rhs) const;
>     unsigned char operator >(const String &rhs) const;
>     unsigned char operator <=(const String &rhs) const;
>     unsigned char operator >=(const String &rhs) const;
> 
>     int compareTo(const String &s) const;
> 
>     //
>     // equals()
>     //
>     // changed behaviour:
>     // any nullptr argument will return false -> String.equals(nullptr) does not return true if String is empty
> 
>     // the terminating NUL byte is not considered part of the string
>     // String.equals('\0') always returns false, even if String is empty
>     // use length() == 0 to determine if a string is empty
>     unsigned char equals(char ch) const {
>         if (length() != 1 || !ch) {
>             return false;
>         }
>         return buffer()[0] == ch;
>     }
> 
>     unsigned char equals(const String &str) const {
>         if (this == &str) {
>             return true;
>         }
>         if (length() != str.length()) {
>             return false;
>         }
>         return strcmp(buffer(), str.buffer()) == 0;
>     }
> 
>     unsigned char equals(const char *cStr) const {
>         if (!cStr) {
>             return false;
>         }
>         if (length() == 0) {
>             return (*cStr == 0);
>         }
>         return strcmp(buffer(), cStr) == 0;
>     }
> 
>     unsigned char equals(const __FlashStringHelper *fStr) const {
>         if (!fStr) {
>             return false;
>         }
>         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fStr)) == 0;
>     }
> 
>     //
>     // equals() with offset
>     //
> 
>     unsigned char equals(const String &str, size_t offset) const {
>         size_t len1;
>         size_t len2;
>         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
>             return false;
>         }
>         return strcmp(buffer() + offset, str.c_str()) == 0;
>     }
> 
>     unsigned char equals(const char *cStr, size_t offset) const {
>         if (!cStr || !*cStr || offset >= length()) {
>             return false;
>         }
>         return strcmp(buffer() + offset, cStr) == 0;
>     }
> 
>     unsigned char equals(const __FlashStringHelper *fStr, size_t offset) const {
>         if (!fStr || offset >= length()) {
>             return false;
>         }
>         return strcmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
>     }
> 
>     //
>     // equalsIgnoreCase() with offset
>     //
> 
>     unsigned char equalsIgnoreCase(const String &str, size_t offset = 0) const {
>         if (offset == 0 && this == &str) {
>             return true;
>         }
>         size_t len1;
>         size_t len2;
>         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
>             return false;
>         }
>         return strcasecmp(buffer() + offset, str.c_str()) == 0;
>     }
> 
>     unsigned char equalsIgnoreCase(const char *cStr, size_t offset = 0) const {
>         if (!cStr || !*cStr || offset >= length()) {
>             return false;
>         }
>         return strcasecmp(buffer() + offset, cStr) == 0;
>     }
> 
>     unsigned char equalsIgnoreCase(const __FlashStringHelper *fStr, size_t offset = 0) const {
>         if (!fStr || offset >= length()) {
>             return false;
>         }
>         return strcasecmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
>     }
> 
>     //
>     // equalsConstantTime
>     //
> 
>     unsigned char equalsConstantTime(const String &s) const;
> 
>     //
>     // _startsWith
>     //
> 
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWith(const char *prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncmp(c_str() + offset, prefix, prefixLen);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWith_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncmp_P(c_str() + offset, prefix, prefixLen);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWithIgnoreCase(const char *prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp(c_str() + offset, prefix, prefixLen);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWithIgnoreCase_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp_P(c_str() + offset, prefix, prefixLen);
>     }
> 
>     //
>     // startsWith(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
>     //
> 
>     unsigned char startsWith(char ch) const {
>         return (length() != 0) && (buffer()[0] == ch);
>     }
>     unsigned char startsWith(char ch, size_t offset) const {
>         return (length() > offset) && (buffer()[offset] == ch);
>     }
>     unsigned char startsWith(const char *prefix, size_t offset = 0) const {
>         return prefix && _startsWith(prefix, strlen(prefix), offset);
>     }
>     unsigned char startsWith(const String &prefix, size_t offset = 0) const {
>         size_t len;
>         return ((len = prefix.length())) != 0 && _startsWith(prefix.buffer(), len, offset);
>     }
>     unsigned char startsWith(const __FlashStringHelper *prefix, size_t offset = 0) const {
>         return prefix && _startsWith_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
>     }
> 
>     //
>     // startsWithIgnoreCase(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
>     //
> 
>     unsigned char startsWithIgnoreCase(char ch, size_t offset = 0) const {
>         return (length() > offset) && (tolower(buffer()[offset]) == tolower(ch));
>     }
>     unsigned char startsWithIgnoreCase(const char *prefix, size_t offset = 0) const {
>         return prefix && _startsWithIgnoreCase(prefix, strlen(prefix), offset);
>     }
>     unsigned char startsWithIgnoreCase(const String &prefix, size_t offset = 0) const {
>         size_t len;
>         return ((len = prefix.length())) != 0 && _startsWithIgnoreCase(prefix.buffer(), len, offset);
>     }
>     unsigned char startsWithIgnoreCase(const __FlashStringHelper *prefix, size_t offset = 0) const {
>         return prefix && _startsWithIgnoreCase_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
>     }
> 
>     //
>     // _endsWith
>     //
> 
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWith(const char *suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcmp(buffer() + len - suffixLen, suffix);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWith_P(PGM_P suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcmp_P(buffer() + len - suffixLen, suffix);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWithIgnoreCase(const char *suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp(buffer() + len - suffixLen, suffix);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWithIgnoreCase_P(PGM_P suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp_P(buffer() + len - suffixLen, suffix);
>     }
> 
>     //
>     // endsWith
>     //
> 
>     unsigned char endsWith(char ch) const {
>         auto len = length();
>         return (len != 0) && (buffer()[len - 1] == ch);
>     }
>     unsigned char endsWith(const String &suffix) const {
>         return _endsWith(suffix.buffer(), suffix.length());
>     }
>     unsigned char endsWith(const char *suffix) const {
>         return suffix && _endsWith(suffix, strlen(suffix));
>     }
>     unsigned char endsWith(const __FlashStringHelper *suffix) const {
>         return suffix && _endsWith_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
>     }
> 
>     //
>     // endsWithIgnoreCase
>     //
> 
>     unsigned char endsWithIgnoreCase(char ch) const {
>         auto len = length();
>         return (len != 0) && (tolower(buffer()[len - 1]) == tolower(ch));
>     }
>     unsigned char endsWithIgnoreCase(const String &suffix) const {
>         return _endsWithIgnoreCase(suffix.buffer(), suffix.length());
>     }
>     unsigned char endsWithIgnoreCase(const char *suffix) const {
>         return suffix && _endsWithIgnoreCase(suffix, strlen(suffix));
>     }
>     unsigned char endsWithIgnoreCase(const __FlashStringHelper *suffix) const {
>         return suffix && _endsWithIgnoreCase_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
>     }
> 
>     // character access
>     char charAt(unsigned int index) const;
>     void setCharAt(unsigned int index, char c);
>     char operator [](unsigned int index) const;
>     char &operator [](unsigned int index);
>     void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
>     void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
>         getBytes((unsigned char *)buf, bufsize, index);
>     }
>     const char *c_str() const { return buffer(); }
>     char *begin() { return wbuffer(); }
>     char *end() { return wbuffer() + length(); }
>     const char *begin() const { return c_str(); }
>     const char *end() const { return c_str() + length(); }
> 
> protected:
>     // findLength is optional, provide only if available
>     int _indexOf(const char *find, size_t fromIndex, size_t findLength = ~0) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (fromIndex + findLength >= len)) {
>             return -1;
>         }
>         auto ptr = buffer();
>         auto idxPtr = strstr(ptr + fromIndex, find);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _indexOfIgnoreCase(const char *find, size_t fromIndex, size_t findLength = ~0) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (fromIndex + findLength >= len)) {
>             return -1;
>         }
>         auto ptr = wbuffer();
>         auto idxPtr = stristr(ptr + fromIndex, find);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _indexOf_P(PGM_P find, size_t fromIndex, size_t findLength = ~0) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (fromIndex + findLength >= len)) {
>             return -1;
>         }
>         auto ptr = buffer();
>         auto idxPtr = strstr_P(ptr + fromIndex, find);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _indexOfIgnoreCase_P(PGM_P find, size_t fromIndex, size_t findLength = ~0) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (fromIndex + findLength >= len)) {
>             return -1;
>         }
>         auto ptr = buffer();
>         auto idxPtr = stristr_P(ptr + fromIndex, find);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _lastIndexOf(char find) const
>     {
>         auto ptr = strrchr(buffer(), find);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf_P(char find) const
>     {
>         auto ptr = strrchr_P(buffer(), find);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf(char find, size_t fromIndex) const
>     {
>         if (!find) {
>             return -1;
>         }
>         auto len = length();
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex > len || fromIndex < 1) {
>             return -1;
>         }
>         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf_P(char find, size_t fromIndex) const
>     {
>         if (!find) {
>             return -1;
>         }
>         auto len = length();
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex > len || fromIndex < 1) {
>             return -1;
>         }
>         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf_P(PGM_P find, size_t fromIndex, size_t findLen) const
>     {
>         size_t len;
>         if (!find || !(len = length())) {
>             return -1;
>         }
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex < findLen || fromIndex > len) {
>             return -1;
>         }
>         auto ptr = __strrstr_P(wbuffer(), fromIndex + findLen, find, findLen);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf(const char *find, size_t fromIndex, size_t findLen) const
>     {
>         size_t len;
>         if (!find || !(len = length())) {
>             return -1;
>         }
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex < findLen || fromIndex > len) {
>             return -1;
>         }
>         auto ptr = __strrstr(wbuffer(), fromIndex + findLen, find, findLen);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
> 
> public:
>     // search
>     int indexOf(char ch, unsigned int fromIndex) const;
>     int indexOf(const String &str) const;
>     int indexOf(const String &str, unsigned int fromIndex) const;
> 
>     int indexOf(char c) const {
>         return indexOf(c, 0);
>     }
> 
>     int indexOf(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOf(str, fromIndex);
>     }
>     int indexOf(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOf_P(reinterpret_cast<PGM_P>(fstr), fromIndex);
>     }
> 
> 
>     int indexOfIgnoreCase(char c) const {
>         return indexOfIgnoreCase(c, 0);
>     }
> 
>     int indexOfIgnoreCase(char ch, unsigned int fromIndex) const {
>         if (fromIndex >= len())
>             return -1;
>         const char *temp = strichr(buffer() + fromIndex, ch);
>         if (temp == NULL)
>             return -1;
>         return temp - buffer();
>     }
> 
> 
>     int indexOfIgnoreCase(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str, fromIndex);
>     }
>     int indexOfIgnoreCase(const String &str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str.c_str(), fromIndex, str.length());
>     }
>     int indexOfIgnoreCase(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase_P(reinterpret_cast<PGM_P>(fstr), fromIndex);
>     }
> 
> 
>     int lastIndexOf(char ch) const {
>         return _lastIndexOf(ch);
>     }
>     int lastIndexOf(char ch, unsigned int fromIndex) const {
>         return _lastIndexOf(ch, fromIndex);
>     }
>     int lastIndexOf(const String &str) const {
>         auto strLen = str.length();
>         return _lastIndexOf(str.buffer(), length() - strLen, strLen);
>     }
>     int lastIndexOf(const String &str, unsigned int fromIndex) const {
>         return _lastIndexOf(str.buffer(), fromIndex, str.length());
>     }
>     int lastIndexOf(const __FlashStringHelper *str, unsigned int fromIndex) const {
>         return _lastIndexOf_P(reinterpret_cast<PGM_P>(str), fromIndex, strlen_P(reinterpret_cast<PGM_P>(str)));
>     }
> 
>     String substring(unsigned int beginIndex) const {
>         return substring(beginIndex, len());
>     }
>     String substring(unsigned int beginIndex, unsigned int endIndex) const;
> 
>     // PROGMEM safe
>     // returns false on failure
>     bool insert(size_t pos, PGM_P insert, size_t insertLen);
> 
>     inline bool insert(size_t pos, PGM_P str) {
>         return insert(pos, str, strlen_P(str));
>     }
>     inline bool insert(size_t pos, const __FlashStringHelper *fstr) {
>         return insert(pos, reinterpret_cast<PGM_P>(fstr), strlen_P(reinterpret_cast<PGM_P>(fstr)));
>     }
>     inline bool insert(size_t pos, const String &str) {
>         return insert(pos, str.buffer(), str.length());
>     }
> 
>     // modification
>     bool replace(char find, char replace);
> 
> protected:
>     bool _replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen);
> 
> public:
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const char *replace) {
>         return _replace(find, strlen(find), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const __FlashStringHelper *replace) {
>         return _replace(find, strlen(find), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const String &replace) {
>         return _replace(find, strlen(find), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const String &replace) {
>         return _replace(find.buffer(), find.length(), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const char *replace) {
>         return _replace(find.buffer(), find.length(), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const __FlashStringHelper *replace) {
>         return _replace(find.buffer(), find.length(), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const String &replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const char *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const __FlashStringHelper *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
> 
>     void remove(unsigned int index);
>     void remove(unsigned int index, unsigned int count);
> 
>     String &toLowerCase(void);
>     String &toUpperCase(void);
> 
> protected:
>     enum class TrimType : uint8_t {
>         LEFT = 0x01,
>         RIGHT = 0x02,
>         BOTH = LEFT | RIGHT
>     };
> 
>     String &_trim(TrimType type);
>     inline String &_trim(TrimType type, char character) {
>         char buf[2] = { character, 0 };
>         return _trim(type, buf, 1);
>     }
>     String &_trim(TrimType type, PGM_P characters, size_t charLen);
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const char *characters) {
>         return _trim(type, characters, strlen(characters));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const __FlashStringHelper *characters) {
>         return _trim(type, reinterpret_cast<PGM_P>(characters), strlen_P(reinterpret_cast<PGM_P>(characters)));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const String &characters) {
>         return _trim(type, characters.c_str(), characters.length());
>     }
> 
> public:
>     inline __attribute__((__always_inline__))
>         String &trim() {
>         return _trim(TrimType::BOTH);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim() {
>         return _trim(TrimType::RIGHT);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim() {
>         return _trim(TrimType::LEFT);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(char character) {
>         return _trim(TrimType::BOTH, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(char character) {
>         return _trim(TrimType::RIGHT, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(char character) {
>         return _trim(TrimType::LEFT, character);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(const char *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const String &characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &rtrim(const char *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const String &characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &ltrim(const char *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const String &characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
> 
>     // parsing/conversion
>     long toInt(void) const;
>     float toFloat(void) const;
> 
>     inline __attribute__((__always_inline__))
>         double toDouble(void) const {
>         return toFloat();
>     }
> 
> protected:
>     // Contains the string info when we're not in SSO mode
>     struct _ptr {
>         char *buff;
>         uint16_t cap;
>         uint16_t len;
>     };
>     // This allows strings up up to 11 (10 + \0 termination) without any extra space.
>     enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
>     struct _sso {
>         char     buff[SSOSIZE];
>         unsigned char len : 7; // Ensure only one byte is allocated by GCC for the bitfields
>         unsigned char isSSO : 1;
>     } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
>     enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
>     union {
>         struct _ptr ptr;
>         struct _sso sso;
>     };
>     // Accessor functions
>     inline bool isSSO() const { return sso.isSSO; }
>     inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
>     inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
>     inline void setSSO(bool set) { sso.isSSO = set; }
>     inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
>     inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
>     inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
>     // Buffer accessor functions
>     inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
>     inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> 
> protected:
>     void init(void);
>     void invalidate(void);
>     unsigned char changeBuffer(unsigned int maxStrLen);
> 
>     // copy and move
>     String &copy(const char *cstr, unsigned int length);
>     String &copy(const __FlashStringHelper *pstr, unsigned int length);
320c893
<         void move(String &rhs);
---
>     void move(String &rhs);
324,355c897,928
< class StringSumHelper: public String {
<     public:
<         StringSumHelper(const String &s) :
<                 String(s) {
<         }
<         StringSumHelper(const char *p) :
<                 String(p) {
<         }
<         StringSumHelper(char c) :
<                 String(c) {
<         }
<         StringSumHelper(unsigned char num) :
<                 String(num) {
<         }
<         StringSumHelper(int num) :
<                 String(num) {
<         }
<         StringSumHelper(unsigned int num) :
<                 String(num) {
<         }
<         StringSumHelper(long num) :
<                 String(num) {
<         }
<         StringSumHelper(unsigned long num) :
<                 String(num) {
<         }
<         StringSumHelper(float num) :
<                 String(num) {
<         }
<         StringSumHelper(double num) :
<                 String(num) {
<         }
---
> class StringSumHelper : public String {
> public:
>     StringSumHelper(const String &s) :
>         String(s) {
>     }
>     StringSumHelper(const char *p) :
>         String(p) {
>     }
>     StringSumHelper(char c) :
>         String(c) {
>     }
>     StringSumHelper(unsigned char num) :
>         String(num) {
>     }
>     StringSumHelper(int num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned int num) :
>         String(num) {
>     }
>     StringSumHelper(long num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned long num) :
>         String(num) {
>     }
>     StringSumHelper(float num) :
>         String(num) {
>     }
>     StringSumHelper(double num) :
>         String(num) {
>     }
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/libraries/ArduinoOTA/ArduinoOTA.h ./framework-arduinoespressif8266/libraries/ArduinoOTA/ArduinoOTA.h
23a24,27
> namespace WebServer{
>     class Plugin;
> }
> 
71a76,77
>     friend WebServer::Plugin;
> 
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/libraries/ESP8266mDNS/src/LEAmDNS.h ./framework-arduinoespressif8266/libraries/ESP8266mDNS/src/LEAmDNS.h
523a524,526
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
1440a1444,1446
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
