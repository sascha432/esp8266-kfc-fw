diff -r -Z -P4 ./framework-arduinoespressif8266_orig/* ./framework-arduinoespressif8266/*
0a1,2513
> 
>  This library is free software; you can redistribute it and/or
>  modify it under the terms of the GNU Lesser General Public
>  License as published by the Free Software Foundation; either
>  version 2.1 of the License, or (at your option) any later version.
> 
>  This library is distributed in the hope that it will be useful,
>  but WITHOUT ANY WARRANTY; without even the implied warranty of
>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
>  Lesser General Public License for more details.
> 
>  You should have received a copy of the GNU Lesser General Public
>  License along with this library; if not, write to the Free Software
>  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
>  */
> 
> #ifdef _MSC_VER
> #include <Arduino_compat.h>
> #include "cores/esp8266/WString.h"
> #include "util/stdlib_noniso.h"
> #else
> #pragma once
> 
> namespace WebServer{
>     class Plugin;
> }
> 
> #include <Arduino.h>
> #include "WString.h"
> #include "stdlib_noniso.h"
> #endif
> #ifdef _MSC_VER
> #include <misc_string.h>
> #else
> 
>  /*********************************************/
>  /*  Constructors                             */
>  /*********************************************/
> #include "KFCBaseLibrary/include/misc_string.h"
> #endif
> 
> String::String(const char *cstr) {
>     init();
>     if (cstr)
>         copy(cstr, strlen(cstr));
> }
> 
> String::String(const String &value) {
> #ifndef FPSTR
>     init();
> #endif
> #ifndef F
>     *this = value;
> #endif
> }
> 
> String::String(const __FlashStringHelper *pstr) {
>     init();
>     *this = pstr; // see operator =
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String::String(String &&rval) {
>     init();
>     move(rval);
> }
> 
> String::String(StringSumHelper &&rval) {
>     init();
>     move(rval);
> }
> #endif
> 
> String::String(char c) {
>     init();
>     friend WebServer::Plugin;
> 
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     *this = buf;
> }
> 
> String::String(unsigned char value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned char)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(int value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(int)];
>     if (base == 10) {
>         sprintf(buf, "%d", value);
>     }
>     else {
>         itoa(value, buf, base);
>     }
>     *this = buf;
> }
> 
> String::String(unsigned int value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned int)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(long value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(long)];
>     if (base == 10) {
>         sprintf(buf, "%ld", value);
>     }
>     else {
>         ltoa(value, buf, base);
>     }
>     explicit String(char c);
>     explicit String(unsigned char, unsigned char base = 10);
>     explicit String(int, unsigned char base = 10);
>     explicit String(unsigned int, unsigned char base = 10);
>     explicit String(long, unsigned char base = 10);
>     explicit String(unsigned long, unsigned char base = 10);
>     explicit String(float, unsigned char decimalPlaces = 2);
>     explicit String(double, unsigned char decimalPlaces = 2);
>     ~String(void);
>     *this = buf;
> }
> 
> String::String(unsigned long value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned long)];
>     ultoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(float value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::String(double value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::~String() {
>     invalidate();
> }
> 
> // /*********************************************/
> // /*  Memory Management                        */
> // /*********************************************/
> 
> void String::invalidate(void) {
>     if (!isSSO() && wbuffer())
>         free(wbuffer());
>     init();
> }
> 
> unsigned char String::reserve(unsigned int size) {
>     if (buffer() && capacity() >= size)
>         return 1;
>     if (changeBuffer(size)) {
>         if (len() == 0)
>             wbuffer()[0] = 0;
>         return 1;
>     }
>     return 0;
> }
> 
> unsigned char String::changeBuffer(unsigned int maxStrLen) {
>     // Can we use SSO here to avoid allocation?
>     if (maxStrLen < sizeof(sso.buff) - 1) {
>         if (isSSO() || !buffer()) {
>             // Already using SSO, nothing to do
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             return 1;
>         }
>         else { // if bufptr && !isSSO()
>          // Using bufptr, need to shrink into sso.buff
>             char temp[sizeof(sso.buff)];
>             memcpy(temp, buffer(), maxStrLen);
>             free(wbuffer());
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             memcpy(wbuffer(), temp, maxStrLen);
>             return 1;
>         }
>     }
>     // Fallthrough to normal allocator
>     size_t newSize = (maxStrLen + 16) & (~0xf);
>     // Make sure we can fit newsize in the buffer
>     if (newSize > CAPACITY_MAX) {
>         return false;
>     }
>     uint16_t oldLen = len();
>     char *newbuffer = (char *)realloc(isSSO() ? nullptr : wbuffer(), newSize);
>     if (newbuffer) {
>         size_t oldSize = capacity() + 1; // include NULL.
>         if (isSSO()) {
>             // Copy the SSO buffer into allocated space
>             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
>         }
>         if (newSize > oldSize)
>         {
>             memset(newbuffer + oldSize, 0, newSize - oldSize);
>         }
>         setSSO(false);
>         setCapacity(newSize - 1);
>         setLen(oldLen); // Needed in case of SSO where len() never existed
>         setBuffer(newbuffer);
>         return 1;
>     }
>     return 0;
> }
> 
> // /*********************************************/
> // /*  Copy and Move                            */
> // /*********************************************/
> 
> String &String::copy(const char *cstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memmove_P(wbuffer(), cstr, length + 1);
>     return *this;
> }
> 
> String &String::copy(const __FlashStringHelper *pstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> void String::move(String &rhs) {
>     if (buffer()) {
>         if (capacity() >= rhs.len()) {
>             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
>             setLen(rhs.len());
>             rhs.invalidate();
>             return;
>         }
>         else {
>             if (!isSSO()) {
>                 free(wbuffer());
>                 setBuffer(nullptr);
>             }
>         }
>     }
>     if (rhs.isSSO()) {
>         setSSO(true);
>         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
>     }
>     else {
>         setSSO(false);
>         setBuffer(rhs.wbuffer());
>     }
>     setCapacity(rhs.capacity());
>     setLen(rhs.len());
>     rhs.setSSO(false);
>     rhs.setCapacity(0);
>     rhs.setLen(0);
>     rhs.setBuffer(nullptr);
> }
> #endif
> 
> String &String::operator =(const String &rhs) {
>     if (this == &rhs)
>         return *this;
> 
>     if (rhs.buffer())
>         copy(rhs.buffer(), rhs.len());
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String &String::operator =(String &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> 
> String &String::operator =(StringSumHelper &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> #endif
> 
> String &String::operator =(const char *cstr) {
>     if (cstr)
>         copy(cstr, strlen(cstr));
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> String &String::operator = (const __FlashStringHelper *pstr)
> {
>     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
>     else invalidate();
> 
>     return *this;
> }
> 
> // /*********************************************/
> // /*  concat                                   */
> // /*********************************************/
> 
> unsigned char String::concat(const String &s) {
>     // Special case if we're concatting ourself (s += s;) since we may end up
>     // realloc'ing the buffer and moving s.buffer in the method called
>     if (&s == this) {
>         unsigned int newlen = 2 * len();
>         if (!s.buffer())
>             return 0;
>         if (s.len() == 0)
>             return 1;
>         if (!reserve(newlen))
>             return 0;
>         memmove_P(wbuffer() + len(), buffer(), len());
>         setLen(newlen);
>         wbuffer()[len()] = 0;
>         return 1;
>     }
>     else {
>         return concat(s.buffer(), s.len());
>     }
> }
> 
> unsigned char String::concat(const char *cstr, unsigned int length) {
>     unsigned int newlen = len() + length;
>     if (!cstr)
>         return 0;
>     if (length == 0)
>         return 1;
>     if (!reserve(newlen))
>         return 0;
>     memmove_P(wbuffer() + len(), cstr, length + 1);
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return 1;
> }
> 
> unsigned char String::concat(const char *cstr) {
>     if (!cstr)
>         return 0;
>     return concat(cstr, strlen(cstr));
> }
> 
> unsigned char String::concat(char c) {
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     return concat(buf, 1);
> }
> 
> unsigned char String::concat(unsigned char num) {
>     char buf[1 + 3 * sizeof(unsigned char)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(int num) {
>     char buf[2 + 3 * sizeof(int)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned int num) {
>     char buf[1 + 3 * sizeof(unsigned int)];
>     utoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(long num) {
>     char buf[2 + 3 * sizeof(long)];
>     sprintf(buf, "%ld", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned long num) {
>     char buf[1 + 3 * sizeof(unsigned long)];
>     ultoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(float num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(double num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(const __FlashStringHelper *str) {
>     if (!str) return 0;
>     int length = strlen_P((PGM_P)str);
>     if (length == 0) return 1;
>     unsigned int newlen = len() + length;
>     if (!reserve(newlen)) return 0;
>     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
>     setLen(newlen);
>     return 1;
> }
> 
> /*********************************************/
> /*  Concatenate                              */
> /*********************************************/
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs.buffer(), rhs.len()))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!cstr || !a.concat(cstr, strlen(cstr)))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, char c) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(c))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, float num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, double num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs))
>         a.invalidate();
>     return a;
> }
> 
> // /*********************************************/
> // /*  Comparison                               */
> // /*********************************************/
> 
> int String::compareTo(const String &s) const {
>     if (!buffer() || !s.buffer()) {
>         if (s.buffer() && s.len() > 0)
>             return 0 - *(unsigned char *)s.buffer();
>         if (buffer() && len() > 0)
>             return *(unsigned char *)buffer();
>         return 0;
>     }
>     return strcmp(buffer(), s.buffer());
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
> }
> 
> 
> unsigned char String::operator<(const String &rhs) const {
>     return compareTo(rhs) < 0;
> }
> 
> unsigned char String::operator>(const String &rhs) const {
>     return compareTo(rhs) > 0;
> }
> 
> unsigned char String::operator<=(const String &rhs) const {
>     return compareTo(rhs) <= 0;
> }
> 
> unsigned char String::operator>=(const String &rhs) const {
>     return compareTo(rhs) >= 0;
> }
> 
> unsigned char String::equalsConstantTime(const String &s2) const {
>     // To avoid possible time-based attacks present function
>     // compares given strings in a constant time.
>     if (len() != s2.len())
>         return 0;
>     //at this point lengths are the same
>     if (len() == 0)
>         return 1;
>     //at this point lenghts are the same and non-zero
>     const char *p1 = buffer();
>     const char *p2 = s2.buffer();
>     unsigned int equalchars = 0;
>     unsigned int diffchars = 0;
>     while (*p1) {
>         if (*p1 == *p2)
>             ++equalchars;
>         else
>             ++diffchars;
>         ++p1;
>         ++p2;
>     }
>     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
>     unsigned char equalcond = (equalchars == len());
>     unsigned char diffcond = (diffchars == 0);
>     return (equalcond & diffcond); //bitwise AND
> }
> 
> // unsigned char String::startsWith(const String &s2) const {
> //     if(len() < s2.len())
> //         return 0;
> //     return startsWith(s2, 0);
> // }
> 
> // unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> //     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> //         return 0;
> //     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> // }
> 
> // /*********************************************/
> // /*  Character Access                         */
> // /*********************************************/
> 
> char String::charAt(unsigned int loc) const {
>     return operator[](loc);
> }
> 
> void String::setCharAt(unsigned int loc, char c) {
>     if (loc < len())
>         wbuffer()[loc] = c;
> }
> 
> char &String::operator[](unsigned int index) {
>     static char dummy_writable_char;
>     if (index >= len() || !buffer()) {
>         dummy_writable_char = 0;
>         return dummy_writable_char;
>     }
>     return wbuffer()[index];
> }
> 
> char String::operator[](unsigned int index) const {
>     if (index >= len() || !buffer())
>         return 0;
>     return buffer()[index];
> }
> 
> void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
>     if (!bufsize || !buf)
>         return;
>     if (index >= len()) {
>         buf[0] = 0;
>         return;
>     }
>     unsigned int n = bufsize - 1;
>     if (n > len() - index)
>         n = len() - index;
>     strncpy((char *)buf, buffer() + index, n);
>     buf[n] = 0;
> }
> 
> // /*********************************************/
> // /*  Search                                   */
> // /*********************************************/
> 
> int String::indexOf(char ch, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *temp = strchr(buffer() + fromIndex, ch);
>     if (temp == NULL)
>         return -1;
>     return temp - buffer();
> }
> 
> int String::indexOf(const String &s2) const {
>     return indexOf(s2, 0);
> }
> 
> int String::indexOf(const String &s2, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *found = strstr(buffer() + fromIndex, s2.buffer());
>     if (found == NULL)
>         return -1;
>     return found - buffer();
> }
> 
> String String::substring(unsigned int left, unsigned int right) const {
>     if (left > right) {
>         unsigned int temp = right;
>         right = left;
>         left = temp;
>     }
>     String out;
>     if (left >= len())
>         return out;
>     if (right > len())
>         right = len();
>     char temp = buffer()[right];  // save the replaced character
>     wbuffer()[right] = '\0';
>     out = wbuffer() + left;  // pointer arithmetic
>     wbuffer()[right] = temp;  //restore character
>     return out;
> }
> 
> // /*********************************************/
> // /*  Modification                             */
> // /*********************************************/
> 
> bool String::insert(size_t pos, PGM_P insert, size_t insertLen) {
>     size_t len;
>     if (insertLen == 0 || (len = length()) == 0 || pos >= len) {
>         return false;
>     }
>     auto requiredLen = len + insertLen;
>     if (!reserve(requiredLen)) {
>         return false;
>     }
>     setLen(requiredLen);
>     memmove(wbuffer() + pos + insertLen, wbuffer() + pos, len - pos/* + 1 NUL byte*/);
>     memmove_P(wbuffer() + pos, insert, insertLen);
>     wbuffer()[requiredLen] = 0;
>     return true;
> }
> 
> 
> bool String::replace(char find, char replace)
> {
>     if (!buffer())
>         return true;
>     for (char *p = wbuffer(); *p; p++) {
>         if (*p == find) {
>             *p = replace;
>         }
>     }
>     return true;
> }
> 
> bool String::_replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen)
> {
>     if (length() == 0 || findLen == 0 || !find) {
>         return false;
>     }
>     int diff = replaceLen - findLen;
>     char *readFrom = wbuffer();
>     char *foundAt;
>     if (diff == 0) {
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             memmove_P(foundAt, replace, replaceLen);
>             readFrom = foundAt + replaceLen;
>         }
>     }
>     else if (diff < 0) {
>         char *writeTo = wbuffer();
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             unsigned int n = foundAt - readFrom;
>             memmove(writeTo, readFrom, n);
>             writeTo += n;
>             memmove_P(writeTo, replace, replaceLen);
>             writeTo += replaceLen;
>             readFrom = foundAt + findLen;
>             setLen(len() + diff);
>         }
>         memmove(writeTo, readFrom, strlen(readFrom) + 1);
>     }
>     else {
>         unsigned int size = len(); // compute size needed for result
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             readFrom = foundAt + findLen;
>             size += diff;
>         }
>         if (size == len()) {
>             return true;
>         }
>         if (size > capacity() && !changeBuffer(size)) {
>             return false;
>         }
>         int index = len() - 1;
>         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
>             readFrom = wbuffer() + index + findLen;
>             memmove(readFrom + diff, readFrom, len() - (readFrom - buffer()));
>             int newLen = len() + diff;
>             memmove_P(wbuffer() + index, replace, replaceLen);
>             setLen(newLen);
>             wbuffer()[newLen] = 0;
>             index--;
>         }
>     }
>     return true;
> }
> 
> void String::remove(unsigned int index) {
>     // Pass the biggest integer as the count. The remove method
>     // below will take care of truncating it at the end of the
>     // string.
>     remove(index, (unsigned int)-1);
> }
> 
> void String::remove(unsigned int index, unsigned int count) {
>     if (index >= len()) {
>         return;
>     }
>     if (count <= 0) {
>         return;
>     }
>     if (count > len() - index) {
>         count = len() - index;
>     }
>     char *writeTo = wbuffer() + index;
>     unsigned int newlen = len() - count;
>     setLen(newlen);
>     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
>     wbuffer()[newlen] = 0;
> }
> 
> String &String::toLowerCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = tolower(*p);
>     }
>     return *this;
> }
> 
> String &String::toUpperCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = toupper(*p);
>     }
>     return *this;
> }
> 
> 
> String &String::_trim(TrimType type)
> {
>     auto len = length();
>     if (len == 0) {
>         return *this;
>     }
>     char *begin = wbuffer();
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         while (isspace(*begin)) {
>             begin++;
>         }
>     }
>     char *end = wbuffer() + len - 1;
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (isspace(*end) && end >= begin) {
>             end--;
>         }
>     }
>     unsigned int newlen = end + 1 - begin;
>     if (begin > buffer()) {
>         memmove(wbuffer(), begin, newlen);
>     }
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return *this;
> }
> 
> String &String::_trim(TrimType type, PGM_P characters, size_t charLen)
> {
>     auto len = length();
>     if (!len || !characters || !charLen) {
>         return *this;
>     }
>     charLen++; // use memchr instead of strchr to avoid additional NUL byte check
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (len && memchr_P(characters, buffer()[len - 1], charLen)) {
>             len--;
>         }
>         setLen(len);
>     }
> 
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         size_t remove = 0;
>         while (memchr_P(characters, buffer()[remove], charLen)) {
>             remove++;
>         }
>         this->remove(0, remove); // remove adds NUL byte
>     }
>     else {
>         wbuffer()[len] = 0;
>     }
>     return *this;
> }
> 
> 
> // /*********************************************/
> // /*  Parsing / Conversion                     */
> // /*********************************************/
> 
> long String::toInt(void) const
> {
>     if (buffer()) {
>         return atol(buffer());
>     }
>     return 0;
> }
> 
> float String::toFloat(void) const
> {
>     if (buffer()) {
>         return atof(buffer());
>     }
>     return 0;
> }
> 
> // global empty string to allow returning const String& with nothing
> 
> const String emptyString;
> 
> #include "WStringEx.cpp"
> 
>  This library is free software; you can redistribute it and/or
>  modify it under the terms of the GNU Lesser General Public
>  License as published by the Free Software Foundation; either
>  version 2.1 of the License, or (at your option) any later version.
> 
>  This library is distributed in the hope that it will be useful,
>  but WITHOUT ANY WARRANTY; without even the implied warranty of
>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
>  Lesser General Public License for more details.
> 
>  You should have received a copy of the GNU Lesser General Public
>  License along with this library; if not, write to the Free Software
>  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
>  */
> 
> #ifdef _MSC_VER
> #include <Arduino_compat.h>
> #include "cores/esp8266/WString.h"
> #include "util/stdlib_noniso.h"
> #else
> #pragma once
> 
> namespace WebServer{
>     class Plugin;
> }
> 
> #include <Arduino.h>
> #include "WString.h"
> #include "stdlib_noniso.h"
> #endif
> #ifdef _MSC_VER
> #include <misc_string.h>
> #else
> 
>  /*********************************************/
>  /*  Constructors                             */
>  /*********************************************/
> #include "KFCBaseLibrary/include/misc_string.h"
> #endif
> 
> String::String(const char *cstr) {
>     init();
>     if (cstr)
>         copy(cstr, strlen(cstr));
> }
> 
> String::String(const String &value) {
> #ifndef FPSTR
>     init();
> #endif
> #ifndef F
>     *this = value;
> #endif
> }
> 
> String::String(const __FlashStringHelper *pstr) {
>     init();
>     *this = pstr; // see operator =
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String::String(String &&rval) {
>     init();
>     move(rval);
> }
> 
> String::String(StringSumHelper &&rval) {
>     init();
>     move(rval);
> }
> #endif
> 
> String::String(char c) {
>     init();
>     friend WebServer::Plugin;
> 
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     *this = buf;
> }
> 
> String::String(unsigned char value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned char)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(int value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(int)];
>     if (base == 10) {
>         sprintf(buf, "%d", value);
>     }
>     else {
>         itoa(value, buf, base);
>     }
>     *this = buf;
> }
> 
> String::String(unsigned int value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned int)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(long value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(long)];
>     if (base == 10) {
>         sprintf(buf, "%ld", value);
>     }
>     else {
>         ltoa(value, buf, base);
>     }
>     explicit String(char c);
>     explicit String(unsigned char, unsigned char base = 10);
>     explicit String(int, unsigned char base = 10);
>     explicit String(unsigned int, unsigned char base = 10);
>     explicit String(long, unsigned char base = 10);
>     explicit String(unsigned long, unsigned char base = 10);
>     explicit String(float, unsigned char decimalPlaces = 2);
>     explicit String(double, unsigned char decimalPlaces = 2);
>     ~String(void);
>     *this = buf;
> }
> 
> String::String(unsigned long value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned long)];
>     ultoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(float value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::String(double value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::~String() {
>     invalidate();
> }
> 
> // /*********************************************/
> // /*  Memory Management                        */
> // /*********************************************/
> 
> void String::invalidate(void) {
>     if (!isSSO() && wbuffer())
>         free(wbuffer());
>     init();
> }
> 
> unsigned char String::reserve(unsigned int size) {
>     if (buffer() && capacity() >= size)
>         return 1;
>     if (changeBuffer(size)) {
>         if (len() == 0)
>             wbuffer()[0] = 0;
>         return 1;
>     }
>     return 0;
> }
> 
> unsigned char String::changeBuffer(unsigned int maxStrLen) {
>     // Can we use SSO here to avoid allocation?
>     if (maxStrLen < sizeof(sso.buff) - 1) {
>         if (isSSO() || !buffer()) {
>             // Already using SSO, nothing to do
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             return 1;
>         }
>         else { // if bufptr && !isSSO()
>          // Using bufptr, need to shrink into sso.buff
>             char temp[sizeof(sso.buff)];
>             memcpy(temp, buffer(), maxStrLen);
>             free(wbuffer());
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             memcpy(wbuffer(), temp, maxStrLen);
>             return 1;
>         }
>     }
>     // Fallthrough to normal allocator
>     size_t newSize = (maxStrLen + 16) & (~0xf);
>     // Make sure we can fit newsize in the buffer
>     if (newSize > CAPACITY_MAX) {
>         return false;
>     }
>     uint16_t oldLen = len();
>     char *newbuffer = (char *)realloc(isSSO() ? nullptr : wbuffer(), newSize);
>     if (newbuffer) {
>         size_t oldSize = capacity() + 1; // include NULL.
> #ifdef HAVE_KFC_FIRMWARE_VERSION
> extern Stream &Serial;
> #else
>         if (isSSO()) {
> #endif
>             // Copy the SSO buffer into allocated space
>             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
>         }
>         if (newSize > oldSize)
>         {
>             memset(newbuffer + oldSize, 0, newSize - oldSize);
>         }
>         setSSO(false);
>         setCapacity(newSize - 1);
>         setLen(oldLen); // Needed in case of SSO where len() never existed
>         setBuffer(newbuffer);
>         return 1;
>     }
>     return 0;
> }
>     }
> 
> // /*********************************************/
> // /*  Copy and Move                            */
> // /*********************************************/
> 
> String &String::copy(const char *cstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memmove_P(wbuffer(), cstr, length + 1);
>     return *this;
> }
> 
> String &String::copy(const __FlashStringHelper *pstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> void String::move(String &rhs) {
>     if (buffer()) {
>         if (capacity() >= rhs.len()) {
>             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
>             setLen(rhs.len());
>             rhs.invalidate();
>             return;
>         }
>         else {
>             if (!isSSO()) {
>                 free(wbuffer());
>                 setBuffer(nullptr);
>             }
>         }
>     }
>     if (rhs.isSSO()) {
>         setSSO(true);
>         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
>     }
>     else {
>         setSSO(false);
>         setBuffer(rhs.wbuffer());
>     }
>     setCapacity(rhs.capacity());
>     setLen(rhs.len());
>     rhs.setSSO(false);
>     rhs.setCapacity(0);
>     rhs.setLen(0);
>     rhs.setBuffer(nullptr);
> }
> #endif
> 
> String &String::operator =(const String &rhs) {
>     if (this == &rhs)
>         return *this;
> 
>     if (rhs.buffer())
>         copy(rhs.buffer(), rhs.len());
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String &String::operator =(String &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> 
> String &String::operator =(StringSumHelper &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> #endif
> 
> String &String::operator =(const char *cstr) {
>     if (cstr)
>         copy(cstr, strlen(cstr));
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> String &String::operator = (const __FlashStringHelper *pstr)
> {
>     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
>     else invalidate();
> 
>     return *this;
> }
> 
> // /*********************************************/
> // /*  concat                                   */
> // /*********************************************/
> 
> unsigned char String::concat(const String &s) {
>     // Special case if we're concatting ourself (s += s;) since we may end up
>     // realloc'ing the buffer and moving s.buffer in the method called
>     if (&s == this) {
>         unsigned int newlen = 2 * len();
>         if (!s.buffer())
>             return 0;
>         if (s.len() == 0)
>             return 1;
>         if (!reserve(newlen))
>             return 0;
>         memmove_P(wbuffer() + len(), buffer(), len());
>         setLen(newlen);
>         wbuffer()[len()] = 0;
>         return 1;
>     }
>     else {
>         return concat(s.buffer(), s.len());
>     }
> }
> 
> unsigned char String::concat(const char *cstr, unsigned int length) {
>     unsigned int newlen = len() + length;
>     if (!cstr)
>         return 0;
>     if (length == 0)
>         return 1;
>     if (!reserve(newlen))
>         return 0;
>     memmove_P(wbuffer() + len(), cstr, length + 1);
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return 1;
> }
> 
> unsigned char String::concat(const char *cstr) {
>     if (!cstr)
>         return 0;
>     return concat(cstr, strlen(cstr));
> }
> 
> unsigned char String::concat(char c) {
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     return concat(buf, 1);
> }
> 
> unsigned char String::concat(unsigned char num) {
>     char buf[1 + 3 * sizeof(unsigned char)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
>         return ptr - buffer();
>     }
> 
> 
> public:
>     // search
>     int indexOf(char ch, unsigned int fromIndex) const;
>     int indexOf(const String &str) const;
>     int indexOf(const String &str, unsigned int fromIndex) const;
> 
>     int indexOf(char c) const {
>         return indexOf(c, 0);
>     }
> 
>     int indexOf(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOf(str, fromIndex, ~0U);
>     }
>     int indexOf(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOf_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int indexOfIgnoreCase(char c) const {
>         return indexOfIgnoreCase(c, 0);
>     }
> 
>     int indexOfIgnoreCase(char ch, unsigned int fromIndex) const {
>         if (fromIndex >= len())
>             return -1;
>         const char *temp = strichr(buffer() + fromIndex, ch);
>         if (temp == NULL)
>             return -1;
>         return temp - buffer();
>     }
> 
> 
>     int indexOfIgnoreCase(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str, fromIndex, ~0U);
>     }
>     int indexOfIgnoreCase(const String &str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str.c_str(), fromIndex, str.length());
>     }
>     int indexOfIgnoreCase(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int lastIndexOf(char ch) const {
>         return _lastIndexOf(ch);
>     }
>     int lastIndexOf(char ch, unsigned int fromIndex) const {
>         return _lastIndexOf(ch, fromIndex);
>     }
>     int lastIndexOf(const String &str) const {
>         auto strLen = str.length();
>         return _lastIndexOf(str.buffer(), length() - strLen, strLen);
>     }
>     int lastIndexOf(const String &str, unsigned int fromIndex) const {
>         auto findLength = str.length();
>         return _lastIndexOf(str.buffer(), fromIndex - findLength, findLength);
>     }
>     int lastIndexOf(const __FlashStringHelper *str, unsigned int fromIndex) const {
>         auto findLength = strlen_P(reinterpret_cast<PGM_P>(str));
>         return _lastIndexOf_P(reinterpret_cast<PGM_P>(str), fromIndex - findLength, findLength);
>     }
> 
>     String substring(unsigned int beginIndex) const {
>         return substring(beginIndex, len());
>     }
>     String substring(unsigned int beginIndex, unsigned int endIndex) const;
> 
>     // PROGMEM safe
>     // returns false on failure
>     bool insert(size_t pos, PGM_P insert, size_t insertLen);
> 
>     inline bool insert(size_t pos, PGM_P str) {
>         return insert(pos, str, strlen_P(str));
>     }
>     inline bool insert(size_t pos, const __FlashStringHelper *fstr) {
>         return insert(pos, reinterpret_cast<PGM_P>(fstr), strlen_P(reinterpret_cast<PGM_P>(fstr)));
>     }
>     inline bool insert(size_t pos, const String &str) {
>         return insert(pos, str.buffer(), str.length());
>     }
> 
>     // modification
>     bool replace(char find, char replace);
> 
> protected:
>     bool _replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen);
> 
> public:
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const char *replace) {
>         return _replace(find, strlen(find), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const __FlashStringHelper *replace) {
>         return _replace(find, strlen(find), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const String &replace) {
>         return _replace(find, strlen(find), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const String &replace) {
>         return _replace(find.buffer(), find.length(), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const char *replace) {
>         return _replace(find.buffer(), find.length(), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const __FlashStringHelper *replace) {
>         return _replace(find.buffer(), find.length(), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const String &replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const char *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const __FlashStringHelper *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
> 
>     void remove(unsigned int index);
>     void remove(unsigned int index, unsigned int count);
> 
>     String &toLowerCase(void);
>     String &toUpperCase(void);
> 
> protected:
>     enum class TrimType : uint8_t {
>         LEFT = 0x01,
>         RIGHT = 0x02,
>         BOTH = LEFT | RIGHT
>     };
> 
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
>     String &_trim(TrimType type);
>     inline String &_trim(TrimType type, char character) {
>         char buf[2] = { character, 0 };
>         return _trim(type, buf, 1);
>     }
>     String &_trim(TrimType type, PGM_P characters, size_t charLen);
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const char *characters) {
>         return _trim(type, characters, strlen(characters));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const __FlashStringHelper *characters) {
>         return _trim(type, reinterpret_cast<PGM_P>(characters), strlen_P(reinterpret_cast<PGM_P>(characters)));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const String &characters) {
>         return _trim(type, characters.c_str(), characters.length());
>     }
> 
> public:
>     inline __attribute__((__always_inline__))
>         String &trim() {
>         return _trim(TrimType::BOTH);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim() {
>         return _trim(TrimType::RIGHT);
>     }
>     inline __attribute__((__always_inline__))
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
>         String &ltrim() {
>         return _trim(TrimType::LEFT);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(char character) {
>         return _trim(TrimType::BOTH, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(char character) {
>         return _trim(TrimType::RIGHT, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(char character) {
>         return _trim(TrimType::LEFT, character);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(const char *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const String &characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &rtrim(const char *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const String &characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &ltrim(const char *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const String &characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
> 
>     // parsing/conversion
>     long toInt(void) const;
>     float toFloat(void) const;
> 
>     inline __attribute__((__always_inline__))
>         double toDouble(void) const {
>         return toFloat();
>     }
> 
> 
> public:
>     // access to SSO and internals
> 
>     // returns allocated memory
>     inline size_t __getAllocSize() const {
> #if defined(ESP8266)
>         if (isSSO()) {
>             return 0;
>         }
>         return capacity() + 1;
> #else
>         return (length() + 8) & ~7;
> #endif
>     }
> 
>     // returns memory usage
>     inline size_t __getMemorySize() const {
>         return sizeof(String) + __getAllocSize();
>     }
> 
>     // get pointer to allocated memory and release ownership
>     // capacity is the size of the allocated block
>     // if no memory is allocated, it returns nullptr and capacity is set to 0
>     // the string is empty afterwards
>     inline char *__release(size_t &capacity) {
>         if (isSSO()) {
>             capacity = 0;
>             return nullptr;
>         }
>         capacity = this->capacity() + 1;
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
>     // see __release(size_t &capacity)
>     inline char *__release() {
>         if (isSSO()) {
>             return nullptr;
>         }
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
> 
> protected:
>     // Contains the string info when we're not in SSO mode
>     struct _ptr {
>         char *buff;
>         uint16_t cap;
>         uint16_t len;
>     };
>     // This allows strings up up to 11 (10 + \0 termination) without any extra space.
>     enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
>     struct _sso {
>         char     buff[SSOSIZE];
>         unsigned char len : 7; // Ensure only one byte is allocated by GCC for the bitfields
>         unsigned char isSSO : 1;
>     } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
>     enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
>     union {
>         struct _ptr ptr;
>         struct _sso sso;
>     };
>     // Accessor functions
>     inline bool isSSO() const { return sso.isSSO; }
>     inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
>     inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
>     inline void setSSO(bool set) { sso.isSSO = set; }
>     inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
>     inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
>     inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
>     // Buffer accessor functions
>     inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
>     inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> 
> protected:
>     inline void init(void) {
>         setSSO(true);
>         setLen(0);
>         wbuffer()[0] = 0;
>     }
> 
>     void invalidate(void);
>     unsigned char changeBuffer(unsigned int maxStrLen);
> 
>     // copy and move
>     String &copy(const char *cstr, unsigned int length);
>     String &copy(const __FlashStringHelper *pstr, unsigned int length);
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
>     void move(String &rhs);
> #endif
> 
> class StringSumHelper : public String {
> public:
>     StringSumHelper(const String &s) :
>         String(s) {
>     }
>     StringSumHelper(const char *p) :
>         String(p) {
>     }
>     StringSumHelper(char c) :
>         String(c) {
>     }
>     StringSumHelper(unsigned char num) :
>         String(num) {
>     }
>     StringSumHelper(int num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned int num) :
>         String(num) {
>     }
>     StringSumHelper(long num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned long num) :
>         String(num) {
>     }
>     StringSumHelper(float num) :
>         String(num) {
>     }
>     StringSumHelper(double num) :
>         String(num) {
>     }
>         return ptr - buffer();
>     }
> 
> 
> public:
>     // search
>     int indexOf(char ch, unsigned int fromIndex) const;
>     int indexOf(const String &str) const;
>     int indexOf(const String &str, unsigned int fromIndex) const;
> 
>     int indexOf(char c) const {
>         return indexOf(c, 0);
>     }
> 
>     int indexOf(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOf(str, fromIndex, ~0U);
>     }
>     int indexOf(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOf_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int indexOfIgnoreCase(char c) const {
>         return indexOfIgnoreCase(c, 0);
>     }
> 
>     int indexOfIgnoreCase(char ch, unsigned int fromIndex) const {
>         if (fromIndex >= len())
>             return -1;
>         const char *temp = strichr(buffer() + fromIndex, ch);
>         if (temp == NULL)
>             return -1;
>         return temp - buffer();
>     }
> 
> 
>     int indexOfIgnoreCase(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str, fromIndex, ~0U);
>     }
>     int indexOfIgnoreCase(const String &str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str.c_str(), fromIndex, str.length());
>     }
>     int indexOfIgnoreCase(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int lastIndexOf(char ch) const {
>         return _lastIndexOf(ch);
>     }
>     int lastIndexOf(char ch, unsigned int fromIndex) const {
>         return _lastIndexOf(ch, fromIndex);
>     }
>     int lastIndexOf(const String &str) const {
>         auto strLen = str.length();
>         return _lastIndexOf(str.buffer(), length() - strLen, strLen);
>     }
>     int lastIndexOf(const String &str, unsigned int fromIndex) const {
>         auto findLength = str.length();
>         return _lastIndexOf(str.buffer(), fromIndex - findLength, findLength);
>     }
>     int lastIndexOf(const __FlashStringHelper *str, unsigned int fromIndex) const {
>         auto findLength = strlen_P(reinterpret_cast<PGM_P>(str));
>         return _lastIndexOf_P(reinterpret_cast<PGM_P>(str), fromIndex - findLength, findLength);
>     }
> 
>     String substring(unsigned int beginIndex) const {
>         return substring(beginIndex, len());
>     }
>     String substring(unsigned int beginIndex, unsigned int endIndex) const;
> 
>     // PROGMEM safe
>     // returns false on failure
>     bool insert(size_t pos, PGM_P insert, size_t insertLen);
> 
>     inline bool insert(size_t pos, PGM_P str) {
>         return insert(pos, str, strlen_P(str));
>     }
>     inline bool insert(size_t pos, const __FlashStringHelper *fstr) {
>         return insert(pos, reinterpret_cast<PGM_P>(fstr), strlen_P(reinterpret_cast<PGM_P>(fstr)));
>     }
>     inline bool insert(size_t pos, const String &str) {
>         return insert(pos, str.buffer(), str.length());
>     }
> 
>     // modification
>     bool replace(char find, char replace);
> 
> protected:
>     bool _replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen);
> 
> public:
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const char *replace) {
>         return _replace(find, strlen(find), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const __FlashStringHelper *replace) {
>         return _replace(find, strlen(find), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const String &replace) {
>         return _replace(find, strlen(find), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const String &replace) {
>         return _replace(find.buffer(), find.length(), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const char *replace) {
>         return _replace(find.buffer(), find.length(), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const __FlashStringHelper *replace) {
>         return _replace(find.buffer(), find.length(), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const String &replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const char *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const __FlashStringHelper *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
> 
>     void remove(unsigned int index);
>     void remove(unsigned int index, unsigned int count);
> 
>     String &toLowerCase(void);
>     String &toUpperCase(void);
> 
> protected:
>     enum class TrimType : uint8_t {
>         LEFT = 0x01,
>         RIGHT = 0x02,
>         BOTH = LEFT | RIGHT
>     };
> 
>     String &_trim(TrimType type);
>     inline String &_trim(TrimType type, char character) {
>         char buf[2] = { character, 0 };
>         return _trim(type, buf, 1);
>     }
>     String &_trim(TrimType type, PGM_P characters, size_t charLen);
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const char *characters) {
>         return _trim(type, characters, strlen(characters));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const __FlashStringHelper *characters) {
>         return _trim(type, reinterpret_cast<PGM_P>(characters), strlen_P(reinterpret_cast<PGM_P>(characters)));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const String &characters) {
>         return _trim(type, characters.c_str(), characters.length());
>     }
> 
> public:
>     inline __attribute__((__always_inline__))
>         String &trim() {
>         return _trim(TrimType::BOTH);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim() {
>         return _trim(TrimType::RIGHT);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim() {
>         return _trim(TrimType::LEFT);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(char character) {
>         return _trim(TrimType::BOTH, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(char character) {
>         return _trim(TrimType::RIGHT, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(char character) {
>         return _trim(TrimType::LEFT, character);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(const char *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const String &characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &rtrim(const char *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const String &characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &ltrim(const char *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const String &characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
> 
>     // parsing/conversion
>     long toInt(void) const;
>     float toFloat(void) const;
> 
>     inline __attribute__((__always_inline__))
>         double toDouble(void) const {
>         return toFloat();
>     }
> 
> 
> public:
>     // access to SSO and internals
> 
>     // returns allocated memory
>     inline size_t __getAllocSize() const {
> #if defined(ESP8266)
>         if (isSSO()) {
>             return 0;
>         }
>         return capacity() + 1;
> #else
>         return (length() + 8) & ~7;
> #endif
>     }
> 
>     // returns memory usage
>     inline size_t __getMemorySize() const {
>         return sizeof(String) + __getAllocSize();
>     }
> 
>     // get pointer to allocated memory and release ownership
>     // capacity is the size of the allocated block
>     // if no memory is allocated, it returns nullptr and capacity is set to 0
>     // the string is empty afterwards
>     inline char *__release(size_t &capacity) {
>         if (isSSO()) {
>             capacity = 0;
>             return nullptr;
>         }
>         capacity = this->capacity() + 1;
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
>     // see __release(size_t &capacity)
>     inline char *__release() {
>         if (isSSO()) {
>             return nullptr;
>         }
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
> 
> protected:
>     // Contains the string info when we're not in SSO mode
>     struct _ptr {
>         char *buff;
>         uint16_t cap;
>         uint16_t len;
>     };
>     // This allows strings up up to 11 (10 + \0 termination) without any extra space.
>     enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
>     struct _sso {
>         char     buff[SSOSIZE];
>         unsigned char len : 7; // Ensure only one byte is allocated by GCC for the bitfields
>         unsigned char isSSO : 1;
>     } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
>     enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
>     union {
>         struct _ptr ptr;
>         struct _sso sso;
>     };
>     // Accessor functions
>     inline bool isSSO() const { return sso.isSSO; }
>     inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
>     inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
>     inline void setSSO(bool set) { sso.isSSO = set; }
>     inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
>     inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
>     inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
>     // Buffer accessor functions
>     inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
>     inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> 
> protected:
>     inline void init(void) {
>         setSSO(true);
>         setLen(0);
>         wbuffer()[0] = 0;
>     }
> 
>     void invalidate(void);
>     unsigned char changeBuffer(unsigned int maxStrLen);
> 
>     // copy and move
>     String &copy(const char *cstr, unsigned int length);
>     String &copy(const __FlashStringHelper *pstr, unsigned int length);
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
>     void move(String &rhs);
> #endif
> };
> 
> class StringSumHelper : public String {
> public:
>     StringSumHelper(const String &s) :
>         String(s) {
>     }
>     StringSumHelper(const char *p) :
>         String(p) {
>     }
>     StringSumHelper(char c) :
>         String(c) {
>     }
>     StringSumHelper(unsigned char num) :
>         String(num) {
>     }
>     StringSumHelper(int num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned int num) :
>         String(num) {
>     }
>     StringSumHelper(long num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned long num) :
>         String(num) {
>     }
>     StringSumHelper(float num) :
>         String(num) {
>     }
>     StringSumHelper(double num) :
>         String(num) {
>     }
> unsigned char String::concat(int num) {
>     char buf[2 + 3 * sizeof(int)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned int num) {
>     char buf[1 + 3 * sizeof(unsigned int)];
>     utoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(long num) {
>     char buf[2 + 3 * sizeof(long)];
>     sprintf(buf, "%ld", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned long num) {
>     char buf[1 + 3 * sizeof(unsigned long)];
>     ultoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(float num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(double num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(const __FlashStringHelper *str) {
>     if (!str) return 0;
>     int length = strlen_P((PGM_P)str);
>     if (length == 0) return 1;
>     unsigned int newlen = len() + length;
>     if (!reserve(newlen)) return 0;
>     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
>     setLen(newlen);
>     return 1;
> }
> 
> /*********************************************/
> /*  Concatenate                              */
> /*********************************************/
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs.buffer(), rhs.len()))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!cstr || !a.concat(cstr, strlen(cstr)))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, char c) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(c))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, float num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, double num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs))
>         a.invalidate();
>     return a;
> }
> 
> // /*********************************************/
> // /*  Comparison                               */
> // /*********************************************/
> 
> int String::compareTo(const String &s) const {
>     if (!buffer() || !s.buffer()) {
>         if (s.buffer() && s.len() > 0)
>             return 0 - *(unsigned char *)s.buffer();
>         if (buffer() && len() > 0)
>             return *(unsigned char *)buffer();
>         return 0;
>     }
>     return strcmp(buffer(), s.buffer());
> }
> 
> 
> unsigned char String::operator<(const String &rhs) const {
>     return compareTo(rhs) < 0;
> }
> 
> unsigned char String::operator>(const String &rhs) const {
>     return compareTo(rhs) > 0;
> }
> 
> unsigned char String::operator<=(const String &rhs) const {
>     return compareTo(rhs) <= 0;
> }
> 
> unsigned char String::operator>=(const String &rhs) const {
>     return compareTo(rhs) >= 0;
> }
> 
> unsigned char String::equalsConstantTime(const String &s2) const {
>     // To avoid possible time-based attacks present function
>     // compares given strings in a constant time.
>     if (len() != s2.len())
>         return 0;
>     //at this point lengths are the same
>     if (len() == 0)
>         return 1;
>     //at this point lenghts are the same and non-zero
>     const char *p1 = buffer();
>     const char *p2 = s2.buffer();
>     unsigned int equalchars = 0;
>     unsigned int diffchars = 0;
>     while (*p1) {
>         if (*p1 == *p2)
>             ++equalchars;
>         else
>             ++diffchars;
>         ++p1;
>         ++p2;
>     }
>     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
>     unsigned char equalcond = (equalchars == len());
>     unsigned char diffcond = (diffchars == 0);
>     return (equalcond & diffcond); //bitwise AND
> }
> 
> // unsigned char String::startsWith(const String &s2) const {
> //     if(len() < s2.len())
> //         return 0;
> //     return startsWith(s2, 0);
> // }
> 
> // unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> //     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> //         return 0;
> //     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> // }
> 
> // /*********************************************/
> // /*  Character Access                         */
> // /*********************************************/
> 
> char String::charAt(unsigned int loc) const {
>     return operator[](loc);
> }
> 
> void String::setCharAt(unsigned int loc, char c) {
>     if (loc < len())
>         wbuffer()[loc] = c;
> }
> 
> char &String::operator[](unsigned int index) {
>     static char dummy_writable_char;
>     if (index >= len() || !buffer()) {
>         dummy_writable_char = 0;
>         return dummy_writable_char;
>     }
>     return wbuffer()[index];
> }
> 
> char String::operator[](unsigned int index) const {
>     if (index >= len() || !buffer())
>         return 0;
>     return buffer()[index];
> }
> 
> void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
>     if (!bufsize || !buf)
>         return;
>     if (index >= len()) {
>         buf[0] = 0;
>         return;
>     }
>     unsigned int n = bufsize - 1;
>     if (n > len() - index)
>         n = len() - index;
>     strncpy((char *)buf, buffer() + index, n);
>     buf[n] = 0;
> }
> 
> // /*********************************************/
> // /*  Search                                   */
> // /*********************************************/
> 
> int String::indexOf(char ch, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *temp = strchr(buffer() + fromIndex, ch);
>     if (temp == NULL)
>         return -1;
>     return temp - buffer();
> }
> 
> int String::indexOf(const String &s2) const {
>     return indexOf(s2, 0);
> }
> 
> int String::indexOf(const String &s2, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *found = strstr(buffer() + fromIndex, s2.buffer());
>     if (found == NULL)
>         return -1;
>     return found - buffer();
> }
> 
> String String::substring(unsigned int left, unsigned int right) const {
>     if (left > right) {
>         unsigned int temp = right;
>         right = left;
>         left = temp;
>     }
>     String out;
>     if (left >= len())
>         return out;
>     if (right > len())
>         right = len();
>     char temp = buffer()[right];  // save the replaced character
>     wbuffer()[right] = '\0';
>     out = wbuffer() + left;  // pointer arithmetic
>     wbuffer()[right] = temp;  //restore character
>     return out;
> }
> 
> // /*********************************************/
> // /*  Modification                             */
> // /*********************************************/
> 
> bool String::insert(size_t pos, PGM_P insert, size_t insertLen) {
>     size_t len;
>     if (insertLen == 0 || (len = length()) == 0 || pos >= len) {
>         return false;
>     }
>     auto requiredLen = len + insertLen;
>     if (!reserve(requiredLen)) {
>         return false;
>     }
>     setLen(requiredLen);
>     memmove(wbuffer() + pos + insertLen, wbuffer() + pos, len - pos/* + 1 NUL byte*/);
>     memmove_P(wbuffer() + pos, insert, insertLen);
>     wbuffer()[requiredLen] = 0;
>     return true;
> }
> 
> 
> bool String::replace(char find, char replace)
> {
>     if (!buffer())
>         return true;
>     for (char *p = wbuffer(); *p; p++) {
>         if (*p == find) {
>             *p = replace;
>         }
>     }
>     return true;
> }
> 
> bool String::_replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen)
> {
>     if (length() == 0 || findLen == 0 || !find) {
>         return false;
>     }
>     int diff = replaceLen - findLen;
>     char *readFrom = wbuffer();
>     char *foundAt;
>     if (diff == 0) {
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             memmove_P(foundAt, replace, replaceLen);
>             readFrom = foundAt + replaceLen;
>         }
>     }
>     else if (diff < 0) {
>         char *writeTo = wbuffer();
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             unsigned int n = foundAt - readFrom;
>             memmove(writeTo, readFrom, n);
>             writeTo += n;
>             memmove_P(writeTo, replace, replaceLen);
>             writeTo += replaceLen;
>             readFrom = foundAt + findLen;
>             setLen(len() + diff);
>         }
>         memmove(writeTo, readFrom, strlen(readFrom) + 1);
>     }
>     else {
>         unsigned int size = len(); // compute size needed for result
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             readFrom = foundAt + findLen;
>             size += diff;
>         }
>         if (size == len()) {
>             return true;
>         }
>         if (size > capacity() && !changeBuffer(size)) {
>             return false;
>         }
>         int index = len() - 1;
>         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
>             readFrom = wbuffer() + index + findLen;
>             memmove(readFrom + diff, readFrom, len() - (readFrom - buffer()));
>             int newLen = len() + diff;
>             memmove_P(wbuffer() + index, replace, replaceLen);
>             setLen(newLen);
>             wbuffer()[newLen] = 0;
>             index--;
>         }
>     }
>     return true;
> }
> 
> void String::remove(unsigned int index) {
>     // Pass the biggest integer as the count. The remove method
>     // below will take care of truncating it at the end of the
>     // string.
>     remove(index, (unsigned int)-1);
> }
> 
> void String::remove(unsigned int index, unsigned int count) {
>     if (index >= len()) {
>         return;
>     }
>     if (count <= 0) {
>         return;
>     }
>     if (count > len() - index) {
>         count = len() - index;
>     }
>     char *writeTo = wbuffer() + index;
>     unsigned int newlen = len() - count;
>     setLen(newlen);
>     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
>     wbuffer()[newlen] = 0;
> }
> 
> String &String::toLowerCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = tolower(*p);
>     }
>     return *this;
> }
> 
> String &String::toUpperCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = toupper(*p);
>     }
>     return *this;
> }
> 
> 
> String &String::_trim(TrimType type)
> {
>     auto len = length();
>     if (len == 0) {
>         return *this;
>     }
>     char *begin = wbuffer();
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         while (isspace(*begin)) {
>             begin++;
>         }
>     }
>     char *end = wbuffer() + len - 1;
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (isspace(*end) && end >= begin) {
>             end--;
>         }
>     }
>     unsigned int newlen = end + 1 - begin;
>     if (begin > buffer()) {
>         memmove(wbuffer(), begin, newlen);
>     }
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return *this;
> }
> 
> String &String::_trim(TrimType type, PGM_P characters, size_t charLen)
> {
>     auto len = length();
>     if (!len || !characters || !charLen) {
>         return *this;
>     }
>     charLen++; // use memchr instead of strchr to avoid additional NUL byte check
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (len && memchr_P(characters, buffer()[len - 1], charLen)) {
>             len--;
>         }
>         setLen(len);
>     }
> 
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         size_t remove = 0;
>         while (memchr_P(characters, buffer()[remove], charLen)) {
>             remove++;
>         }
>         this->remove(0, remove); // remove adds NUL byte
>     }
>     else {
>         wbuffer()[len] = 0;
>     }
>     return *this;
> }
> 
> 
> // /*********************************************/
> // /*  Parsing / Conversion                     */
> // /*********************************************/
> 
> long String::toInt(void) const
> {
>     if (buffer()) {
>         return atol(buffer());
>     }
>     return 0;
> }
> 
> float String::toFloat(void) const
> {
>     if (buffer()) {
>         return atof(buffer());
>     }
>     return 0;
> }
> 
> // global empty string to allow returning const String& with nothing
> 
> const String emptyString;
> 
> #include "WStringEx.cpp"
>     }
> #ifdef HAVE_KFC_FIRMWARE_VERSION
> extern Stream &Serial;
> #else
> #endif
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/*.orig ./framework-arduinoespressif8266/*.orig
0a1,1258
> 
>  This library is free software; you can redistribute it and/or
>  modify it under the terms of the GNU Lesser General Public
>  License as published by the Free Software Foundation; either
>  version 2.1 of the License, or (at your option) any later version.
> 
>  This library is distributed in the hope that it will be useful,
>  but WITHOUT ANY WARRANTY; without even the implied warranty of
>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
>  Lesser General Public License for more details.
> 
>  You should have received a copy of the GNU Lesser General Public
>  License along with this library; if not, write to the Free Software
>  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
>  */
> 
> #ifdef _MSC_VER
> #include <Arduino_compat.h>
> #include "cores/esp8266/WString.h"
> #include "util/stdlib_noniso.h"
> #else
> #pragma once
> 
> namespace WebServer{
>     class Plugin;
> }
> 
> #include <Arduino.h>
> #include "WString.h"
> #include "stdlib_noniso.h"
> #endif
> #ifdef _MSC_VER
> #include <misc_string.h>
> #else
> 
>  /*********************************************/
>  /*  Constructors                             */
>  /*********************************************/
> #include "KFCBaseLibrary/include/misc_string.h"
> #endif
> 
> String::String(const char *cstr) {
>     init();
>     if (cstr)
>         copy(cstr, strlen(cstr));
> }
> 
> String::String(const String &value) {
> #ifndef FPSTR
>     init();
> #endif
> #ifndef F
>     *this = value;
> #endif
> }
> 
> String::String(const __FlashStringHelper *pstr) {
>     init();
>     *this = pstr; // see operator =
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String::String(String &&rval) {
>     init();
>     move(rval);
> }
> 
> String::String(StringSumHelper &&rval) {
>     init();
>     move(rval);
> }
> #endif
> 
> String::String(char c) {
>     init();
>     friend WebServer::Plugin;
> 
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     *this = buf;
> }
> 
> String::String(unsigned char value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned char)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(int value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(int)];
>     if (base == 10) {
>         sprintf(buf, "%d", value);
>     }
>     else {
>         itoa(value, buf, base);
>     }
>     *this = buf;
> }
> 
> String::String(unsigned int value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned int)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(long value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(long)];
>     if (base == 10) {
>         sprintf(buf, "%ld", value);
>     }
>     else {
>         ltoa(value, buf, base);
>     }
>     explicit String(char c);
>     explicit String(unsigned char, unsigned char base = 10);
>     explicit String(int, unsigned char base = 10);
>     explicit String(unsigned int, unsigned char base = 10);
>     explicit String(long, unsigned char base = 10);
>     explicit String(unsigned long, unsigned char base = 10);
>     explicit String(float, unsigned char decimalPlaces = 2);
>     explicit String(double, unsigned char decimalPlaces = 2);
>     ~String(void);
>     *this = buf;
> }
> 
> String::String(unsigned long value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned long)];
>     ultoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(float value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::String(double value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::~String() {
>     invalidate();
> }
> 
> // /*********************************************/
> // /*  Memory Management                        */
> // /*********************************************/
> 
> void String::invalidate(void) {
>     if (!isSSO() && wbuffer())
>         free(wbuffer());
>     init();
> }
> 
> unsigned char String::reserve(unsigned int size) {
>     if (buffer() && capacity() >= size)
>         return 1;
>     if (changeBuffer(size)) {
>         if (len() == 0)
>             wbuffer()[0] = 0;
>         return 1;
>     }
>     return 0;
> }
> 
> unsigned char String::changeBuffer(unsigned int maxStrLen) {
>     // Can we use SSO here to avoid allocation?
>     if (maxStrLen < sizeof(sso.buff) - 1) {
>         if (isSSO() || !buffer()) {
>             // Already using SSO, nothing to do
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             return 1;
>         }
>         else { // if bufptr && !isSSO()
>          // Using bufptr, need to shrink into sso.buff
>             char temp[sizeof(sso.buff)];
>             memcpy(temp, buffer(), maxStrLen);
>             free(wbuffer());
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             memcpy(wbuffer(), temp, maxStrLen);
>             return 1;
>         }
>     }
>     // Fallthrough to normal allocator
>     size_t newSize = (maxStrLen + 16) & (~0xf);
>     // Make sure we can fit newsize in the buffer
>     if (newSize > CAPACITY_MAX) {
>         return false;
>     }
>     uint16_t oldLen = len();
>     char *newbuffer = (char *)realloc(isSSO() ? nullptr : wbuffer(), newSize);
>     if (newbuffer) {
>         size_t oldSize = capacity() + 1; // include NULL.
>         if (isSSO()) {
>             // Copy the SSO buffer into allocated space
>             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
>         }
>         if (newSize > oldSize)
>         {
>             memset(newbuffer + oldSize, 0, newSize - oldSize);
>         }
>         setSSO(false);
>         setCapacity(newSize - 1);
>         setLen(oldLen); // Needed in case of SSO where len() never existed
>         setBuffer(newbuffer);
>         return 1;
>     }
>     return 0;
> }
>     }
> 
> // /*********************************************/
> // /*  Copy and Move                            */
> // /*********************************************/
> 
> String &String::copy(const char *cstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memmove_P(wbuffer(), cstr, length + 1);
>     return *this;
> }
> 
> String &String::copy(const __FlashStringHelper *pstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> void String::move(String &rhs) {
>     if (buffer()) {
>         if (capacity() >= rhs.len()) {
>             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
>             setLen(rhs.len());
>             rhs.invalidate();
>             return;
>         }
>         else {
>             if (!isSSO()) {
>                 free(wbuffer());
>                 setBuffer(nullptr);
>             }
>         }
>     }
>     if (rhs.isSSO()) {
>         setSSO(true);
>         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
>     }
>     else {
>         setSSO(false);
>         setBuffer(rhs.wbuffer());
>     }
>     setCapacity(rhs.capacity());
>     setLen(rhs.len());
>     rhs.setSSO(false);
>     rhs.setCapacity(0);
>     rhs.setLen(0);
>     rhs.setBuffer(nullptr);
> }
> #endif
> 
> String &String::operator =(const String &rhs) {
>     if (this == &rhs)
>         return *this;
> 
>     if (rhs.buffer())
>         copy(rhs.buffer(), rhs.len());
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String &String::operator =(String &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> 
> String &String::operator =(StringSumHelper &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> #endif
> 
> String &String::operator =(const char *cstr) {
>     if (cstr)
>         copy(cstr, strlen(cstr));
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> String &String::operator = (const __FlashStringHelper *pstr)
> {
>     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
>     else invalidate();
> 
>     return *this;
> }
> 
> // /*********************************************/
> // /*  concat                                   */
> // /*********************************************/
> 
> unsigned char String::concat(const String &s) {
>     // Special case if we're concatting ourself (s += s;) since we may end up
>     // realloc'ing the buffer and moving s.buffer in the method called
>     if (&s == this) {
>         unsigned int newlen = 2 * len();
>         if (!s.buffer())
>             return 0;
>         if (s.len() == 0)
>             return 1;
>         if (!reserve(newlen))
>             return 0;
>         memmove_P(wbuffer() + len(), buffer(), len());
>         setLen(newlen);
>         wbuffer()[len()] = 0;
>         return 1;
>     }
>     else {
>         return concat(s.buffer(), s.len());
>     }
> }
> 
> unsigned char String::concat(const char *cstr, unsigned int length) {
>     unsigned int newlen = len() + length;
>     if (!cstr)
>         return 0;
>     if (length == 0)
>         return 1;
>     if (!reserve(newlen))
>         return 0;
>     memmove_P(wbuffer() + len(), cstr, length + 1);
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return 1;
> }
> 
> unsigned char String::concat(const char *cstr) {
>     if (!cstr)
>         return 0;
>     return concat(cstr, strlen(cstr));
> }
> 
> unsigned char String::concat(char c) {
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     return concat(buf, 1);
> }
> 
> unsigned char String::concat(unsigned char num) {
>     char buf[1 + 3 * sizeof(unsigned char)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
>         return ptr - buffer();
>     }
> 
> 
> public:
>     // search
>     int indexOf(char ch, unsigned int fromIndex) const;
>     int indexOf(const String &str) const;
>     int indexOf(const String &str, unsigned int fromIndex) const;
> 
>     int indexOf(char c) const {
>         return indexOf(c, 0);
>     }
> 
>     int indexOf(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOf(str, fromIndex, ~0U);
>     }
>     int indexOf(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOf_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int indexOfIgnoreCase(char c) const {
>         return indexOfIgnoreCase(c, 0);
>     }
> 
>     int indexOfIgnoreCase(char ch, unsigned int fromIndex) const {
>         if (fromIndex >= len())
>             return -1;
>         const char *temp = strichr(buffer() + fromIndex, ch);
>         if (temp == NULL)
>             return -1;
>         return temp - buffer();
>     }
> 
> 
>     int indexOfIgnoreCase(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str, fromIndex, ~0U);
>     }
>     int indexOfIgnoreCase(const String &str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str.c_str(), fromIndex, str.length());
>     }
>     int indexOfIgnoreCase(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int lastIndexOf(char ch) const {
>         return _lastIndexOf(ch);
>     }
>     int lastIndexOf(char ch, unsigned int fromIndex) const {
>         return _lastIndexOf(ch, fromIndex);
>     }
>     int lastIndexOf(const String &str) const {
>         auto strLen = str.length();
>         return _lastIndexOf(str.buffer(), length() - strLen, strLen);
>     }
>     int lastIndexOf(const String &str, unsigned int fromIndex) const {
>         auto findLength = str.length();
>         return _lastIndexOf(str.buffer(), fromIndex - findLength, findLength);
>     }
>     int lastIndexOf(const __FlashStringHelper *str, unsigned int fromIndex) const {
>         auto findLength = strlen_P(reinterpret_cast<PGM_P>(str));
>         return _lastIndexOf_P(reinterpret_cast<PGM_P>(str), fromIndex - findLength, findLength);
>     }
> 
>     String substring(unsigned int beginIndex) const {
>         return substring(beginIndex, len());
>     }
>     String substring(unsigned int beginIndex, unsigned int endIndex) const;
> 
>     // PROGMEM safe
>     // returns false on failure
>     bool insert(size_t pos, PGM_P insert, size_t insertLen);
> 
>     inline bool insert(size_t pos, PGM_P str) {
>         return insert(pos, str, strlen_P(str));
>     }
>     inline bool insert(size_t pos, const __FlashStringHelper *fstr) {
>         return insert(pos, reinterpret_cast<PGM_P>(fstr), strlen_P(reinterpret_cast<PGM_P>(fstr)));
>     }
>     inline bool insert(size_t pos, const String &str) {
>         return insert(pos, str.buffer(), str.length());
>     }
> 
>     // modification
>     bool replace(char find, char replace);
> 
> protected:
>     bool _replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen);
> 
> public:
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const char *replace) {
>         return _replace(find, strlen(find), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const __FlashStringHelper *replace) {
>         return _replace(find, strlen(find), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const String &replace) {
>         return _replace(find, strlen(find), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const String &replace) {
>         return _replace(find.buffer(), find.length(), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const char *replace) {
>         return _replace(find.buffer(), find.length(), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const __FlashStringHelper *replace) {
>         return _replace(find.buffer(), find.length(), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const String &replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const char *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const __FlashStringHelper *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
> 
>     void remove(unsigned int index);
>     void remove(unsigned int index, unsigned int count);
> 
>     String &toLowerCase(void);
>     String &toUpperCase(void);
> 
> protected:
>     enum class TrimType : uint8_t {
>         LEFT = 0x01,
>         RIGHT = 0x02,
>         BOTH = LEFT | RIGHT
>     };
> 
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
>     String &_trim(TrimType type);
>     inline String &_trim(TrimType type, char character) {
>         char buf[2] = { character, 0 };
>         return _trim(type, buf, 1);
>     }
>     String &_trim(TrimType type, PGM_P characters, size_t charLen);
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const char *characters) {
>         return _trim(type, characters, strlen(characters));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const __FlashStringHelper *characters) {
>         return _trim(type, reinterpret_cast<PGM_P>(characters), strlen_P(reinterpret_cast<PGM_P>(characters)));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const String &characters) {
>         return _trim(type, characters.c_str(), characters.length());
>     }
> 
> public:
>     inline __attribute__((__always_inline__))
>         String &trim() {
>         return _trim(TrimType::BOTH);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim() {
>         return _trim(TrimType::RIGHT);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim() {
>         return _trim(TrimType::LEFT);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(char character) {
>         return _trim(TrimType::BOTH, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(char character) {
>         return _trim(TrimType::RIGHT, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(char character) {
>         return _trim(TrimType::LEFT, character);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(const char *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const String &characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &rtrim(const char *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const String &characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &ltrim(const char *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const String &characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
> 
>     // parsing/conversion
>     long toInt(void) const;
>     float toFloat(void) const;
> 
>     inline __attribute__((__always_inline__))
>         double toDouble(void) const {
>         return toFloat();
>     }
> 
> 
> public:
>     // access to SSO and internals
> 
>     // returns allocated memory
>     inline size_t __getAllocSize() const {
> #if defined(ESP8266)
>         if (isSSO()) {
>             return 0;
>         }
>         return capacity() + 1;
> #else
>         return (length() + 8) & ~7;
> #endif
>     }
> 
>     // returns memory usage
>     inline size_t __getMemorySize() const {
>         return sizeof(String) + __getAllocSize();
>     }
> 
>     // get pointer to allocated memory and release ownership
>     // capacity is the size of the allocated block
>     // if no memory is allocated, it returns nullptr and capacity is set to 0
>     // the string is empty afterwards
>     inline char *__release(size_t &capacity) {
>         if (isSSO()) {
>             capacity = 0;
>             return nullptr;
>         }
>         capacity = this->capacity() + 1;
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
>     // see __release(size_t &capacity)
>     inline char *__release() {
>         if (isSSO()) {
>             return nullptr;
>         }
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
> 
> protected:
>     // Contains the string info when we're not in SSO mode
>     struct _ptr {
>         char *buff;
>         uint16_t cap;
>         uint16_t len;
>     };
>     // This allows strings up up to 11 (10 + \0 termination) without any extra space.
>     enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
>     struct _sso {
>         char     buff[SSOSIZE];
>         unsigned char len : 7; // Ensure only one byte is allocated by GCC for the bitfields
>         unsigned char isSSO : 1;
>     } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
>     enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
>     union {
>         struct _ptr ptr;
>         struct _sso sso;
>     };
>     // Accessor functions
>     inline bool isSSO() const { return sso.isSSO; }
>     inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
>     inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
>     inline void setSSO(bool set) { sso.isSSO = set; }
>     inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
>     inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
>     inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
>     // Buffer accessor functions
>     inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
>     inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> 
> protected:
>     inline void init(void) {
>         setSSO(true);
>         setLen(0);
>         wbuffer()[0] = 0;
>     }
> 
>     void invalidate(void);
>     unsigned char changeBuffer(unsigned int maxStrLen);
> 
>     // copy and move
>     String &copy(const char *cstr, unsigned int length);
>     String &copy(const __FlashStringHelper *pstr, unsigned int length);
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
>     void move(String &rhs);
> #endif
> };
> 
> class StringSumHelper : public String {
> public:
>     StringSumHelper(const String &s) :
>         String(s) {
>     }
>     StringSumHelper(const char *p) :
>         String(p) {
>     }
>     StringSumHelper(char c) :
>         String(c) {
>     }
>     StringSumHelper(unsigned char num) :
>         String(num) {
>     }
>     StringSumHelper(int num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned int num) :
>         String(num) {
>     }
>     StringSumHelper(long num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned long num) :
>         String(num) {
>     }
>     StringSumHelper(float num) :
>         String(num) {
>     }
>     StringSumHelper(double num) :
>         String(num) {
>     }
> unsigned char String::concat(int num) {
>     char buf[2 + 3 * sizeof(int)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned int num) {
>     char buf[1 + 3 * sizeof(unsigned int)];
>     utoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(long num) {
>     char buf[2 + 3 * sizeof(long)];
>     sprintf(buf, "%ld", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned long num) {
>     char buf[1 + 3 * sizeof(unsigned long)];
>     ultoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(float num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(double num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(const __FlashStringHelper *str) {
>     if (!str) return 0;
>     int length = strlen_P((PGM_P)str);
>     if (length == 0) return 1;
>     unsigned int newlen = len() + length;
>     if (!reserve(newlen)) return 0;
>     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
>     setLen(newlen);
>     return 1;
> }
> 
> /*********************************************/
> /*  Concatenate                              */
> /*********************************************/
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs.buffer(), rhs.len()))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!cstr || !a.concat(cstr, strlen(cstr)))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, char c) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(c))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, float num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, double num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs))
>         a.invalidate();
>     return a;
> }
> 
> // /*********************************************/
> // /*  Comparison                               */
> // /*********************************************/
> 
> int String::compareTo(const String &s) const {
>     if (!buffer() || !s.buffer()) {
>         if (s.buffer() && s.len() > 0)
>             return 0 - *(unsigned char *)s.buffer();
>         if (buffer() && len() > 0)
>             return *(unsigned char *)buffer();
>         return 0;
>     }
>     return strcmp(buffer(), s.buffer());
> }
> 
> 
> unsigned char String::operator<(const String &rhs) const {
>     return compareTo(rhs) < 0;
> }
> 
> unsigned char String::operator>(const String &rhs) const {
>     return compareTo(rhs) > 0;
> }
> 
> unsigned char String::operator<=(const String &rhs) const {
>     return compareTo(rhs) <= 0;
> }
> 
> unsigned char String::operator>=(const String &rhs) const {
>     return compareTo(rhs) >= 0;
> }
> 
> unsigned char String::equalsConstantTime(const String &s2) const {
>     // To avoid possible time-based attacks present function
>     // compares given strings in a constant time.
>     if (len() != s2.len())
>         return 0;
>     //at this point lengths are the same
>     if (len() == 0)
>         return 1;
>     //at this point lenghts are the same and non-zero
>     const char *p1 = buffer();
>     const char *p2 = s2.buffer();
>     unsigned int equalchars = 0;
>     unsigned int diffchars = 0;
>     while (*p1) {
>         if (*p1 == *p2)
>             ++equalchars;
>         else
>             ++diffchars;
>         ++p1;
>         ++p2;
>     }
>     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
>     unsigned char equalcond = (equalchars == len());
>     unsigned char diffcond = (diffchars == 0);
>     return (equalcond & diffcond); //bitwise AND
> }
> 
> // unsigned char String::startsWith(const String &s2) const {
> //     if(len() < s2.len())
> //         return 0;
> //     return startsWith(s2, 0);
> // }
> 
> // unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> //     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> //         return 0;
> //     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> // }
> 
> // /*********************************************/
> // /*  Character Access                         */
> // /*********************************************/
> 
> char String::charAt(unsigned int loc) const {
>     return operator[](loc);
> }
> 
> void String::setCharAt(unsigned int loc, char c) {
>     if (loc < len())
>         wbuffer()[loc] = c;
> }
> 
> char &String::operator[](unsigned int index) {
>     static char dummy_writable_char;
>     if (index >= len() || !buffer()) {
>         dummy_writable_char = 0;
>         return dummy_writable_char;
>     }
>     return wbuffer()[index];
> }
> 
> char String::operator[](unsigned int index) const {
>     if (index >= len() || !buffer())
>         return 0;
>     return buffer()[index];
> }
> 
> void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
>     if (!bufsize || !buf)
>         return;
>     if (index >= len()) {
>         buf[0] = 0;
>         return;
>     }
>     unsigned int n = bufsize - 1;
>     if (n > len() - index)
>         n = len() - index;
>     strncpy((char *)buf, buffer() + index, n);
>     buf[n] = 0;
> }
> 
> // /*********************************************/
> // /*  Search                                   */
> // /*********************************************/
> 
> int String::indexOf(char ch, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *temp = strchr(buffer() + fromIndex, ch);
>     if (temp == NULL)
>         return -1;
>     return temp - buffer();
> }
> 
> int String::indexOf(const String &s2) const {
>     return indexOf(s2, 0);
> }
> 
> int String::indexOf(const String &s2, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *found = strstr(buffer() + fromIndex, s2.buffer());
>     if (found == NULL)
>         return -1;
>     return found - buffer();
> }
> 
> String String::substring(unsigned int left, unsigned int right) const {
>     if (left > right) {
>         unsigned int temp = right;
>         right = left;
>         left = temp;
>     }
>     String out;
>     if (left >= len())
>         return out;
>     if (right > len())
>         right = len();
>     char temp = buffer()[right];  // save the replaced character
>     wbuffer()[right] = '\0';
>     out = wbuffer() + left;  // pointer arithmetic
>     wbuffer()[right] = temp;  //restore character
>     return out;
> }
> 
> // /*********************************************/
> // /*  Modification                             */
> // /*********************************************/
> 
> bool String::insert(size_t pos, PGM_P insert, size_t insertLen) {
>     size_t len;
>     if (insertLen == 0 || (len = length()) == 0 || pos >= len) {
>         return false;
>     }
>     auto requiredLen = len + insertLen;
>     if (!reserve(requiredLen)) {
>         return false;
>     }
>     setLen(requiredLen);
>     memmove(wbuffer() + pos + insertLen, wbuffer() + pos, len - pos/* + 1 NUL byte*/);
>     memmove_P(wbuffer() + pos, insert, insertLen);
>     wbuffer()[requiredLen] = 0;
>     return true;
> }
> 
> 
> bool String::replace(char find, char replace)
> {
>     if (!buffer())
>         return true;
>     for (char *p = wbuffer(); *p; p++) {
>         if (*p == find) {
>             *p = replace;
>         }
>     }
>     return true;
> }
> 
> bool String::_replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen)
> {
>     if (length() == 0 || findLen == 0 || !find) {
>         return false;
>     }
>     int diff = replaceLen - findLen;
>     char *readFrom = wbuffer();
>     char *foundAt;
>     if (diff == 0) {
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             memmove_P(foundAt, replace, replaceLen);
>             readFrom = foundAt + replaceLen;
>         }
>     }
>     else if (diff < 0) {
>         char *writeTo = wbuffer();
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             unsigned int n = foundAt - readFrom;
>             memmove(writeTo, readFrom, n);
>             writeTo += n;
>             memmove_P(writeTo, replace, replaceLen);
>             writeTo += replaceLen;
>             readFrom = foundAt + findLen;
>             setLen(len() + diff);
>         }
>         memmove(writeTo, readFrom, strlen(readFrom) + 1);
>     }
>     else {
>         unsigned int size = len(); // compute size needed for result
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             readFrom = foundAt + findLen;
>             size += diff;
>         }
>         if (size == len()) {
>             return true;
>         }
>         if (size > capacity() && !changeBuffer(size)) {
>             return false;
>         }
>         int index = len() - 1;
>         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
>             readFrom = wbuffer() + index + findLen;
>             memmove(readFrom + diff, readFrom, len() - (readFrom - buffer()));
>             int newLen = len() + diff;
>             memmove_P(wbuffer() + index, replace, replaceLen);
>             setLen(newLen);
>             wbuffer()[newLen] = 0;
>             index--;
>         }
>     }
>     return true;
> }
> 
> void String::remove(unsigned int index) {
>     // Pass the biggest integer as the count. The remove method
>     // below will take care of truncating it at the end of the
>     // string.
>     remove(index, (unsigned int)-1);
> }
> 
> void String::remove(unsigned int index, unsigned int count) {
>     if (index >= len()) {
>         return;
>     }
>     if (count <= 0) {
>         return;
>     }
>     if (count > len() - index) {
>         count = len() - index;
>     }
>     char *writeTo = wbuffer() + index;
>     unsigned int newlen = len() - count;
>     setLen(newlen);
>     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
>     wbuffer()[newlen] = 0;
> }
> 
> String &String::toLowerCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = tolower(*p);
>     }
>     return *this;
> }
> 
> String &String::toUpperCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = toupper(*p);
>     }
>     return *this;
> }
> 
> 
> String &String::_trim(TrimType type)
> {
>     auto len = length();
>     if (len == 0) {
>         return *this;
>     }
>     char *begin = wbuffer();
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         while (isspace(*begin)) {
>             begin++;
>         }
>     }
>     char *end = wbuffer() + len - 1;
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (isspace(*end) && end >= begin) {
>             end--;
>         }
>     }
>     unsigned int newlen = end + 1 - begin;
>     if (begin > buffer()) {
>         memmove(wbuffer(), begin, newlen);
>     }
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return *this;
> }
> 
> String &String::_trim(TrimType type, PGM_P characters, size_t charLen)
> {
>     auto len = length();
>     if (!len || !characters || !charLen) {
>         return *this;
>     }
>     charLen++; // use memchr instead of strchr to avoid additional NUL byte check
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (len && memchr_P(characters, buffer()[len - 1], charLen)) {
>             len--;
>         }
>         setLen(len);
>     }
> 
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         size_t remove = 0;
>         while (memchr_P(characters, buffer()[remove], charLen)) {
>             remove++;
>         }
>         this->remove(0, remove); // remove adds NUL byte
>     }
>     else {
>         wbuffer()[len] = 0;
>     }
>     return *this;
> }
> 
> 
> // /*********************************************/
> // /*  Parsing / Conversion                     */
> // /*********************************************/
> 
> long String::toInt(void) const
> {
>     if (buffer()) {
>         return atol(buffer());
>     }
>     return 0;
> }
> 
> float String::toFloat(void) const
> {
>     if (buffer()) {
>         return atof(buffer());
>     }
>     return 0;
> }
> 
> // global empty string to allow returning const String& with nothing
> 
> const String emptyString;
> 
> #include "WStringEx.cpp"
>     }
> #ifdef HAVE_KFC_FIRMWARE_VERSION
> extern Stream &Serial;
> #else
> #endif
> #ifdef HAVE_KFC_FIRMWARE_VERSION
>     public:
> #endif
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/*.rej ./framework-arduinoespressif8266/*.rej
0a1,1831
> *** /dev/null
> --- /dev/null
> ***************
> *** 221
> -     while (p != &__init_array_start)
> --- 221 -----
> +     while (p != &__init_array_start) {
> *** /dev/null
> --- /dev/null
> ***************
> *** 83
> - static void ets_printf_P(const char *str, ...) {
> --- 83,88 -----
> + 
> + // exported for using in custom_crash_callback()
> + extern void ___static_ets_printf_P(const char *str, ...);
> + #define ets_printf_P ___static_ets_printf_P
> + 
> + void ___static_ets_printf_P(const char *str, ...) {
> *** /dev/null
> --- /dev/null
> ***************
> *** 2,849
> -  This library is free software; you can redistribute it and/or
> -  modify it under the terms of the GNU Lesser General Public
> -  License as published by the Free Software Foundation; either
> -  version 2.1 of the License, or (at your option) any later version.
> - 
> -  This library is distributed in the hope that it will be useful,
> -  but WITHOUT ANY WARRANTY; without even the implied warranty of
> -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> -  Lesser General Public License for more details.
> - 
> -  You should have received a copy of the GNU Lesser General Public
> -  License along with this library; if not, write to the Free Software
> -  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
> -  */
> - 
> - #include <Arduino.h>
> - #include "WString.h"
> - #include "stdlib_noniso.h"
> - 
> - /*********************************************/
> - /*  Constructors                             */
> - /*********************************************/
> - 
> - String::String(const char *cstr) {
> -     init();
> -     if (cstr)
> -         copy(cstr, strlen(cstr));
> - }
> - 
> - String::String(const String &value) {
> -     init();
> -     *this = value;
> - }
> - 
> - String::String(const __FlashStringHelper *pstr) {
> -     init();
> -     *this = pstr; // see operator =
> - }
> - 
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> - String::String(String &&rval) {
> -     init();
> -     move(rval);
> - }
> - 
> - String::String(StringSumHelper &&rval) {
> -     init();
> -     move(rval);
> - }
> - #endif
> - 
> - String::String(char c) {
> -     init();
> -     char buf[2];
> -     buf[0] = c;
> -     buf[1] = 0;
> -     *this = buf;
> - }
> - 
> - String::String(unsigned char value, unsigned char base) {
> -     init();
> -     char buf[1 + 8 * sizeof(unsigned char)];
> -     utoa(value, buf, base);
> -     *this = buf;
> - }
> - 
> - String::String(int value, unsigned char base) {
> -     init();
> -     char buf[2 + 8 * sizeof(int)];
> -     if (base == 10) {
> -         sprintf(buf, "%d", value);
> -     } else {
> -         itoa(value, buf, base);
> -     }
> -     *this = buf;
> - }
> - 
> - String::String(unsigned int value, unsigned char base) {
> -     init();
> -     char buf[1 + 8 * sizeof(unsigned int)];
> -     utoa(value, buf, base);
> -     *this = buf;
> - }
> - 
> - String::String(long value, unsigned char base) {
> -     init();
> -     char buf[2 + 8 * sizeof(long)];
> -     if (base==10) {
> -         sprintf(buf, "%ld", value);
> -     } else {
> -         ltoa(value, buf, base);
> -     }
> -     *this = buf;
> - }
> - 
> - String::String(unsigned long value, unsigned char base) {
> -     init();
> -     char buf[1 + 8 * sizeof(unsigned long)];
> -     ultoa(value, buf, base);
> -     *this = buf;
> - }
> - 
> - String::String(float value, unsigned char decimalPlaces) {
> -     init();
> -     char buf[33];
> -     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> - }
> - 
> - String::String(double value, unsigned char decimalPlaces) {
> -     init();
> -     char buf[33];
> -     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> - }
> - 
> - String::~String() {
> -     invalidate();
> - }
> - 
> - // /*********************************************/
> - // /*  Memory Management                        */
> - // /*********************************************/
> - 
> - inline void String::init(void) {
> -     setSSO(true);
> -     setLen(0);
> -     wbuffer()[0] = 0;
> - }
> - 
> - void String::invalidate(void) {
> -     if(!isSSO() && wbuffer())
> -         free(wbuffer());
> -     init();
> - }
> - 
> - unsigned char String::reserve(unsigned int size) {
> -     if(buffer() && capacity() >= size)
> -         return 1;
> -     if(changeBuffer(size)) {
> -         if(len() == 0)
> -             wbuffer()[0] = 0;
> -         return 1;
> -     }
> -     return 0;
> - }
> - 
> - unsigned char String::changeBuffer(unsigned int maxStrLen) {
> -     // Can we use SSO here to avoid allocation?
> -     if (maxStrLen < sizeof(sso.buff) - 1) {
> -         if (isSSO() || !buffer()) {
> -             // Already using SSO, nothing to do
> -             uint16_t oldLen = len();
> -             setSSO(true);
> -             setLen(oldLen);
> -             return 1;
> -         } else { // if bufptr && !isSSO()
> -             // Using bufptr, need to shrink into sso.buff
> -             char temp[sizeof(sso.buff)];
> -             memcpy(temp, buffer(), maxStrLen);
> -             free(wbuffer());
> -             uint16_t oldLen = len();
> -             setSSO(true);
> -             setLen(oldLen);
> -             memcpy(wbuffer(), temp, maxStrLen);
> -             return 1;
> -         }
> -     }
> -     // Fallthrough to normal allocator
> -     size_t newSize = (maxStrLen + 16) & (~0xf);
> -     // Make sure we can fit newsize in the buffer
> -     if (newSize > CAPACITY_MAX) {
> -         return false;
> -     }
> -     uint16_t oldLen = len();
> -     char *newbuffer = (char *) realloc(isSSO() ? nullptr : wbuffer(), newSize);
> -     if (newbuffer) {
> -         size_t oldSize = capacity() + 1; // include NULL.
> -         if (isSSO()) {
> -             // Copy the SSO buffer into allocated space
> -             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
> -         }
> -         if (newSize > oldSize)
> -         {
> -             memset(newbuffer + oldSize, 0, newSize - oldSize);
> -         }
> -         setSSO(false);
> -         setCapacity(newSize - 1);
> -         setLen(oldLen); // Needed in case of SSO where len() never existed
> -         setBuffer(newbuffer);
> -         return 1;
> -     }
> -     return 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Copy and Move                            */
> - // /*********************************************/
> - 
> - String & String::copy(const char *cstr, unsigned int length) {
> -     if (!reserve(length)) {
> -         invalidate();
> -         return *this;
> -     }
> -     setLen(length);
> -     memmove_P(wbuffer(), cstr, length + 1);
> -     return *this;
> - }
> - 
> - String & String::copy(const __FlashStringHelper *pstr, unsigned int length) {
> -     if (!reserve(length)) {
> -         invalidate();
> -         return *this;
> -     }
> -     setLen(length);
> -     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
> -     return *this;
> - }
> - 
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> - void String::move(String &rhs) {
> -     if (buffer()) {
> -         if (capacity() >= rhs.len()) {
> -             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
> -             setLen(rhs.len());
> -             rhs.invalidate();
> -             return;
> -         } else {
> -             if (!isSSO()) {
> -                 free(wbuffer());
> -                 setBuffer(nullptr);
> -             }
> -         }
> -     }
> -     if (rhs.isSSO()) {
> -         setSSO(true);
> -         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
> -     } else {
> -         setSSO(false);
> -         setBuffer(rhs.wbuffer());
> -     }
> -     setCapacity(rhs.capacity());
> -     setLen(rhs.len());
> -     rhs.setSSO(false);
> -     rhs.setCapacity(0);
> -     rhs.setLen(0);
> -     rhs.setBuffer(nullptr);
> - }
> - #endif
> - 
> - String & String::operator =(const String &rhs) {
> -     if (this == &rhs)
> -         return *this;
> - 
> -     if (rhs.buffer())
> -         copy(rhs.buffer(), rhs.len());
> -     else
> -         invalidate();
> - 
> -     return *this;
> - }
> - 
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> - String & String::operator =(String &&rval) {
> -     if (this != &rval)
> -         move(rval);
> -     return *this;
> - }
> - 
> - String & String::operator =(StringSumHelper &&rval) {
> -     if (this != &rval)
> -         move(rval);
> -     return *this;
> - }
> - #endif
> - 
> - String & String::operator =(const char *cstr) {
> -     if (cstr)
> -         copy(cstr, strlen(cstr));
> -     else
> -         invalidate();
> - 
> -     return *this;
> - }
> - 
> - String & String::operator = (const __FlashStringHelper *pstr)
> - {
> -     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
> -     else invalidate();
> - 
> -     return *this;
> - }
> - 
> - // /*********************************************/
> - // /*  concat                                   */
> - // /*********************************************/
> - 
> - unsigned char String::concat(const String &s) {
> -     // Special case if we're concatting ourself (s += s;) since we may end up
> -     // realloc'ing the buffer and moving s.buffer in the method called
> -     if (&s == this) {
> -         unsigned int newlen = 2 * len();
> -         if (!s.buffer())
> -             return 0;
> -         if (s.len() == 0)
> -             return 1;
> -         if (!reserve(newlen))
> -             return 0;
> -         memmove_P(wbuffer() + len(), buffer(), len());
> -         setLen(newlen);
> -         wbuffer()[len()] = 0;
> -         return 1;
> -     } else {
> -         return concat(s.buffer(), s.len());
> -     }
> - }
> - 
> - unsigned char String::concat(const char *cstr, unsigned int length) {
> -     unsigned int newlen = len() + length;
> -     if (!cstr)
> -         return 0;
> -     if (length == 0)
> -         return 1;
> -     if (!reserve(newlen))
> -         return 0;
> -     memmove_P(wbuffer() + len(), cstr, length + 1);
> -     setLen(newlen);
> -     wbuffer()[newlen] = 0;
> -     return 1;
> - }
> - 
> - unsigned char String::concat(const char *cstr) {
> -     if (!cstr)
> -         return 0;
> -     return concat(cstr, strlen(cstr));
> - }
> - 
> - unsigned char String::concat(char c) {
> -     char buf[2];
> -     buf[0] = c;
> -     buf[1] = 0;
> -     return concat(buf, 1);
> - }
> - 
> - unsigned char String::concat(unsigned char num) {
> -     char buf[1 + 3 * sizeof(unsigned char)];
> -     sprintf(buf, "%d", num);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(int num) {
> -     char buf[2 + 3 * sizeof(int)];
> -     sprintf(buf, "%d", num);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(unsigned int num) {
> -     char buf[1 + 3 * sizeof(unsigned int)];
> -     utoa(num, buf, 10);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(long num) {
> -     char buf[2 + 3 * sizeof(long)];
> -     sprintf(buf, "%ld", num);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(unsigned long num) {
> -     char buf[1 + 3 * sizeof(unsigned long)];
> -     ultoa(num, buf, 10);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(float num) {
> -     char buf[20];
> -     char* string = dtostrf(num, 4, 2, buf);
> -     return concat(string, strlen(string));
> - }
> - 
> - unsigned char String::concat(double num) {
> -     char buf[20];
> -     char* string = dtostrf(num, 4, 2, buf);
> -     return concat(string, strlen(string));
> - }
> - 
> - unsigned char String::concat(const __FlashStringHelper * str) {
> -     if (!str) return 0;
> -     int length = strlen_P((PGM_P)str);
> -     if (length == 0) return 1;
> -     unsigned int newlen = len() + length;
> -     if (!reserve(newlen)) return 0;
> -     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
> -     setLen(newlen);
> -     return 1;
> - }
> - 
> - /*********************************************/
> - /*  Concatenate                              */
> - /*********************************************/
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(rhs.buffer(), rhs.len()))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!cstr || !a.concat(cstr, strlen(cstr)))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, char c) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(c))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, int num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, long num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, float num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, double num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> - {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(rhs))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - // /*********************************************/
> - // /*  Comparison                               */
> - // /*********************************************/
> - 
> - int String::compareTo(const String &s) const {
> -     if(!buffer() || !s.buffer()) {
> -         if(s.buffer() && s.len() > 0)
> -             return 0 - *(unsigned char *) s.buffer();
> -         if(buffer() && len() > 0)
> -             return *(unsigned char *) buffer();
> -         return 0;
> -     }
> -     return strcmp(buffer(), s.buffer());
> - }
> - 
> - unsigned char String::equals(const String &s2) const {
> -     return (len() == s2.len() && compareTo(s2) == 0);
> - }
> - 
> - unsigned char String::equals(const char *cstr) const {
> -     if (len() == 0)
> -         return (cstr == NULL || *cstr == 0);
> -     if (cstr == NULL)
> -         return buffer()[0] == 0;
> -     return strcmp(buffer(), cstr) == 0;
> - }
> - 
> - unsigned char String::operator<(const String &rhs) const {
> -     return compareTo(rhs) < 0;
> - }
> - 
> - unsigned char String::operator>(const String &rhs) const {
> -     return compareTo(rhs) > 0;
> - }
> - 
> - unsigned char String::operator<=(const String &rhs) const {
> -     return compareTo(rhs) <= 0;
> - }
> - 
> - unsigned char String::operator>=(const String &rhs) const {
> -     return compareTo(rhs) >= 0;
> - }
> - 
> - unsigned char String::equalsIgnoreCase(const String &s2) const {
> -     if (this == &s2)
> -         return 1;
> -     if (len() != s2.len())
> -         return 0;
> -     if (len() == 0)
> -         return 1;
> -     const char *p1 = buffer();
> -     const char *p2 = s2.buffer();
> -     while (*p1) {
> -         if (tolower(*p1++) != tolower(*p2++))
> -             return 0;
> -     }
> -     return 1;
> - }
> - 
> - unsigned char String::equalsConstantTime(const String &s2) const {
> -     // To avoid possible time-based attacks present function
> -     // compares given strings in a constant time.
> -     if (len() != s2.len())
> -         return 0;
> -     //at this point lengths are the same
> -     if (len() == 0)
> -         return 1;
> -     //at this point lenghts are the same and non-zero
> -     const char *p1 = buffer();
> -     const char *p2 = s2.buffer();
> -     unsigned int equalchars = 0;
> -     unsigned int diffchars = 0;
> -     while (*p1) {
> -         if (*p1 == *p2)
> -             ++equalchars;
> -         else
> -             ++diffchars;
> -         ++p1;
> -         ++p2;
> -     }
> -     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
> -     unsigned char equalcond = (equalchars == len());
> -     unsigned char diffcond = (diffchars == 0);
> -     return (equalcond & diffcond); //bitwise AND
> - }
> - 
> - unsigned char String::startsWith(const String &s2) const {
> -     if(len() < s2.len())
> -         return 0;
> -     return startsWith(s2, 0);
> - }
> - 
> - unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> -     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> -         return 0;
> -     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> - }
> - 
> - unsigned char String::endsWith(const String &s2) const {
> -     if(len() < s2.len() || !buffer() || !s2.buffer())
> -         return 0;
> -     return strcmp(&buffer()[len() - s2.len()], s2.buffer()) == 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Character Access                         */
> - // /*********************************************/
> - 
> - char String::charAt(unsigned int loc) const {
> -     return operator[](loc);
> - }
> - 
> - void String::setCharAt(unsigned int loc, char c) {
> -     if (loc < len())
> -         wbuffer()[loc] = c;
> - }
> - 
> - char & String::operator[](unsigned int index) {
> -     static char dummy_writable_char;
> -     if (index >= len() || !buffer()) {
> -         dummy_writable_char = 0;
> -         return dummy_writable_char;
> -     }
> -     return wbuffer()[index];
> - }
> - 
> - char String::operator[](unsigned int index) const {
> -     if (index >= len() || !buffer())
> -         return 0;
> -     return buffer()[index];
> - }
> - 
> - void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
> -     if (!bufsize || !buf)
> -         return;
> -     if (index >= len()) {
> -         buf[0] = 0;
> -         return;
> -     }
> -     unsigned int n = bufsize - 1;
> -     if (n > len() - index)
> -         n = len() - index;
> -     strncpy((char *) buf, buffer() + index, n);
> -     buf[n] = 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Search                                   */
> - // /*********************************************/
> - 
> - int String::indexOf(char c) const {
> -     return indexOf(c, 0);
> - }
> - 
> - int String::indexOf(char ch, unsigned int fromIndex) const {
> -     if (fromIndex >= len())
> -         return -1;
> -     const char* temp = strchr(buffer() + fromIndex, ch);
> -     if (temp == NULL)
> -         return -1;
> -     return temp - buffer();
> - }
> - 
> - int String::indexOf(const String &s2) const {
> -     return indexOf(s2, 0);
> - }
> - 
> - int String::indexOf(const String &s2, unsigned int fromIndex) const {
> -     if (fromIndex >= len())
> -         return -1;
> -     const char *found = strstr(buffer() + fromIndex, s2.buffer());
> -     if (found == NULL)
> -         return -1;
> -     return found - buffer();
> - }
> - 
> - int String::lastIndexOf(char theChar) const {
> -     return lastIndexOf(theChar, len() - 1);
> - }
> - 
> - int String::lastIndexOf(char ch, unsigned int fromIndex) const {
> -     if (fromIndex >= len())
> -         return -1;
> -     char tempchar = buffer()[fromIndex + 1];
> -     wbuffer()[fromIndex + 1] = '\0';
> -     char* temp = strrchr(wbuffer(), ch);
> -     wbuffer()[fromIndex + 1] = tempchar;
> -     if (temp == NULL)
> -         return -1;
> -     return temp - buffer();
> - }
> - 
> - int String::lastIndexOf(const String &s2) const {
> -     return lastIndexOf(s2, len() - s2.len());
> - }
> - 
> - int String::lastIndexOf(const String &s2, unsigned int fromIndex) const {
> -     if (s2.len() == 0 || len() == 0 || s2.len() > len())
> -         return -1;
> -     if (fromIndex >= len())
> -         fromIndex = len() - 1;
> -     int found = -1;
> -     for (char *p = wbuffer(); p <= wbuffer() + fromIndex; p++) {
> -         p = strstr(p, s2.buffer());
> -         if (!p)
> -             break;
> -         if ((unsigned int) (p - wbuffer()) <= fromIndex)
> -             found = p - buffer();
> -     }
> -     return found;
> - }
> - 
> - String String::substring(unsigned int left, unsigned int right) const {
> -     if (left > right) {
> -         unsigned int temp = right;
> -         right = left;
> -         left = temp;
> -     }
> -     String out;
> -     if (left >= len())
> -         return out;
> -     if (right > len())
> -         right = len();
> -     char temp = buffer()[right];  // save the replaced character
> -     wbuffer()[right] = '\0';
> -     out = wbuffer() + left;  // pointer arithmetic
> -     wbuffer()[right] = temp;  //restore character
> -     return out;
> - }
> - 
> - // /*********************************************/
> - // /*  Modification                             */
> - // /*********************************************/
> - 
> - void String::replace(char find, char replace) {
> -     if (!buffer())
> -         return;
> -     for (char *p = wbuffer(); *p; p++) {
> -         if (*p == find)
> -             *p = replace;
> -     }
> - }
> - 
> - void String::replace(const String& find, const String& replace) {
> -     if (len() == 0 || find.len() == 0)
> -         return;
> -     int diff = replace.len() - find.len();
> -     char *readFrom = wbuffer();
> -     char *foundAt;
> -     if (diff == 0) {
> -         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
> -             memmove_P(foundAt, replace.buffer(), replace.len());
> -             readFrom = foundAt + replace.len();
> -         }
> -     } else if (diff < 0) {
> -         char *writeTo = wbuffer();
> -         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
> -             unsigned int n = foundAt - readFrom;
> -             memmove_P(writeTo, readFrom, n);
> -             writeTo += n;
> -             memmove_P(writeTo, replace.buffer(), replace.len());
> -             writeTo += replace.len();
> -             readFrom = foundAt + find.len();
> -             setLen(len() + diff);
> -         }
> -         memmove_P(writeTo, readFrom, strlen(readFrom)+1);
> -     } else {
> -         unsigned int size = len(); // compute size needed for result
> -         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
> -             readFrom = foundAt + find.len();
> -             size += diff;
> -         }
> -         if (size == len())
> -             return;
> -         if (size > capacity() && !changeBuffer(size))
> -             return; // XXX: tell user!
> -         int index = len() - 1;
> -         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
> -             readFrom = wbuffer() + index + find.len();
> -             memmove_P(readFrom + diff, readFrom, len() - (readFrom - buffer()));
> -             int newLen = len() + diff;
> -             memmove_P(wbuffer() + index, replace.buffer(), replace.len());
> -             setLen(newLen);
> -             wbuffer()[newLen] = 0;
> -             index--;
> -         }
> -     }
> - }
> - 
> - void String::remove(unsigned int index) {
> -     // Pass the biggest integer as the count. The remove method
> -     // below will take care of truncating it at the end of the
> -     // string.
> -     remove(index, (unsigned int) -1);
> - }
> - 
> - void String::remove(unsigned int index, unsigned int count) {
> -     if (index >= len()) {
> -         return;
> -     }
> -     if (count <= 0) {
> -         return;
> -     }
> -     if (count > len() - index) {
> -         count = len() - index;
> -     }
> -     char *writeTo = wbuffer() + index;
> -     unsigned int newlen = len() - count;
> -     setLen(newlen);
> -     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
> -     wbuffer()[newlen] = 0;
> - }
> - 
> - void String::toLowerCase(void) {
> -     if (!buffer())
> -         return;
> -     for (char *p = wbuffer(); *p; p++) {
> -         *p = tolower(*p);
> -     }
> - }
> - 
> - void String::toUpperCase(void) {
> -     if (!buffer())
> -         return;
> -     for (char *p = wbuffer(); *p; p++) {
> -         *p = toupper(*p);
> -     }
> - }
> - 
> - void String::trim(void) {
> -     if (!buffer() || len() == 0)
> -         return;
> -     char *begin = wbuffer();
> -     while (isspace(*begin))
> -         begin++;
> -     char *end = wbuffer() + len() - 1;
> -     while (isspace(*end) && end >= begin)
> -         end--;
> -     unsigned int newlen = end + 1 - begin;
> -     setLen(newlen);
> -     if (begin > buffer())
> -         memmove_P(wbuffer(), begin, newlen);
> -     wbuffer()[newlen] = 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Parsing / Conversion                     */
> - // /*********************************************/
> - 
> - long String::toInt(void) const {
> -     if (buffer())
> -         return atol(buffer());
> -     return 0;
> - }
> - 
> - float String::toFloat(void) const {
> -     if (buffer())
> -         return atof(buffer());
> -     return 0;
> - }
> - 
> - double String::toDouble(void) const
> - {
> -     if (buffer())
> -         return atof(buffer());
> -     return 0.0;
> - }
> - 
> - // global empty string to allow returning const String& with nothing
> - 
> - const String emptyString;
> --- -5 -----
> + #include "WString/WStringEX.cpp"
> *** /dev/null
> --- /dev/null
> ***************
> *** 38,39
> - // An inherited class for holding the result of a concatenation.  These
> - // result objects are assumed to be writable by subsequent concatenations.
> --- 45,46 -----
> +  // An inherited class for holding the result of a concatenation.  These
> +  // result objects are assumed to be writable by subsequent concatenations.
> ***************
> *** 54,108
> -         // use a function pointer to allow for "if (s)" without the
> -         // complications of an operator bool(). for more information, see:
> -         // http://www.artima.com/cppsource/safebool.html
> -         typedef void (String::*StringIfHelperType)() const;
> -         void StringIfHelper() const {
> -         }
> - 
> -     public:
> -         // constructors
> -         // creates a copy of the initial value.
> -         // if the initial value is null or invalid, or if memory allocation
> -         // fails, the string will be marked as invalid (i.e. "if (s)" will
> -         // be false).
> -         String(const char *cstr = nullptr);
> -         String(const String &str);
> -         String(const __FlashStringHelper *str);
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> -         String(String &&rval);
> -         String(StringSumHelper &&rval);
> - #endif
> -         explicit String(char c);
> -         explicit String(unsigned char, unsigned char base = 10);
> -         explicit String(int, unsigned char base = 10);
> -         explicit String(unsigned int, unsigned char base = 10);
> -         explicit String(long, unsigned char base = 10);
> -         explicit String(unsigned long, unsigned char base = 10);
> -         explicit String(float, unsigned char decimalPlaces = 2);
> -         explicit String(double, unsigned char decimalPlaces = 2);
> -         ~String(void);
> - 
> -         // memory management
> -         // return true on success, false on failure (in which case, the string
> -         // is left unchanged).  reserve(0), if successful, will validate an
> -         // invalid string (i.e., "if (s)" will be true afterwards)
> -         unsigned char reserve(unsigned int size);
> -         inline unsigned int length(void) const {
> -             if(buffer()) {
> -                 return len();
> -             } else {
> -                 return 0;
> -             }
> -         }
> -         inline void clear(void) {
> -             setLen(0);
> -         }
> -         inline bool isEmpty(void) const {
> -             return length() == 0;
> -         }
> - 
> -         // creates a copy of the assigned value.  if the value is null or
> -         // invalid, or if the memory allocation fails, the string will be
> -         // marked as invalid ("if (s)" will be false).
> -         String & operator =(const String &rhs);
> -         String & operator =(const char *cstr);
> -         String & operator = (const __FlashStringHelper *str);
> --- 65,80 -----
> +     // use a function pointer to allow for "if (s)" without the
> +     // complications of an operator bool(). for more information, see:
> +     // http://www.artima.com/cppsource/safebool.html
> +     typedef void (String:: *StringIfHelperType)() const;
> +     void StringIfHelper() const {
> +     }
> + 
> + public:
> +     // constructors
> +     // creates a copy of the initial value.
> +     // if the initial value is null or invalid, or if memory allocation
> +     // fails, the string will be marked as invalid (i.e. "if (s)" will
> +     // be false).
> +     String(const char *cstr = nullptr);
> +     String(const String &str);
> +     String(const __FlashStringHelper *str);
> ***************
> *** 110,111
> -         String & operator =(String &&rval);
> -         String & operator =(StringSumHelper &&rval);
> --- 82,83 -----
> +     String(String &&rval);
> +     String(StringSumHelper &&rval);
> ***************
> *** 123
> -         // concatenate (works w/ built-in types)
> --- 104,122 -----
> +     // memory management
> +     // return true on success, false on failure (in which case, the string
> +     // is left unchanged).  reserve(0), if successful, will validate an
> +     // invalid string (i.e., "if (s)" will be true afterwards)
> +     unsigned char reserve(unsigned int size);
> +     inline unsigned int length(void) const {
> +         if (buffer()) {
> +             return len();
> +         }
> +         else {
> +             return 0;
> +         }
> +     }
> +     inline void clear(void) {
> +         setLen(0);
> +     }
> +     inline bool isEmpty(void) const {
> +         return length() == 0;
> +     }
> ***************
> *** 125,338
> -         // returns true on success, false on failure (in which case, the string
> -         // is left unchanged).  if the argument is null or invalid, the
> -         // concatenation is considered unsuccessful.
> -         unsigned char concat(const String &str);
> -         unsigned char concat(const char *cstr);
> -         unsigned char concat(char c);
> -         unsigned char concat(unsigned char c);
> -         unsigned char concat(int num);
> -         unsigned char concat(unsigned int num);
> -         unsigned char concat(long num);
> -         unsigned char concat(unsigned long num);
> -         unsigned char concat(float num);
> -         unsigned char concat(double num);
> -         unsigned char concat(const __FlashStringHelper * str);
> -         unsigned char concat(const char *cstr, unsigned int length);
> - 
> -         // if there's not enough memory for the concatenated value, the string
> -         // will be left unchanged (but this isn't signalled in any way)
> -         String & operator +=(const String &rhs) {
> -             concat(rhs);
> -             return (*this);
> -         }
> -         String & operator +=(const char *cstr) {
> -             concat(cstr);
> -             return (*this);
> -         }
> -         String & operator +=(char c) {
> -             concat(c);
> -             return (*this);
> -         }
> -         String & operator +=(unsigned char num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(int num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(unsigned int num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(long num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(unsigned long num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(float num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(double num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator += (const __FlashStringHelper *str){
> -             concat(str);
> -             return (*this);
> -         }
> - 
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, char c);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, int num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, long num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, float num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, double num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, const __FlashStringHelper *rhs);
> - 
> -         // comparison (only works w/ Strings and "strings")
> -         operator StringIfHelperType() const {
> -             return buffer() ? &String::StringIfHelper : 0;
> -         }
> -         int compareTo(const String &s) const;
> -         unsigned char equals(const String &s) const;
> -         unsigned char equals(const char *cstr) const;
> -         unsigned char operator ==(const String &rhs) const {
> -             return equals(rhs);
> -         }
> -         unsigned char operator ==(const char *cstr) const {
> -             return equals(cstr);
> -         }
> -         unsigned char operator !=(const String &rhs) const {
> -             return !equals(rhs);
> -         }
> -         unsigned char operator !=(const char *cstr) const {
> -             return !equals(cstr);
> -         }
> -         unsigned char operator <(const String &rhs) const;
> -         unsigned char operator >(const String &rhs) const;
> -         unsigned char operator <=(const String &rhs) const;
> -         unsigned char operator >=(const String &rhs) const;
> -         unsigned char equalsIgnoreCase(const String &s) const;
> -         unsigned char equalsConstantTime(const String &s) const;
> -         unsigned char startsWith(const String &prefix) const;
> -         unsigned char startsWith(const char * prefix) const {
> -             return this->startsWith(String(prefix));
> -         }
> -         unsigned char startsWith(const __FlashStringHelper * prefix) const {
> -             return this->startsWith(String(prefix));
> -         }
> -         unsigned char startsWith(const String &prefix, unsigned int offset) const;
> -         unsigned char endsWith(const String &suffix) const;
> -         unsigned char endsWith(const char * suffix) const {
> -             return this->endsWith(String(suffix));
> -         }
> -         unsigned char endsWith(const __FlashStringHelper * suffix) const {
> -             return this->endsWith(String(suffix));
> -         }
> - 
> -         // character access
> -         char charAt(unsigned int index) const;
> -         void setCharAt(unsigned int index, char c);
> -         char operator [](unsigned int index) const;
> -         char& operator [](unsigned int index);
> -         void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
> -         void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
> -             getBytes((unsigned char *) buf, bufsize, index);
> -         }
> -         const char* c_str() const { return buffer(); }
> -         char* begin() { return wbuffer(); }
> -         char* end() { return wbuffer() + length(); }
> -         const char* begin() const { return c_str(); }
> -         const char* end() const { return c_str() + length(); }
> - 
> -         // search
> -         int indexOf(char ch) const;
> -         int indexOf(char ch, unsigned int fromIndex) const;
> -         int indexOf(const String &str) const;
> -         int indexOf(const String &str, unsigned int fromIndex) const;
> -         int lastIndexOf(char ch) const;
> -         int lastIndexOf(char ch, unsigned int fromIndex) const;
> -         int lastIndexOf(const String &str) const;
> -         int lastIndexOf(const String &str, unsigned int fromIndex) const;
> -         String substring(unsigned int beginIndex) const {
> -             return substring(beginIndex, len());
> -         }
> -         ;
> -         String substring(unsigned int beginIndex, unsigned int endIndex) const;
> - 
> -         // modification
> -         void replace(char find, char replace);
> -         void replace(const String& find, const String& replace);
> -         void replace(const char * find, const String& replace) {
> -             this->replace(String(find), replace);
> -         }
> -         void replace(const __FlashStringHelper * find, const String& replace) {
> -             this->replace(String(find), replace);
> -         }
> -         void replace(const char * find, const char * replace) {
> -             this->replace(String(find), String(replace));
> -         }
> -         void replace(const __FlashStringHelper * find, const char * replace) {
> -             this->replace(String(find), String(replace));
> -         }
> -         void replace(const __FlashStringHelper * find, const __FlashStringHelper * replace) {
> -             this->replace(String(find), String(replace));
> -         }
> -         void remove(unsigned int index);
> -         void remove(unsigned int index, unsigned int count);
> -         void toLowerCase(void);
> -         void toUpperCase(void);
> -         void trim(void);
> - 
> -         // parsing/conversion
> -         long toInt(void) const;
> -         float toFloat(void) const;
> - 	double toDouble(void) const;
> - 
> -     protected:
> -         // Contains the string info when we're not in SSO mode
> -         struct _ptr { 
> -             char *   buff;
> -             uint16_t cap;
> -             uint16_t len;
> -         };
> -         // This allows strings up up to 11 (10 + \0 termination) without any extra space.
> -         enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
> -         struct _sso {
> -             char     buff[SSOSIZE];
> -             unsigned char len   : 7; // Ensure only one byte is allocated by GCC for the bitfields
> -             unsigned char isSSO : 1;
> -         } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
> -         enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
> -         union {
> -             struct _ptr ptr;
> -             struct _sso sso;
> -         };
> -         // Accessor functions
> -         inline bool isSSO() const { return sso.isSSO; }
> -         inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
> -         inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
> -         inline void setSSO(bool set) { sso.isSSO = set; }
> -         inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
> -         inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
> - 	inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
> -         // Buffer accessor functions
> -         inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
> -         inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> - 
> -     protected:
> -         void init(void);
> -         void invalidate(void);
> -         unsigned char changeBuffer(unsigned int maxStrLen);
> - 
> -         // copy and move
> -         String & copy(const char *cstr, unsigned int length);
> -         String & copy(const __FlashStringHelper *pstr, unsigned int length);
> --- 124,129 -----
> +     // creates a copy of the assigned value.  if the value is null or
> +     // invalid, or if the memory allocation fails, the string will be
> +     // marked as invalid ("if (s)" will be false).
> +     String &operator =(const String &rhs);
> +     String &operator =(const char *cstr);
> +     String &operator = (const __FlashStringHelper *str);
> ***************
> *** 340
> -         void move(String &rhs);
> --- 131,132 -----
> +     String &operator =(String &&rval);
> +     String &operator =(StringSumHelper &&rval);
> ***************
> *** 343,346
> - class StringSumHelper: public String {
> -     public:
> -         StringSumHelper(const String &s) :
> -                 String(s) {
> --- 134,570 -----
> +     // concatenate (works w/ built-in types)
> + 
> +     // returns true on success, false on failure (in which case, the string
> +     // is left unchanged).  if the argument is null or invalid, the
> +     // concatenation is considered unsuccessful.
> +     unsigned char concat(const String &str);
> +     unsigned char concat(const char *cstr);
> +     unsigned char concat(char c);
> +     unsigned char concat(unsigned char c);
> +     unsigned char concat(int num);
> +     unsigned char concat(unsigned int num);
> +     unsigned char concat(long num);
> +     unsigned char concat(unsigned long num);
> +     unsigned char concat(float num);
> +     unsigned char concat(double num);
> +     unsigned char concat(const __FlashStringHelper *str);
> +     unsigned char concat(const char *cstr, unsigned int length);
> + 
> +     // if there's not enough memory for the concatenated value, the string
> +     // will be left unchanged (but this isn't signalled in any way)
> +     String &operator +=(const String &rhs) {
> +         concat(rhs);
> +         return (*this);
> +     }
> +     String &operator +=(const char *cstr) {
> +         concat(cstr);
> +         return (*this);
> +     }
> +     String &operator +=(char c) {
> +         concat(c);
> +         return (*this);
> +     }
> +     String &operator +=(unsigned char num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(int num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(unsigned int num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(long num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(unsigned long num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(float num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(double num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator += (const __FlashStringHelper *str) {
> +         concat(str);
> +         return (*this);
> +     }
> + 
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, char c);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, int num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, long num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, float num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, double num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, const __FlashStringHelper *rhs);
> + 
> +     // comparison (only works w/ Strings and "strings")
> +     operator StringIfHelperType() const {
> +         return buffer() ? &String::StringIfHelper : 0;
> +     }
> +     unsigned char operator ==(char ch) const {
> +         return equals(ch);
> +     }
> +     unsigned char operator ==(const String &rhs) const {
> +         return equals(rhs);
> +     }
> +     unsigned char operator ==(const char *cstr) const {
> +         return equals(cstr);
> +     }
> +     unsigned char operator ==(const __FlashStringHelper *fstr) const {
> +         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) == 0;
> +     }
> +     unsigned char operator !=(char ch) const {
> +         return !equals(ch);
> +     }
> +     unsigned char operator !=(const String &rhs) const {
> +         return !equals(rhs);
> +     }
> +     unsigned char operator !=(const char *cstr) const {
> +         return !equals(cstr);
> +     }
> +     unsigned char operator !=(const __FlashStringHelper *fstr) const {
> +         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) != 0;
> +     }
> + 
> +     unsigned char operator <(const String &rhs) const;
> +     unsigned char operator >(const String &rhs) const;
> +     unsigned char operator <=(const String &rhs) const;
> +     unsigned char operator >=(const String &rhs) const;
> + 
> +     int compareTo(const String &s) const;
> + 
> +     //
> +     // equals()
> +     //
> +     // changed behaviour:
> +     // any nullptr argument will return false -> String.equals(nullptr) does not return true if String is empty
> + 
> +     // the terminating NUL byte is not considered part of the string
> +     // String.equals('\0') always returns false, even if String is empty
> +     // use length() == 0 to determine if a string is empty
> +     unsigned char equals(char ch) const {
> +         if (length() != 1 || !ch) {
> +             return false;
> +         }
> +         return buffer()[0] == ch;
> +     }
> + 
> +     unsigned char equals(const String &str) const {
> +         if (this == &str) {
> +             return true;
> +         }
> +         if (length() != str.length()) {
> +             return false;
> +         }
> +         return strcmp(buffer(), str.buffer()) == 0;
> +     }
> + 
> +     unsigned char equals(const char *cStr) const {
> +         if (!cStr) {
> +             return false;
> +         }
> +         if (length() == 0) {
> +             return (*cStr == 0);
> +         }
> +         return strcmp(buffer(), cStr) == 0;
> +     }
> + 
> +     unsigned char equals(const __FlashStringHelper *fStr) const {
> +         if (!fStr) {
> +             return false;
> +         }
> +         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fStr)) == 0;
> +     }
> + 
> +     // return true if String matches the end of str1
> +     // basically a.endsWith(b) = b.endEquals(a)
> +     //
> +     // String("123").endEquals("test123") == true
> +     // String("").endEquals(nullptr) == false
> +     bool endEquals(const char *str1) const {
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcmp(str1, buffer()) == 0;
> +         }
> +         return strcmp(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     bool endEquals(const __FlashStringHelper *fStr) const {
> +         PGM_P str1 = reinterpret_cast<PGM_P>(fStr);
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen_P(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcmp_P_P(str1, buffer()) == 0;
> +         }
> +         return strcmp_P_P(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     // we can use endsWith in this case
> +     inline bool endEquals(const String &str) const {
> +         return str.endsWith(*this);
> +     }
> + 
> +     // return true if String matches the end of str1
> +     // basically a.endsWith(b) = b.endEquals(a)
> +     //
> +     // String("abc").endEqualsIgnoreCase("TESTABC") == true
> +     // String("").endEqualsIgnoreCase(nullptr) == false
> +     bool endEqualsIgnoreCase(const char *str1) const {
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcasecmp(str1, buffer()) == 0;
> +         }
> +         return strcasecmp(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     bool endEqualsIgnoreCase(const __FlashStringHelper *fStr) const {
> +         PGM_P str1 = reinterpret_cast<PGM_P>(fStr);
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen_P(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcasecmp_P_P(str1, buffer()) == 0;
> +         }
> +         return strcasecmp_P_P(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     // we can just use endsWithIgnoreCase in this case
> +     inline bool endEqualsIgnoreCase(const String &str) const {
> +         return str.endsWithIgnoreCase(*this);
> +     }
> + 
> +     //
> +     // equals() with offset
> +     //
> + 
> +     unsigned char equals(const String &str, size_t offset) const {
> +         size_t len1;
> +         size_t len2;
> +         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
> +             return false;
> +         }
> +         return strcmp(buffer() + offset, str.c_str()) == 0;
> +     }
> + 
> +     unsigned char equals(const char *cStr, size_t offset) const {
> +         if (!cStr || !*cStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcmp(buffer() + offset, cStr) == 0;
> +     }
> + 
> +     unsigned char equals(const __FlashStringHelper *fStr, size_t offset) const {
> +         if (!fStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
> +     }
> + 
> +     //
> +     // equalsIgnoreCase() with offset
> +     //
> + 
> +     unsigned char equalsIgnoreCase(const String &str, size_t offset = 0) const {
> +         if (offset == 0 && this == &str) {
> +             return true;
> +         }
> +         size_t len1;
> +         size_t len2;
> +         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
> +             return false;
> +         }
> +         return strcasecmp(buffer() + offset, str.c_str()) == 0;
> +     }
> + 
> +     unsigned char equalsIgnoreCase(const char *cStr, size_t offset = 0) const {
> +         if (!cStr || !*cStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcasecmp(buffer() + offset, cStr) == 0;
> +     }
> + 
> +     unsigned char equalsIgnoreCase(const __FlashStringHelper *fStr, size_t offset = 0) const {
> +         if (!fStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcasecmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
> +     }
> + 
> +     //
> +     // equalsConstantTime
> +     //
> + 
> +     unsigned char equalsConstantTime(const String &s) const;
> + 
> +     //
> +     // _startsWith
> +     //
> + 
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWith(const char *prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncmp(c_str() + offset, prefix, prefixLen);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWith_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncmp_P(c_str() + offset, prefix, prefixLen);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWithIgnoreCase(const char *prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp(c_str() + offset, prefix, prefixLen);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWithIgnoreCase_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp_P(c_str() + offset, prefix, prefixLen);
> +     }
> + 
> +     //
> +     // startsWith(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
> +     //
> + 
> +     unsigned char startsWith(char ch) const {
> +         return (length() != 0) && (buffer()[0] == ch);
> +     }
> +     unsigned char startsWith(char ch, size_t offset) const {
> +         return (length() > offset) && (buffer()[offset] == ch);
> +     }
> +     unsigned char startsWith(const char *prefix, size_t offset = 0) const {
> +         return prefix && _startsWith(prefix, strlen(prefix), offset);
> +     }
> +     unsigned char startsWith(const String &prefix, size_t offset = 0) const {
> +         size_t len;
> +         return ((len = prefix.length())) != 0 && _startsWith(prefix.buffer(), len, offset);
> +     }
> +     unsigned char startsWith(const __FlashStringHelper *prefix, size_t offset = 0) const {
> +         return prefix && _startsWith_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
> +     }
> + 
> +     //
> +     // startsWithIgnoreCase(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
> +     //
> + 
> +     unsigned char startsWithIgnoreCase(char ch, size_t offset = 0) const {
> +         return (length() > offset) && (tolower(buffer()[offset]) == tolower(ch));
> +     }
> +     unsigned char startsWithIgnoreCase(const char *prefix, size_t offset = 0) const {
> +         return prefix && _startsWithIgnoreCase(prefix, strlen(prefix), offset);
> +     }
> +     unsigned char startsWithIgnoreCase(const String &prefix, size_t offset = 0) const {
> +         size_t len;
> +         return ((len = prefix.length())) != 0 && _startsWithIgnoreCase(prefix.buffer(), len, offset);
> +     }
> +     unsigned char startsWithIgnoreCase(const __FlashStringHelper *prefix, size_t offset = 0) const {
> +         return prefix && _startsWithIgnoreCase_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
> +     }
> + 
> +     //
> +     // _endsWith
> +     //
> + 
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWith(const char *suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcmp(buffer() + len - suffixLen, suffix);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWith_P(PGM_P suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcmp_P(buffer() + len - suffixLen, suffix);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWithIgnoreCase(const char *suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp(buffer() + len - suffixLen, suffix);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWithIgnoreCase_P(PGM_P suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp_P(buffer() + len - suffixLen, suffix);
> +     }
> + 
> +     //
> +     // endsWith
> +     //
> + 
> +     unsigned char endsWith(char ch) const {
> +         auto len = length();
> +         return (len != 0) && (buffer()[len - 1] == ch);
> +     }
> +     unsigned char endsWith(const String &suffix) const {
> +         return _endsWith(suffix.buffer(), suffix.length());
> +     }
> +     unsigned char endsWith(const char *suffix) const {
> +         return suffix && _endsWith(suffix, strlen(suffix));
> +     }
> +     unsigned char endsWith(const __FlashStringHelper *suffix) const {
> +         return suffix && _endsWith_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
> +     }
> + 
> +     //
> +     // endsWithIgnoreCase
> +     //
> + 
> +     unsigned char endsWithIgnoreCase(char ch) const {
> +         auto len = length();
> +         return (len != 0) && (tolower(buffer()[len - 1]) == tolower(ch));
> +     }
> +     unsigned char endsWithIgnoreCase(const String &suffix) const {
> +         return _endsWithIgnoreCase(suffix.buffer(), suffix.length());
> +     }
> +     unsigned char endsWithIgnoreCase(const char *suffix) const {
> +         return suffix && _endsWithIgnoreCase(suffix, strlen(suffix));
> +     }
> +     unsigned char endsWithIgnoreCase(const __FlashStringHelper *suffix) const {
> +         return suffix && _endsWithIgnoreCase_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
> +     }
> + 
> +     // character access
> +     char charAt(unsigned int index) const;
> +     void setCharAt(unsigned int index, char c);
> +     char operator [](unsigned int index) const;
> +     char &operator [](unsigned int index);
> +     void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
> +     void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
> +         getBytes((unsigned char *)buf, bufsize, index);
> +     }
> +     const char *c_str() const { return buffer(); }
> +     char *begin() { return wbuffer(); }
> +     char *end() { return wbuffer() + length(); }
> +     const char *begin() const { return c_str(); }
> +     const char *end() const { return c_str() + length(); }
> + 
> + protected:
> +     // findLength is optional, provide only if available
> +     int _indexOf(const char *find, size_t fromIndex, size_t findLength = ~0) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
> +             return -1;
> +         }
> +         auto ptr = buffer();
> +         auto idxPtr = strstr(ptr + fromIndex, find);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 348,349
> -         StringSumHelper(const char *p) :
> -                 String(p) {
> --- 572,584 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _indexOfIgnoreCase(const char *find, size_t fromIndex, size_t findLength = ~0) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
> +             return -1;
> +         }
> +         auto ptr = wbuffer();
> +         auto idxPtr = stristr(ptr + fromIndex, find);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 351,352
> -         StringSumHelper(char c) :
> -                 String(c) {
> --- 586,598 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _indexOf_P(PGM_P find, size_t fromIndex, size_t findLength = ~0) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
> +             return -1;
> +         }
> +         auto ptr = buffer();
> +         auto idxPtr = strstr_P(ptr + fromIndex, find);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 354,355
> -         StringSumHelper(unsigned char num) :
> -                 String(num) {
> --- 600,612 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _indexOfIgnoreCase_P(PGM_P find, size_t fromIndex, size_t findLength) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (fromIndex + findLength >= len)) {
> +             return -1;
> +         }
> +         auto ptr = buffer();
> +         auto idxPtr = stristr_P(ptr + fromIndex, find, findLength);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 357,358
> -         StringSumHelper(int num) :
> -                 String(num) {
> --- 614,621 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _lastIndexOf(char find) const
> +     {
> +         auto ptr = strrchr(buffer(), find);
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 360,361
> -         StringSumHelper(unsigned int num) :
> -                 String(num) {
> --- 623,630 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf_P(char find) const
> +     {
> +         auto ptr = strrchr_P(buffer(), find);
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 363,364
> -         StringSumHelper(long num) :
> -                 String(num) {
> --- 632,649 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf(char find, size_t fromIndex) const
> +     {
> +         if (!find) {
> +             return -1;
> +         }
> +         auto len = length();
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex > len || fromIndex < 1) {
> +             return -1;
> +         }
> +         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 366,367
> -         StringSumHelper(unsigned long num) :
> -                 String(num) {
> --- 651,668 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf_P(char find, size_t fromIndex) const
> +     {
> +         if (!find) {
> +             return -1;
> +         }
> +         auto len = length();
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex > len || fromIndex < 1) {
> +             return -1;
> +         }
> +         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 369,370
> -         StringSumHelper(float num) :
> -                 String(num) {
> --- 670,687 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf_P(PGM_P find, size_t fromIndex, size_t findLen) const
> +     {
> +         size_t len;
> +         if (!find || !(len = length())) {
> +             return -1;
> +         }
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex < findLen || fromIndex > len) {
> +             return -1;
> +         }
> +         auto ptr = __strrstr_P(wbuffer(), fromIndex + findLen, find, findLen);
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 372,373
> -         StringSumHelper(double num) :
> -                 String(num) {
> --- 689,706 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf(const char *find, size_t fromIndex, size_t findLen) const
> +     {
> +         size_t len;
> +         if (!find || !(len = length())) {
> +             return -1;
> +         }
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex < findLen || fromIndex > len) {
> +             return -1;
> +         }
> +         auto ptr = __strrstr(wbuffer(), fromIndex + findLen, find, findLen);
> +         if (!ptr) {
> +             return -1;
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/.rej ./framework-arduinoespressif8266/.rej
0a1,3170
> *** /dev/null
> --- /dev/null
> ***************
> *** 221
> -     while (p != &__init_array_start)
> --- 221 -----
> +     while (p != &__init_array_start) {
> ***************
> *** 0
> --- 223 -----
> +     }
> *** /dev/null
> --- /dev/null
> ***************
> *** 83
> - static void ets_printf_P(const char *str, ...) {
> --- 83,88 -----
> + 
> + // exported for using in custom_crash_callback()
> + extern void ___static_ets_printf_P(const char *str, ...);
> + #define ets_printf_P ___static_ets_printf_P
> + 
> + void ___static_ets_printf_P(const char *str, ...) {
> *** /dev/null
> --- /dev/null
> ***************
> *** 0
> --- 207,209 -----
> + #ifdef HAVE_KFC_FIRMWARE_VERSION
> + extern Stream &Serial;
> + #else
> ***************
> *** 0
> --- 211 -----
> + #endif
> *** /dev/null
> --- /dev/null
> ***************
> *** 0
> --- 1,2 -----
> + 
> + #include "WStringEx.cpp"
> *** /dev/null
> --- /dev/null
> ***************
> *** 0
> --- 1,859 -----
> + /*
> +  WString.cpp - String library for Wiring & Arduino
> +  ...mostly rewritten by Paul Stoffregen...
> +  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
> +  Copyright 2011, Paul Stoffregen, paul@pjrc.com
> +  Modified by Ivan Grokhotkov, 2014 - esp8266 support
> +  Modified by Michael C. Miller, 2015 - esp8266 progmem support
> + 
> +  This library is free software; you can redistribute it and/or
> +  modify it under the terms of the GNU Lesser General Public
> +  License as published by the Free Software Foundation; either
> +  version 2.1 of the License, or (at your option) any later version.
> + 
> +  This library is distributed in the hope that it will be useful,
> +  but WITHOUT ANY WARRANTY; without even the implied warranty of
> +  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> +  Lesser General Public License for more details.
> + 
> +  You should have received a copy of the GNU Lesser General Public
> +  License along with this library; if not, write to the Free Software
> +  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
> +  */
> + 
> + #ifdef _MSC_VER
> + #include <Arduino_compat.h>
> + #include "cores/esp8266/WString.h"
> + #include "util/stdlib_noniso.h"
> + #else
> + #include <Arduino.h>
> + #include "WString.h"
> + #include "stdlib_noniso.h"
> + #endif
> + 
> +  /*********************************************/
> +  /*  Constructors                             */
> +  /*********************************************/
> + 
> + String::String(const char *cstr) {
> +     init();
> +     if (cstr)
> +         copy(cstr, strlen(cstr));
> + }
> + 
> + String::String(const String &value) {
> +     init();
> +     *this = value;
> + }
> + 
> + String::String(const __FlashStringHelper *pstr) {
> +     init();
> +     *this = pstr; // see operator =
> + }
> + 
> + #ifdef __GXX_EXPERIMENTAL_CXX0X__
> + String::String(String &&rval) {
> +     init();
> +     move(rval);
> + }
> + 
> + String::String(StringSumHelper &&rval) {
> +     init();
> +     move(rval);
> + }
> + #endif
> + 
> + String::String(char c) {
> +     init();
> +     char buf[2];
> +     buf[0] = c;
> +     buf[1] = 0;
> +     *this = buf;
> + }
> + 
> + String::String(unsigned char value, unsigned char base) {
> +     init();
> +     char buf[1 + 8 * sizeof(unsigned char)];
> +     utoa(value, buf, base);
> +     *this = buf;
> + }
> + 
> + String::String(int value, unsigned char base) {
> +     init();
> +     char buf[2 + 8 * sizeof(int)];
> +     if (base == 10) {
> +         sprintf(buf, "%d", value);
> +     }
> +     else {
> +         itoa(value, buf, base);
> +     }
> +     *this = buf;
> + }
> + 
> + String::String(unsigned int value, unsigned char base) {
> +     init();
> +     char buf[1 + 8 * sizeof(unsigned int)];
> +     utoa(value, buf, base);
> +     *this = buf;
> + }
> + 
> + String::String(long value, unsigned char base) {
> +     init();
> +     char buf[2 + 8 * sizeof(long)];
> +     if (base == 10) {
> +         sprintf(buf, "%ld", value);
> +     }
> +     else {
> +         ltoa(value, buf, base);
> +     }
> +     *this = buf;
> + }
> + 
> + String::String(unsigned long value, unsigned char base) {
> +     init();
> +     char buf[1 + 8 * sizeof(unsigned long)];
> +     ultoa(value, buf, base);
> +     *this = buf;
> + }
> + 
> + String::String(float value, unsigned char decimalPlaces) {
> +     init();
> +     char buf[33];
> +     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> + }
> + 
> + String::String(double value, unsigned char decimalPlaces) {
> +     init();
> +     char buf[33];
> +     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> + }
> + 
> + String::~String() {
> +     invalidate();
> + }
> + 
> + // /*********************************************/
> + // /*  Memory Management                        */
> + // /*********************************************/
> + 
> + void String::invalidate(void) {
> +     if (!isSSO() && wbuffer())
> +         free(wbuffer());
> +     init();
> + }
> + 
> + unsigned char String::reserve(unsigned int size) {
> +     if (buffer() && capacity() >= size)
> +         return 1;
> +     if (changeBuffer(size)) {
> +         if (len() == 0)
> +             wbuffer()[0] = 0;
> +         return 1;
> +     }
> +     return 0;
> + }
> + 
> + unsigned char String::changeBuffer(unsigned int maxStrLen) {
> +     // Can we use SSO here to avoid allocation?
> +     if (maxStrLen < sizeof(sso.buff) - 1) {
> +         if (isSSO() || !buffer()) {
> +             // Already using SSO, nothing to do
> +             uint16_t oldLen = len();
> +             setSSO(true);
> +             setLen(oldLen);
> +             return 1;
> +         }
> +         else { // if bufptr && !isSSO()
> +          // Using bufptr, need to shrink into sso.buff
> +             char temp[sizeof(sso.buff)];
> +             memcpy(temp, buffer(), maxStrLen);
> +             free(wbuffer());
> +             uint16_t oldLen = len();
> +             setSSO(true);
> +             setLen(oldLen);
> +             memcpy(wbuffer(), temp, maxStrLen);
> +             return 1;
> +         }
> +     }
> +     // Fallthrough to normal allocator
> +     size_t newSize = (maxStrLen + 16) & (~0xf);
> +     // Make sure we can fit newsize in the buffer
> +     if (newSize > CAPACITY_MAX) {
> +         return false;
> +     }
> +     uint16_t oldLen = len();
> +     char *newbuffer = (char *)realloc(isSSO() ? nullptr : wbuffer(), newSize);
> +     if (newbuffer) {
> +         size_t oldSize = capacity() + 1; // include NULL.
> +         if (isSSO()) {
> +             // Copy the SSO buffer into allocated space
> +             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
> +         }
> +         if (newSize > oldSize)
> +         {
> +             memset(newbuffer + oldSize, 0, newSize - oldSize);
> +         }
> +         setSSO(false);
> +         setCapacity(newSize - 1);
> +         setLen(oldLen); // Needed in case of SSO where len() never existed
> +         setBuffer(newbuffer);
> +         return 1;
> +     }
> +     return 0;
> + }
> + 
> + // /*********************************************/
> + // /*  Copy and Move                            */
> + // /*********************************************/
> + 
> + String &String::copy(const char *cstr, unsigned int length) {
> +     if (!reserve(length)) {
> +         invalidate();
> +         return *this;
> +     }
> +     setLen(length);
> +     memmove_P(wbuffer(), cstr, length + 1);
> +     return *this;
> + }
> + 
> + String &String::copy(const __FlashStringHelper *pstr, unsigned int length) {
> +     if (!reserve(length)) {
> +         invalidate();
> +         return *this;
> +     }
> +     setLen(length);
> +     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
> +     return *this;
> + }
> + 
> + #ifdef __GXX_EXPERIMENTAL_CXX0X__
> + void String::move(String &rhs) {
> +     if (buffer()) {
> +         if (capacity() >= rhs.len()) {
> +             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
> +             setLen(rhs.len());
> +             rhs.invalidate();
> +             return;
> +         }
> +         else {
> +             if (!isSSO()) {
> +                 free(wbuffer());
> +                 setBuffer(nullptr);
> +             }
> +         }
> +     }
> +     if (rhs.isSSO()) {
> +         setSSO(true);
> +         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
> +     }
> +     else {
> +         setSSO(false);
> +         setBuffer(rhs.wbuffer());
> +     }
> +     setCapacity(rhs.capacity());
> +     setLen(rhs.len());
> +     rhs.setSSO(false);
> +     rhs.setCapacity(0);
> +     rhs.setLen(0);
> +     rhs.setBuffer(nullptr);
> + }
> + #endif
> + 
> + String &String::operator =(const String &rhs) {
> +     if (this == &rhs)
> +         return *this;
> + 
> +     if (rhs.buffer())
> +         copy(rhs.buffer(), rhs.len());
> +     else
> +         invalidate();
> + 
> +     return *this;
> + }
> + 
> + #ifdef __GXX_EXPERIMENTAL_CXX0X__
> + String &String::operator =(String &&rval) {
> +     if (this != &rval)
> +         move(rval);
> +     return *this;
> + }
> + 
> + String &String::operator =(StringSumHelper &&rval) {
> +     if (this != &rval)
> +         move(rval);
> +     return *this;
> + }
> + #endif
> + 
> + String &String::operator =(const char *cstr) {
> +     if (cstr)
> +         copy(cstr, strlen(cstr));
> +     else
> +         invalidate();
> + 
> +     return *this;
> + }
> + 
> + String &String::operator = (const __FlashStringHelper *pstr)
> + {
> +     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
> +     else invalidate();
> + 
> +     return *this;
> + }
> + 
> + // /*********************************************/
> + // /*  concat                                   */
> + // /*********************************************/
> + 
> + unsigned char String::concat(const String &s) {
> +     // Special case if we're concatting ourself (s += s;) since we may end up
> +     // realloc'ing the buffer and moving s.buffer in the method called
> +     if (&s == this) {
> +         unsigned int newlen = 2 * len();
> +         if (!s.buffer())
> +             return 0;
> +         if (s.len() == 0)
> +             return 1;
> +         if (!reserve(newlen))
> +             return 0;
> +         memmove_P(wbuffer() + len(), buffer(), len());
> +         setLen(newlen);
> +         wbuffer()[len()] = 0;
> +         return 1;
> +     }
> +     else {
> +         return concat(s.buffer(), s.len());
> +     }
> + }
> + 
> + unsigned char String::concat(const char *cstr, unsigned int length) {
> +     unsigned int newlen = len() + length;
> +     if (!cstr)
> +         return 0;
> +     if (length == 0)
> +         return 1;
> +     if (!reserve(newlen))
> +         return 0;
> +     memmove_P(wbuffer() + len(), cstr, length + 1);
> +     setLen(newlen);
> +     wbuffer()[newlen] = 0;
> +     return 1;
> + }
> + 
> + unsigned char String::concat(const char *cstr) {
> +     if (!cstr)
> +         return 0;
> +     return concat(cstr, strlen(cstr));
> + }
> + 
> + unsigned char String::concat(char c) {
> +     char buf[2];
> +     buf[0] = c;
> +     buf[1] = 0;
> +     return concat(buf, 1);
> + }
> + 
> + unsigned char String::concat(unsigned char num) {
> +     char buf[1 + 3 * sizeof(unsigned char)];
> +     sprintf(buf, "%d", num);
> +     return concat(buf, strlen(buf));
> + }
> + 
> + unsigned char String::concat(int num) {
> +     char buf[2 + 3 * sizeof(int)];
> +     sprintf(buf, "%d", num);
> +     return concat(buf, strlen(buf));
> + }
> + 
> + unsigned char String::concat(unsigned int num) {
> +     char buf[1 + 3 * sizeof(unsigned int)];
> +     utoa(num, buf, 10);
> +     return concat(buf, strlen(buf));
> + }
> + 
> + unsigned char String::concat(long num) {
> +     char buf[2 + 3 * sizeof(long)];
> +     sprintf(buf, "%ld", num);
> +     return concat(buf, strlen(buf));
> + }
> + 
> + unsigned char String::concat(unsigned long num) {
> +     char buf[1 + 3 * sizeof(unsigned long)];
> +     ultoa(num, buf, 10);
> +     return concat(buf, strlen(buf));
> + }
> + 
> + unsigned char String::concat(float num) {
> +     char buf[20];
> +     char *string = dtostrf(num, 4, 2, buf);
> +     return concat(string, strlen(string));
> + }
> + 
> + unsigned char String::concat(double num) {
> +     char buf[20];
> +     char *string = dtostrf(num, 4, 2, buf);
> +     return concat(string, strlen(string));
> + }
> + 
> + unsigned char String::concat(const __FlashStringHelper *str) {
> +     if (!str) return 0;
> +     int length = strlen_P((PGM_P)str);
> +     if (length == 0) return 1;
> +     unsigned int newlen = len() + length;
> +     if (!reserve(newlen)) return 0;
> +     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
> +     setLen(newlen);
> +     return 1;
> + }
> + 
> + /*********************************************/
> + /*  Concatenate                              */
> + /*********************************************/
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(rhs.buffer(), rhs.len()))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!cstr || !a.concat(cstr, strlen(cstr)))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, char c) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(c))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(num))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, int num) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(num))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(num))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, long num) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(num))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(num))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, float num) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(num))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator +(const StringSumHelper &lhs, double num) {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(num))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + StringSumHelper &operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> + {
> +     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
> +     if (!a.concat(rhs))
> +         a.invalidate();
> +     return a;
> + }
> + 
> + // /*********************************************/
> + // /*  Comparison                               */
> + // /*********************************************/
> + 
> + int String::compareTo(const String &s) const {
> +     if (!buffer() || !s.buffer()) {
> +         if (s.buffer() && s.len() > 0)
> +             return 0 - *(unsigned char *)s.buffer();
> +         if (buffer() && len() > 0)
> +             return *(unsigned char *)buffer();
> +         return 0;
> +     }
> +     return strcmp(buffer(), s.buffer());
> + }
> + 
> + 
> + unsigned char String::operator<(const String &rhs) const {
> +     return compareTo(rhs) < 0;
> + }
> + 
> + unsigned char String::operator>(const String &rhs) const {
> +     return compareTo(rhs) > 0;
> + }
> + 
> + unsigned char String::operator<=(const String &rhs) const {
> +     return compareTo(rhs) <= 0;
> + }
> + 
> + unsigned char String::operator>=(const String &rhs) const {
> +     return compareTo(rhs) >= 0;
> + }
> + 
> + unsigned char String::equalsConstantTime(const String &s2) const {
> +     // To avoid possible time-based attacks present function
> +     // compares given strings in a constant time.
> +     if (len() != s2.len())
> +         return 0;
> +     //at this point lengths are the same
> +     if (len() == 0)
> +         return 1;
> +     //at this point lenghts are the same and non-zero
> +     const char *p1 = buffer();
> +     const char *p2 = s2.buffer();
> +     unsigned int equalchars = 0;
> +     unsigned int diffchars = 0;
> +     while (*p1) {
> +         if (*p1 == *p2)
> +             ++equalchars;
> +         else
> +             ++diffchars;
> +         ++p1;
> +         ++p2;
> +     }
> +     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
> +     unsigned char equalcond = (equalchars == len());
> +     unsigned char diffcond = (diffchars == 0);
> +     return (equalcond & diffcond); //bitwise AND
> + }
> + 
> + // unsigned char String::startsWith(const String &s2) const {
> + //     if(len() < s2.len())
> + //         return 0;
> + //     return startsWith(s2, 0);
> + // }
> + 
> + // unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> + //     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> + //         return 0;
> + //     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> + // }
> + 
> + // /*********************************************/
> + // /*  Character Access                         */
> + // /*********************************************/
> + 
> + char String::charAt(unsigned int loc) const {
> +     return operator[](loc);
> + }
> + 
> + void String::setCharAt(unsigned int loc, char c) {
> +     if (loc < len())
> +         wbuffer()[loc] = c;
> + }
> + 
> + char &String::operator[](unsigned int index) {
> +     static char dummy_writable_char;
> +     if (index >= len() || !buffer()) {
> +         dummy_writable_char = 0;
> +         return dummy_writable_char;
> +     }
> +     return wbuffer()[index];
> + }
> + 
> + char String::operator[](unsigned int index) const {
> +     if (index >= len() || !buffer())
> +         return 0;
> +     return buffer()[index];
> + }
> + 
> + void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
> +     if (!bufsize || !buf)
> +         return;
> +     if (index >= len()) {
> +         buf[0] = 0;
> +         return;
> +     }
> +     unsigned int n = bufsize - 1;
> +     if (n > len() - index)
> +         n = len() - index;
> +     strncpy((char *)buf, buffer() + index, n);
> +     buf[n] = 0;
> + }
> + 
> + // /*********************************************/
> + // /*  Search                                   */
> + // /*********************************************/
> + 
> + int String::indexOf(char ch, unsigned int fromIndex) const {
> +     if (fromIndex >= len())
> +         return -1;
> +     const char *temp = strchr(buffer() + fromIndex, ch);
> +     if (temp == NULL)
> +         return -1;
> +     return temp - buffer();
> + }
> + 
> + int String::indexOf(const String &s2) const {
> +     return indexOf(s2, 0);
> + }
> + 
> + int String::indexOf(const String &s2, unsigned int fromIndex) const {
> +     if (fromIndex >= len())
> +         return -1;
> +     const char *found = strstr(buffer() + fromIndex, s2.buffer());
> +     if (found == NULL)
> +         return -1;
> +     return found - buffer();
> + }
> + 
> + String String::substring(unsigned int left, unsigned int right) const {
> +     if (left > right) {
> +         unsigned int temp = right;
> +         right = left;
> +         left = temp;
> +     }
> +     String out;
> +     if (left >= len())
> +         return out;
> +     if (right > len())
> +         right = len();
> +     char temp = buffer()[right];  // save the replaced character
> +     wbuffer()[right] = '\0';
> +     out = wbuffer() + left;  // pointer arithmetic
> +     wbuffer()[right] = temp;  //restore character
> +     return out;
> + }
> + 
> + // /*********************************************/
> + // /*  Modification                             */
> + // /*********************************************/
> + 
> + bool String::insert(size_t pos, PGM_P insert, size_t insertLen) {
> +     size_t len;
> +     if (insertLen == 0 || (len = length()) == 0 || pos >= len) {
> +         return false;
> +     }
> +     auto requiredLen = len + insertLen;
> +     if (!reserve(requiredLen)) {
> +         return false;
> +     }
> +     setLen(requiredLen);
> +     memmove(wbuffer() + pos + insertLen, wbuffer() + pos, len - pos/* + 1 NUL byte*/);
> +     memmove_P(wbuffer() + pos, insert, insertLen);
> +     wbuffer()[requiredLen] = 0;
> +     return true;
> + }
> + 
> + 
> + bool String::replace(char find, char replace)
> + {
> +     if (!buffer())
> +         return true;
> +     for (char *p = wbuffer(); *p; p++) {
> +         if (*p == find) {
> +             *p = replace;
> +         }
> +     }
> +     return true;
> + }
> + 
> + bool String::_replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen)
> + {
> +     if (length() == 0 || findLen == 0 || !find) {
> +         return false;
> +     }
> +     int diff = replaceLen - findLen;
> +     char *readFrom = wbuffer();
> +     char *foundAt;
> +     if (diff == 0) {
> +         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
> +             memmove_P(foundAt, replace, replaceLen);
> +             readFrom = foundAt + replaceLen;
> +         }
> +     }
> +     else if (diff < 0) {
> +         char *writeTo = wbuffer();
> +         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
> +             unsigned int n = foundAt - readFrom;
> +             memmove(writeTo, readFrom, n);
> +             writeTo += n;
> +             memmove_P(writeTo, replace, replaceLen);
> +             writeTo += replaceLen;
> +             readFrom = foundAt + findLen;
> +             setLen(len() + diff);
> +         }
> +         memmove(writeTo, readFrom, strlen(readFrom) + 1);
> +     }
> +     else {
> +         unsigned int size = len(); // compute size needed for result
> +         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
> +             readFrom = foundAt + findLen;
> +             size += diff;
> +         }
> +         if (size == len()) {
> +             return true;
> +         }
> +         if (size > capacity() && !changeBuffer(size)) {
> +             return false;
> +         }
> +         int index = len() - 1;
> +         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
> +             readFrom = wbuffer() + index + findLen;
> +             memmove(readFrom + diff, readFrom, len() - (readFrom - buffer()));
> +             int newLen = len() + diff;
> +             memmove_P(wbuffer() + index, replace, replaceLen);
> +             setLen(newLen);
> +             wbuffer()[newLen] = 0;
> +             index--;
> +         }
> +     }
> +     return true;
> + }
> + 
> + void String::remove(unsigned int index) {
> +     // Pass the biggest integer as the count. The remove method
> +     // below will take care of truncating it at the end of the
> +     // string.
> +     remove(index, (unsigned int)-1);
> + }
> + 
> + void String::remove(unsigned int index, unsigned int count) {
> +     if (index >= len()) {
> +         return;
> +     }
> +     if (count <= 0) {
> +         return;
> +     }
> +     if (count > len() - index) {
> +         count = len() - index;
> +     }
> +     char *writeTo = wbuffer() + index;
> +     unsigned int newlen = len() - count;
> +     setLen(newlen);
> +     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
> +     wbuffer()[newlen] = 0;
> + }
> + 
> + String &String::toLowerCase(void)
> + {
> +     if (!buffer()) {
> +         return *this;
> +     }
> +     for (char *p = wbuffer(); *p; p++) {
> +         *p = tolower(*p);
> +     }
> +     return *this;
> + }
> + 
> + String &String::toUpperCase(void)
> + {
> +     if (!buffer()) {
> +         return *this;
> +     }
> +     for (char *p = wbuffer(); *p; p++) {
> +         *p = toupper(*p);
> +     }
> +     return *this;
> + }
> + 
> + 
> + String &String::_trim(TrimType type)
> + {
> +     auto len = length();
> +     if (len == 0) {
> +         return *this;
> +     }
> +     char *begin = wbuffer();
> +     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
> +         while (isspace(*begin)) {
> +             begin++;
> +         }
> +     }
> +     char *end = wbuffer() + len - 1;
> +     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
> +         while (isspace(*end) && end >= begin) {
> +             end--;
> +         }
> +     }
> +     unsigned int newlen = end + 1 - begin;
> +     if (begin > buffer()) {
> +         memmove(wbuffer(), begin, newlen);
> +     }
> +     setLen(newlen);
> +     wbuffer()[newlen] = 0;
> +     return *this;
> + }
> + 
> + String &String::_trim(TrimType type, PGM_P characters, size_t charLen)
> + {
> +     auto len = length();
> +     if (!len || !characters || !charLen) {
> +         return *this;
> +     }
> +     charLen++; // use memchr instead of strchr to avoid additional NUL byte check
> +     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
> +         while (len && memchr_P(characters, buffer()[len - 1], charLen)) {
> +             len--;
> +         }
> +         setLen(len);
> +     }
> + 
> +     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
> +         size_t remove = 0;
> +         while (memchr_P(characters, buffer()[remove], charLen)) {
> +             remove++;
> +         }
> +         this->remove(0, remove); // remove adds NUL byte
> +     }
> +     else {
> +         wbuffer()[len] = 0;
> +     }
> +     return *this;
> + }
> + 
> + 
> + // /*********************************************/
> + // /*  Parsing / Conversion                     */
> + // /*********************************************/
> + 
> + long String::toInt(void) const
> + {
> +     if (buffer()) {
> +         return atol(buffer());
> +     }
> +     return 0;
> + }
> + 
> + float String::toFloat(void) const
> + {
> +     if (buffer()) {
> +         return atof(buffer());
> +     }
> +     return 0;
> + }
> + 
> + // global empty string to allow returning const String& with nothing
> + 
> + const String emptyString;
> *** /dev/null
> --- /dev/null
> ***************
> *** 1,7
> - /*
> -  WString.cpp - String library for Wiring & Arduino
> -  ...mostly rewritten by Paul Stoffregen...
> -  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
> -  Copyright 2011, Paul Stoffregen, paul@pjrc.com
> -  Modified by Ivan Grokhotkov, 2014 - esp8266 support
> -  Modified by Michael C. Miller, 2015 - esp8266 progmem support
> --- 0 -----
> ***************
> *** 9,856
> -  This library is free software; you can redistribute it and/or
> -  modify it under the terms of the GNU Lesser General Public
> -  License as published by the Free Software Foundation; either
> -  version 2.1 of the License, or (at your option) any later version.
> - 
> -  This library is distributed in the hope that it will be useful,
> -  but WITHOUT ANY WARRANTY; without even the implied warranty of
> -  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
> -  Lesser General Public License for more details.
> - 
> -  You should have received a copy of the GNU Lesser General Public
> -  License along with this library; if not, write to the Free Software
> -  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
> -  */
> - 
> - #include <Arduino.h>
> - #include "WString.h"
> - #include "stdlib_noniso.h"
> - 
> - /*********************************************/
> - /*  Constructors                             */
> - /*********************************************/
> - 
> - String::String(const char *cstr) {
> -     init();
> -     if (cstr)
> -         copy(cstr, strlen(cstr));
> - }
> - 
> - String::String(const String &value) {
> -     init();
> -     *this = value;
> - }
> - 
> - String::String(const __FlashStringHelper *pstr) {
> -     init();
> -     *this = pstr; // see operator =
> - }
> - 
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> - String::String(String &&rval) {
> -     init();
> -     move(rval);
> - }
> - 
> - String::String(StringSumHelper &&rval) {
> -     init();
> -     move(rval);
> - }
> - #endif
> - 
> - String::String(char c) {
> -     init();
> -     char buf[2];
> -     buf[0] = c;
> -     buf[1] = 0;
> -     *this = buf;
> - }
> - 
> - String::String(unsigned char value, unsigned char base) {
> -     init();
> -     char buf[1 + 8 * sizeof(unsigned char)];
> -     utoa(value, buf, base);
> -     *this = buf;
> - }
> - 
> - String::String(int value, unsigned char base) {
> -     init();
> -     char buf[2 + 8 * sizeof(int)];
> -     if (base == 10) {
> -         sprintf(buf, "%d", value);
> -     } else {
> -         itoa(value, buf, base);
> -     }
> -     *this = buf;
> - }
> - 
> - String::String(unsigned int value, unsigned char base) {
> -     init();
> -     char buf[1 + 8 * sizeof(unsigned int)];
> -     utoa(value, buf, base);
> -     *this = buf;
> - }
> - 
> - String::String(long value, unsigned char base) {
> -     init();
> -     char buf[2 + 8 * sizeof(long)];
> -     if (base==10) {
> -         sprintf(buf, "%ld", value);
> -     } else {
> -         ltoa(value, buf, base);
> -     }
> -     *this = buf;
> - }
> - 
> - String::String(unsigned long value, unsigned char base) {
> -     init();
> -     char buf[1 + 8 * sizeof(unsigned long)];
> -     ultoa(value, buf, base);
> -     *this = buf;
> - }
> - 
> - String::String(float value, unsigned char decimalPlaces) {
> -     init();
> -     char buf[33];
> -     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> - }
> - 
> - String::String(double value, unsigned char decimalPlaces) {
> -     init();
> -     char buf[33];
> -     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> - }
> - 
> - String::~String() {
> -     invalidate();
> - }
> - 
> - // /*********************************************/
> - // /*  Memory Management                        */
> - // /*********************************************/
> - 
> - inline void String::init(void) {
> -     setSSO(true);
> -     setLen(0);
> -     wbuffer()[0] = 0;
> - }
> - 
> - void String::invalidate(void) {
> -     if(!isSSO() && wbuffer())
> -         free(wbuffer());
> -     init();
> - }
> - 
> - unsigned char String::reserve(unsigned int size) {
> -     if(buffer() && capacity() >= size)
> -         return 1;
> -     if(changeBuffer(size)) {
> -         if(len() == 0)
> -             wbuffer()[0] = 0;
> -         return 1;
> -     }
> -     return 0;
> - }
> - 
> - unsigned char String::changeBuffer(unsigned int maxStrLen) {
> -     // Can we use SSO here to avoid allocation?
> -     if (maxStrLen < sizeof(sso.buff) - 1) {
> -         if (isSSO() || !buffer()) {
> -             // Already using SSO, nothing to do
> -             uint16_t oldLen = len();
> -             setSSO(true);
> -             setLen(oldLen);
> -             return 1;
> -         } else { // if bufptr && !isSSO()
> -             // Using bufptr, need to shrink into sso.buff
> -             char temp[sizeof(sso.buff)];
> -             memcpy(temp, buffer(), maxStrLen);
> -             free(wbuffer());
> -             uint16_t oldLen = len();
> -             setSSO(true);
> -             setLen(oldLen);
> -             memcpy(wbuffer(), temp, maxStrLen);
> -             return 1;
> -         }
> -     }
> -     // Fallthrough to normal allocator
> -     size_t newSize = (maxStrLen + 16) & (~0xf);
> -     // Make sure we can fit newsize in the buffer
> -     if (newSize > CAPACITY_MAX) {
> -         return false;
> -     }
> -     uint16_t oldLen = len();
> -     char *newbuffer = (char *) realloc(isSSO() ? nullptr : wbuffer(), newSize);
> -     if (newbuffer) {
> -         size_t oldSize = capacity() + 1; // include NULL.
> -         if (isSSO()) {
> -             // Copy the SSO buffer into allocated space
> -             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
> -         }
> -         if (newSize > oldSize)
> -         {
> -             memset(newbuffer + oldSize, 0, newSize - oldSize);
> -         }
> -         setSSO(false);
> -         setCapacity(newSize - 1);
> -         setLen(oldLen); // Needed in case of SSO where len() never existed
> -         setBuffer(newbuffer);
> -         return 1;
> -     }
> -     return 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Copy and Move                            */
> - // /*********************************************/
> - 
> - String & String::copy(const char *cstr, unsigned int length) {
> -     if (!reserve(length)) {
> -         invalidate();
> -         return *this;
> -     }
> -     setLen(length);
> -     memmove_P(wbuffer(), cstr, length + 1);
> -     return *this;
> - }
> - 
> - String & String::copy(const __FlashStringHelper *pstr, unsigned int length) {
> -     if (!reserve(length)) {
> -         invalidate();
> -         return *this;
> -     }
> -     setLen(length);
> -     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
> -     return *this;
> - }
> - 
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> - void String::move(String &rhs) {
> -     if (buffer()) {
> -         if (capacity() >= rhs.len()) {
> -             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
> -             setLen(rhs.len());
> -             rhs.invalidate();
> -             return;
> -         } else {
> -             if (!isSSO()) {
> -                 free(wbuffer());
> -                 setBuffer(nullptr);
> -             }
> -         }
> -     }
> -     if (rhs.isSSO()) {
> -         setSSO(true);
> -         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
> -     } else {
> -         setSSO(false);
> -         setBuffer(rhs.wbuffer());
> -     }
> -     setCapacity(rhs.capacity());
> -     setLen(rhs.len());
> -     rhs.setSSO(false);
> -     rhs.setCapacity(0);
> -     rhs.setLen(0);
> -     rhs.setBuffer(nullptr);
> - }
> - #endif
> - 
> - String & String::operator =(const String &rhs) {
> -     if (this == &rhs)
> -         return *this;
> - 
> -     if (rhs.buffer())
> -         copy(rhs.buffer(), rhs.len());
> -     else
> -         invalidate();
> - 
> -     return *this;
> - }
> - 
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> - String & String::operator =(String &&rval) {
> -     if (this != &rval)
> -         move(rval);
> -     return *this;
> - }
> - 
> - String & String::operator =(StringSumHelper &&rval) {
> -     if (this != &rval)
> -         move(rval);
> -     return *this;
> - }
> - #endif
> - 
> - String & String::operator =(const char *cstr) {
> -     if (cstr)
> -         copy(cstr, strlen(cstr));
> -     else
> -         invalidate();
> - 
> -     return *this;
> - }
> - 
> - String & String::operator = (const __FlashStringHelper *pstr)
> - {
> -     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
> -     else invalidate();
> - 
> -     return *this;
> - }
> - 
> - // /*********************************************/
> - // /*  concat                                   */
> - // /*********************************************/
> - 
> - unsigned char String::concat(const String &s) {
> -     // Special case if we're concatting ourself (s += s;) since we may end up
> -     // realloc'ing the buffer and moving s.buffer in the method called
> -     if (&s == this) {
> -         unsigned int newlen = 2 * len();
> -         if (!s.buffer())
> -             return 0;
> -         if (s.len() == 0)
> -             return 1;
> -         if (!reserve(newlen))
> -             return 0;
> -         memmove_P(wbuffer() + len(), buffer(), len());
> -         setLen(newlen);
> -         wbuffer()[len()] = 0;
> -         return 1;
> -     } else {
> -         return concat(s.buffer(), s.len());
> -     }
> - }
> - 
> - unsigned char String::concat(const char *cstr, unsigned int length) {
> -     unsigned int newlen = len() + length;
> -     if (!cstr)
> -         return 0;
> -     if (length == 0)
> -         return 1;
> -     if (!reserve(newlen))
> -         return 0;
> -     memmove_P(wbuffer() + len(), cstr, length + 1);
> -     setLen(newlen);
> -     wbuffer()[newlen] = 0;
> -     return 1;
> - }
> - 
> - unsigned char String::concat(const char *cstr) {
> -     if (!cstr)
> -         return 0;
> -     return concat(cstr, strlen(cstr));
> - }
> - 
> - unsigned char String::concat(char c) {
> -     char buf[2];
> -     buf[0] = c;
> -     buf[1] = 0;
> -     return concat(buf, 1);
> - }
> - 
> - unsigned char String::concat(unsigned char num) {
> -     char buf[1 + 3 * sizeof(unsigned char)];
> -     sprintf(buf, "%d", num);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(int num) {
> -     char buf[2 + 3 * sizeof(int)];
> -     sprintf(buf, "%d", num);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(unsigned int num) {
> -     char buf[1 + 3 * sizeof(unsigned int)];
> -     utoa(num, buf, 10);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(long num) {
> -     char buf[2 + 3 * sizeof(long)];
> -     sprintf(buf, "%ld", num);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(unsigned long num) {
> -     char buf[1 + 3 * sizeof(unsigned long)];
> -     ultoa(num, buf, 10);
> -     return concat(buf, strlen(buf));
> - }
> - 
> - unsigned char String::concat(float num) {
> -     char buf[20];
> -     char* string = dtostrf(num, 4, 2, buf);
> -     return concat(string, strlen(string));
> - }
> - 
> - unsigned char String::concat(double num) {
> -     char buf[20];
> -     char* string = dtostrf(num, 4, 2, buf);
> -     return concat(string, strlen(string));
> - }
> - 
> - unsigned char String::concat(const __FlashStringHelper * str) {
> -     if (!str) return 0;
> -     int length = strlen_P((PGM_P)str);
> -     if (length == 0) return 1;
> -     unsigned int newlen = len() + length;
> -     if (!reserve(newlen)) return 0;
> -     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
> -     setLen(newlen);
> -     return 1;
> - }
> - 
> - /*********************************************/
> - /*  Concatenate                              */
> - /*********************************************/
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(rhs.buffer(), rhs.len()))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!cstr || !a.concat(cstr, strlen(cstr)))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, char c) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(c))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, int num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, long num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, float num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator +(const StringSumHelper &lhs, double num) {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(num))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - StringSumHelper & operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> - {
> -     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
> -     if (!a.concat(rhs))
> -         a.invalidate();
> -     return a;
> - }
> - 
> - // /*********************************************/
> - // /*  Comparison                               */
> - // /*********************************************/
> - 
> - int String::compareTo(const String &s) const {
> -     if(!buffer() || !s.buffer()) {
> -         if(s.buffer() && s.len() > 0)
> -             return 0 - *(unsigned char *) s.buffer();
> -         if(buffer() && len() > 0)
> -             return *(unsigned char *) buffer();
> -         return 0;
> -     }
> -     return strcmp(buffer(), s.buffer());
> - }
> - 
> - unsigned char String::equals(const String &s2) const {
> -     return (len() == s2.len() && compareTo(s2) == 0);
> - }
> - 
> - unsigned char String::equals(const char *cstr) const {
> -     if (len() == 0)
> -         return (cstr == NULL || *cstr == 0);
> -     if (cstr == NULL)
> -         return buffer()[0] == 0;
> -     return strcmp(buffer(), cstr) == 0;
> - }
> - 
> - unsigned char String::operator<(const String &rhs) const {
> -     return compareTo(rhs) < 0;
> - }
> - 
> - unsigned char String::operator>(const String &rhs) const {
> -     return compareTo(rhs) > 0;
> - }
> - 
> - unsigned char String::operator<=(const String &rhs) const {
> -     return compareTo(rhs) <= 0;
> - }
> - 
> - unsigned char String::operator>=(const String &rhs) const {
> -     return compareTo(rhs) >= 0;
> - }
> - 
> - unsigned char String::equalsIgnoreCase(const String &s2) const {
> -     if (this == &s2)
> -         return 1;
> -     if (len() != s2.len())
> -         return 0;
> -     if (len() == 0)
> -         return 1;
> -     const char *p1 = buffer();
> -     const char *p2 = s2.buffer();
> -     while (*p1) {
> -         if (tolower(*p1++) != tolower(*p2++))
> -             return 0;
> -     }
> -     return 1;
> - }
> - 
> - unsigned char String::equalsConstantTime(const String &s2) const {
> -     // To avoid possible time-based attacks present function
> -     // compares given strings in a constant time.
> -     if (len() != s2.len())
> -         return 0;
> -     //at this point lengths are the same
> -     if (len() == 0)
> -         return 1;
> -     //at this point lenghts are the same and non-zero
> -     const char *p1 = buffer();
> -     const char *p2 = s2.buffer();
> -     unsigned int equalchars = 0;
> -     unsigned int diffchars = 0;
> -     while (*p1) {
> -         if (*p1 == *p2)
> -             ++equalchars;
> -         else
> -             ++diffchars;
> -         ++p1;
> -         ++p2;
> -     }
> -     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
> -     unsigned char equalcond = (equalchars == len());
> -     unsigned char diffcond = (diffchars == 0);
> -     return (equalcond & diffcond); //bitwise AND
> - }
> - 
> - unsigned char String::startsWith(const String &s2) const {
> -     if(len() < s2.len())
> -         return 0;
> -     return startsWith(s2, 0);
> - }
> - 
> - unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> -     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> -         return 0;
> -     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> - }
> - 
> - unsigned char String::endsWith(const String &s2) const {
> -     if(len() < s2.len() || !buffer() || !s2.buffer())
> -         return 0;
> -     return strcmp(&buffer()[len() - s2.len()], s2.buffer()) == 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Character Access                         */
> - // /*********************************************/
> - 
> - char String::charAt(unsigned int loc) const {
> -     return operator[](loc);
> - }
> - 
> - void String::setCharAt(unsigned int loc, char c) {
> -     if (loc < len())
> -         wbuffer()[loc] = c;
> - }
> - 
> - char & String::operator[](unsigned int index) {
> -     static char dummy_writable_char;
> -     if (index >= len() || !buffer()) {
> -         dummy_writable_char = 0;
> -         return dummy_writable_char;
> -     }
> -     return wbuffer()[index];
> - }
> - 
> - char String::operator[](unsigned int index) const {
> -     if (index >= len() || !buffer())
> -         return 0;
> -     return buffer()[index];
> - }
> - 
> - void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
> -     if (!bufsize || !buf)
> -         return;
> -     if (index >= len()) {
> -         buf[0] = 0;
> -         return;
> -     }
> -     unsigned int n = bufsize - 1;
> -     if (n > len() - index)
> -         n = len() - index;
> -     strncpy((char *) buf, buffer() + index, n);
> -     buf[n] = 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Search                                   */
> - // /*********************************************/
> - 
> - int String::indexOf(char c) const {
> -     return indexOf(c, 0);
> - }
> - 
> - int String::indexOf(char ch, unsigned int fromIndex) const {
> -     if (fromIndex >= len())
> -         return -1;
> -     const char* temp = strchr(buffer() + fromIndex, ch);
> -     if (temp == NULL)
> -         return -1;
> -     return temp - buffer();
> - }
> - 
> - int String::indexOf(const String &s2) const {
> -     return indexOf(s2, 0);
> - }
> - 
> - int String::indexOf(const String &s2, unsigned int fromIndex) const {
> -     if (fromIndex >= len())
> -         return -1;
> -     const char *found = strstr(buffer() + fromIndex, s2.buffer());
> -     if (found == NULL)
> -         return -1;
> -     return found - buffer();
> - }
> - 
> - int String::lastIndexOf(char theChar) const {
> -     return lastIndexOf(theChar, len() - 1);
> - }
> - 
> - int String::lastIndexOf(char ch, unsigned int fromIndex) const {
> -     if (fromIndex >= len())
> -         return -1;
> -     char tempchar = buffer()[fromIndex + 1];
> -     wbuffer()[fromIndex + 1] = '\0';
> -     char* temp = strrchr(wbuffer(), ch);
> -     wbuffer()[fromIndex + 1] = tempchar;
> -     if (temp == NULL)
> -         return -1;
> -     return temp - buffer();
> - }
> - 
> - int String::lastIndexOf(const String &s2) const {
> -     return lastIndexOf(s2, len() - s2.len());
> - }
> - 
> - int String::lastIndexOf(const String &s2, unsigned int fromIndex) const {
> -     if (s2.len() == 0 || len() == 0 || s2.len() > len())
> -         return -1;
> -     if (fromIndex >= len())
> -         fromIndex = len() - 1;
> -     int found = -1;
> -     for (char *p = wbuffer(); p <= wbuffer() + fromIndex; p++) {
> -         p = strstr(p, s2.buffer());
> -         if (!p)
> -             break;
> -         if ((unsigned int) (p - wbuffer()) <= fromIndex)
> -             found = p - buffer();
> -     }
> -     return found;
> - }
> - 
> - String String::substring(unsigned int left, unsigned int right) const {
> -     if (left > right) {
> -         unsigned int temp = right;
> -         right = left;
> -         left = temp;
> -     }
> -     String out;
> -     if (left >= len())
> -         return out;
> -     if (right > len())
> -         right = len();
> -     char temp = buffer()[right];  // save the replaced character
> -     wbuffer()[right] = '\0';
> -     out = wbuffer() + left;  // pointer arithmetic
> -     wbuffer()[right] = temp;  //restore character
> -     return out;
> - }
> - 
> - // /*********************************************/
> - // /*  Modification                             */
> - // /*********************************************/
> - 
> - void String::replace(char find, char replace) {
> -     if (!buffer())
> -         return;
> -     for (char *p = wbuffer(); *p; p++) {
> -         if (*p == find)
> -             *p = replace;
> -     }
> - }
> - 
> - void String::replace(const String& find, const String& replace) {
> -     if (len() == 0 || find.len() == 0)
> -         return;
> -     int diff = replace.len() - find.len();
> -     char *readFrom = wbuffer();
> -     char *foundAt;
> -     if (diff == 0) {
> -         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
> -             memmove_P(foundAt, replace.buffer(), replace.len());
> -             readFrom = foundAt + replace.len();
> -         }
> -     } else if (diff < 0) {
> -         char *writeTo = wbuffer();
> -         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
> -             unsigned int n = foundAt - readFrom;
> -             memmove_P(writeTo, readFrom, n);
> -             writeTo += n;
> -             memmove_P(writeTo, replace.buffer(), replace.len());
> -             writeTo += replace.len();
> -             readFrom = foundAt + find.len();
> -             setLen(len() + diff);
> -         }
> -         memmove_P(writeTo, readFrom, strlen(readFrom)+1);
> -     } else {
> -         unsigned int size = len(); // compute size needed for result
> -         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
> -             readFrom = foundAt + find.len();
> -             size += diff;
> -         }
> -         if (size == len())
> -             return;
> -         if (size > capacity() && !changeBuffer(size))
> -             return; // XXX: tell user!
> -         int index = len() - 1;
> -         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
> -             readFrom = wbuffer() + index + find.len();
> -             memmove_P(readFrom + diff, readFrom, len() - (readFrom - buffer()));
> -             int newLen = len() + diff;
> -             memmove_P(wbuffer() + index, replace.buffer(), replace.len());
> -             setLen(newLen);
> -             wbuffer()[newLen] = 0;
> -             index--;
> -         }
> -     }
> - }
> - 
> - void String::remove(unsigned int index) {
> -     // Pass the biggest integer as the count. The remove method
> -     // below will take care of truncating it at the end of the
> -     // string.
> -     remove(index, (unsigned int) -1);
> - }
> - 
> - void String::remove(unsigned int index, unsigned int count) {
> -     if (index >= len()) {
> -         return;
> -     }
> -     if (count <= 0) {
> -         return;
> -     }
> -     if (count > len() - index) {
> -         count = len() - index;
> -     }
> -     char *writeTo = wbuffer() + index;
> -     unsigned int newlen = len() - count;
> -     setLen(newlen);
> -     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
> -     wbuffer()[newlen] = 0;
> - }
> - 
> - void String::toLowerCase(void) {
> -     if (!buffer())
> -         return;
> -     for (char *p = wbuffer(); *p; p++) {
> -         *p = tolower(*p);
> -     }
> - }
> - 
> - void String::toUpperCase(void) {
> -     if (!buffer())
> -         return;
> -     for (char *p = wbuffer(); *p; p++) {
> -         *p = toupper(*p);
> -     }
> - }
> - 
> - void String::trim(void) {
> -     if (!buffer() || len() == 0)
> -         return;
> -     char *begin = wbuffer();
> -     while (isspace(*begin))
> -         begin++;
> -     char *end = wbuffer() + len() - 1;
> -     while (isspace(*end) && end >= begin)
> -         end--;
> -     unsigned int newlen = end + 1 - begin;
> -     setLen(newlen);
> -     if (begin > buffer())
> -         memmove_P(wbuffer(), begin, newlen);
> -     wbuffer()[newlen] = 0;
> - }
> - 
> - // /*********************************************/
> - // /*  Parsing / Conversion                     */
> - // /*********************************************/
> - 
> - long String::toInt(void) const {
> -     if (buffer())
> -         return atol(buffer());
> -     return 0;
> - }
> - 
> - float String::toFloat(void) const {
> -     if (buffer())
> -         return atof(buffer());
> -     return 0;
> - }
> - 
> - double String::toDouble(void) const
> - {
> -     if (buffer())
> -         return atof(buffer());
> -     return 0.0;
> - }
> - 
> - // global empty string to allow returning const String& with nothing
> - 
> - const String emptyString;
> --- 2 -----
> + #include "WString/WStringEX.cpp"
> *** /dev/null
> --- /dev/null
> ***************
> *** 0
> --- 22,23 -----
> + #pragma once
> + 
> ***************
> *** 0
> --- 28,30 -----
> + #ifdef _MSC_VER
> + #include <misc_string.h>
> + #else
> ***************
> *** 0
> --- 35,36 -----
> + #include "KFCBaseLibrary/include/misc_string.h"
> + #endif
> ***************
> *** 31,32
> - // An inherited class for holding the result of a concatenation.  These
> - // result objects are assumed to be writable by subsequent concatenations.
> --- 38,39 -----
> +  // An inherited class for holding the result of a concatenation.  These
> +  // result objects are assumed to be writable by subsequent concatenations.
> ***************
> *** 0
> --- 45 -----
> + #ifndef FPSTR
> ***************
> *** 0
> --- 47,48 -----
> + #endif
> + #ifndef F
> ***************
> *** 0
> --- 50 -----
> + #endif
> ***************
> *** 43,97
> -         // use a function pointer to allow for "if (s)" without the
> -         // complications of an operator bool(). for more information, see:
> -         // http://www.artima.com/cppsource/safebool.html
> -         typedef void (String::*StringIfHelperType)() const;
> -         void StringIfHelper() const {
> -         }
> - 
> -     public:
> -         // constructors
> -         // creates a copy of the initial value.
> -         // if the initial value is null or invalid, or if memory allocation
> -         // fails, the string will be marked as invalid (i.e. "if (s)" will
> -         // be false).
> -         String(const char *cstr = nullptr);
> -         String(const String &str);
> -         String(const __FlashStringHelper *str);
> - #ifdef __GXX_EXPERIMENTAL_CXX0X__
> -         String(String &&rval);
> -         String(StringSumHelper &&rval);
> - #endif
> -         explicit String(char c);
> -         explicit String(unsigned char, unsigned char base = 10);
> -         explicit String(int, unsigned char base = 10);
> -         explicit String(unsigned int, unsigned char base = 10);
> -         explicit String(long, unsigned char base = 10);
> -         explicit String(unsigned long, unsigned char base = 10);
> -         explicit String(float, unsigned char decimalPlaces = 2);
> -         explicit String(double, unsigned char decimalPlaces = 2);
> -         ~String(void);
> - 
> -         // memory management
> -         // return true on success, false on failure (in which case, the string
> -         // is left unchanged).  reserve(0), if successful, will validate an
> -         // invalid string (i.e., "if (s)" will be true afterwards)
> -         unsigned char reserve(unsigned int size);
> -         inline unsigned int length(void) const {
> -             if(buffer()) {
> -                 return len();
> -             } else {
> -                 return 0;
> -             }
> -         }
> -         inline void clear(void) {
> -             setLen(0);
> -         }
> -         inline bool isEmpty(void) const {
> -             return length() == 0;
> -         }
> - 
> -         // creates a copy of the assigned value.  if the value is null or
> -         // invalid, or if the memory allocation fails, the string will be
> -         // marked as invalid ("if (s)" will be false).
> -         String & operator =(const String &rhs);
> -         String & operator =(const char *cstr);
> -         String & operator = (const __FlashStringHelper *str);
> --- 54,69 -----
> +     // use a function pointer to allow for "if (s)" without the
> +     // complications of an operator bool(). for more information, see:
> +     // http://www.artima.com/cppsource/safebool.html
> +     typedef void (String:: *StringIfHelperType)() const;
> +     void StringIfHelper() const {
> +     }
> + 
> + public:
> +     // constructors
> +     // creates a copy of the initial value.
> +     // if the initial value is null or invalid, or if memory allocation
> +     // fails, the string will be marked as invalid (i.e. "if (s)" will
> +     // be false).
> +     String(const char *cstr = nullptr);
> +     String(const String &str);
> +     String(const __FlashStringHelper *str);
> ***************
> *** 99,100
> -         String & operator =(String &&rval);
> -         String & operator =(StringSumHelper &&rval);
> --- 71,72 -----
> +     String(String &&rval);
> +     String(StringSumHelper &&rval);
> ***************
> *** 0
> --- 74,82 -----
> +     explicit String(char c);
> +     explicit String(unsigned char, unsigned char base = 10);
> +     explicit String(int, unsigned char base = 10);
> +     explicit String(unsigned int, unsigned char base = 10);
> +     explicit String(long, unsigned char base = 10);
> +     explicit String(unsigned long, unsigned char base = 10);
> +     explicit String(float, unsigned char decimalPlaces = 2);
> +     explicit String(double, unsigned char decimalPlaces = 2);
> +     ~String(void);
> ***************
> *** 103
> -         // concatenate (works w/ built-in types)
> --- 84,102 -----
> +     // memory management
> +     // return true on success, false on failure (in which case, the string
> +     // is left unchanged).  reserve(0), if successful, will validate an
> +     // invalid string (i.e., "if (s)" will be true afterwards)
> +     unsigned char reserve(unsigned int size);
> +     inline unsigned int length(void) const {
> +         if (buffer()) {
> +             return len();
> +         }
> +         else {
> +             return 0;
> +         }
> +     }
> +     inline void clear(void) {
> +         setLen(0);
> +     }
> +     inline bool isEmpty(void) const {
> +         return length() == 0;
> +     }
> ***************
> *** 105,318
> -         // returns true on success, false on failure (in which case, the string
> -         // is left unchanged).  if the argument is null or invalid, the
> -         // concatenation is considered unsuccessful.
> -         unsigned char concat(const String &str);
> -         unsigned char concat(const char *cstr);
> -         unsigned char concat(char c);
> -         unsigned char concat(unsigned char c);
> -         unsigned char concat(int num);
> -         unsigned char concat(unsigned int num);
> -         unsigned char concat(long num);
> -         unsigned char concat(unsigned long num);
> -         unsigned char concat(float num);
> -         unsigned char concat(double num);
> -         unsigned char concat(const __FlashStringHelper * str);
> -         unsigned char concat(const char *cstr, unsigned int length);
> - 
> -         // if there's not enough memory for the concatenated value, the string
> -         // will be left unchanged (but this isn't signalled in any way)
> -         String & operator +=(const String &rhs) {
> -             concat(rhs);
> -             return (*this);
> -         }
> -         String & operator +=(const char *cstr) {
> -             concat(cstr);
> -             return (*this);
> -         }
> -         String & operator +=(char c) {
> -             concat(c);
> -             return (*this);
> -         }
> -         String & operator +=(unsigned char num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(int num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(unsigned int num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(long num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(unsigned long num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(float num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator +=(double num) {
> -             concat(num);
> -             return (*this);
> -         }
> -         String & operator += (const __FlashStringHelper *str){
> -             concat(str);
> -             return (*this);
> -         }
> - 
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, const String &rhs);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, const char *cstr);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, char c);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned char num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, int num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned int num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, long num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, unsigned long num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, float num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, double num);
> -         friend StringSumHelper & operator +(const StringSumHelper &lhs, const __FlashStringHelper *rhs);
> - 
> -         // comparison (only works w/ Strings and "strings")
> -         operator StringIfHelperType() const {
> -             return buffer() ? &String::StringIfHelper : 0;
> -         }
> -         int compareTo(const String &s) const;
> -         unsigned char equals(const String &s) const;
> -         unsigned char equals(const char *cstr) const;
> -         unsigned char operator ==(const String &rhs) const {
> -             return equals(rhs);
> -         }
> -         unsigned char operator ==(const char *cstr) const {
> -             return equals(cstr);
> -         }
> -         unsigned char operator !=(const String &rhs) const {
> -             return !equals(rhs);
> -         }
> -         unsigned char operator !=(const char *cstr) const {
> -             return !equals(cstr);
> -         }
> -         unsigned char operator <(const String &rhs) const;
> -         unsigned char operator >(const String &rhs) const;
> -         unsigned char operator <=(const String &rhs) const;
> -         unsigned char operator >=(const String &rhs) const;
> -         unsigned char equalsIgnoreCase(const String &s) const;
> -         unsigned char equalsConstantTime(const String &s) const;
> -         unsigned char startsWith(const String &prefix) const;
> -         unsigned char startsWith(const char * prefix) const {
> -             return this->startsWith(String(prefix));
> -         }
> -         unsigned char startsWith(const __FlashStringHelper * prefix) const {
> -             return this->startsWith(String(prefix));
> -         }
> -         unsigned char startsWith(const String &prefix, unsigned int offset) const;
> -         unsigned char endsWith(const String &suffix) const;
> -         unsigned char endsWith(const char * suffix) const {
> -             return this->endsWith(String(suffix));
> -         }
> -         unsigned char endsWith(const __FlashStringHelper * suffix) const {
> -             return this->endsWith(String(suffix));
> -         }
> - 
> -         // character access
> -         char charAt(unsigned int index) const;
> -         void setCharAt(unsigned int index, char c);
> -         char operator [](unsigned int index) const;
> -         char& operator [](unsigned int index);
> -         void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
> -         void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
> -             getBytes((unsigned char *) buf, bufsize, index);
> -         }
> -         const char* c_str() const { return buffer(); }
> -         char* begin() { return wbuffer(); }
> -         char* end() { return wbuffer() + length(); }
> -         const char* begin() const { return c_str(); }
> -         const char* end() const { return c_str() + length(); }
> - 
> -         // search
> -         int indexOf(char ch) const;
> -         int indexOf(char ch, unsigned int fromIndex) const;
> -         int indexOf(const String &str) const;
> -         int indexOf(const String &str, unsigned int fromIndex) const;
> -         int lastIndexOf(char ch) const;
> -         int lastIndexOf(char ch, unsigned int fromIndex) const;
> -         int lastIndexOf(const String &str) const;
> -         int lastIndexOf(const String &str, unsigned int fromIndex) const;
> -         String substring(unsigned int beginIndex) const {
> -             return substring(beginIndex, len());
> -         }
> -         ;
> -         String substring(unsigned int beginIndex, unsigned int endIndex) const;
> - 
> -         // modification
> -         void replace(char find, char replace);
> -         void replace(const String& find, const String& replace);
> -         void replace(const char * find, const String& replace) {
> -             this->replace(String(find), replace);
> -         }
> -         void replace(const __FlashStringHelper * find, const String& replace) {
> -             this->replace(String(find), replace);
> -         }
> -         void replace(const char * find, const char * replace) {
> -             this->replace(String(find), String(replace));
> -         }
> -         void replace(const __FlashStringHelper * find, const char * replace) {
> -             this->replace(String(find), String(replace));
> -         }
> -         void replace(const __FlashStringHelper * find, const __FlashStringHelper * replace) {
> -             this->replace(String(find), String(replace));
> -         }
> -         void remove(unsigned int index);
> -         void remove(unsigned int index, unsigned int count);
> -         void toLowerCase(void);
> -         void toUpperCase(void);
> -         void trim(void);
> - 
> -         // parsing/conversion
> -         long toInt(void) const;
> -         float toFloat(void) const;
> - 	double toDouble(void) const;
> - 
> -     protected:
> -         // Contains the string info when we're not in SSO mode
> -         struct _ptr { 
> -             char *   buff;
> -             uint16_t cap;
> -             uint16_t len;
> -         };
> -         // This allows strings up up to 11 (10 + \0 termination) without any extra space.
> -         enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
> -         struct _sso {
> -             char     buff[SSOSIZE];
> -             unsigned char len   : 7; // Ensure only one byte is allocated by GCC for the bitfields
> -             unsigned char isSSO : 1;
> -         } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
> -         enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
> -         union {
> -             struct _ptr ptr;
> -             struct _sso sso;
> -         };
> -         // Accessor functions
> -         inline bool isSSO() const { return sso.isSSO; }
> -         inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
> -         inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
> -         inline void setSSO(bool set) { sso.isSSO = set; }
> -         inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
> -         inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
> - 	inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
> -         // Buffer accessor functions
> -         inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
> -         inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> - 
> -     protected:
> -         void init(void);
> -         void invalidate(void);
> -         unsigned char changeBuffer(unsigned int maxStrLen);
> - 
> -         // copy and move
> -         String & copy(const char *cstr, unsigned int length);
> -         String & copy(const __FlashStringHelper *pstr, unsigned int length);
> --- 104,109 -----
> +     // creates a copy of the assigned value.  if the value is null or
> +     // invalid, or if the memory allocation fails, the string will be
> +     // marked as invalid ("if (s)" will be false).
> +     String &operator =(const String &rhs);
> +     String &operator =(const char *cstr);
> +     String &operator = (const __FlashStringHelper *str);
> ***************
> *** 320
> -         void move(String &rhs);
> --- 111,112 -----
> +     String &operator =(String &&rval);
> +     String &operator =(StringSumHelper &&rval);
> ***************
> *** 322
> - };
> --- 0 -----
> ***************
> *** 324,327
> - class StringSumHelper: public String {
> -     public:
> -         StringSumHelper(const String &s) :
> -                 String(s) {
> --- 115,551 -----
> +     // concatenate (works w/ built-in types)
> + 
> +     // returns true on success, false on failure (in which case, the string
> +     // is left unchanged).  if the argument is null or invalid, the
> +     // concatenation is considered unsuccessful.
> +     unsigned char concat(const String &str);
> +     unsigned char concat(const char *cstr);
> +     unsigned char concat(char c);
> +     unsigned char concat(unsigned char c);
> +     unsigned char concat(int num);
> +     unsigned char concat(unsigned int num);
> +     unsigned char concat(long num);
> +     unsigned char concat(unsigned long num);
> +     unsigned char concat(float num);
> +     unsigned char concat(double num);
> +     unsigned char concat(const __FlashStringHelper *str);
> +     unsigned char concat(const char *cstr, unsigned int length);
> + 
> +     // if there's not enough memory for the concatenated value, the string
> +     // will be left unchanged (but this isn't signalled in any way)
> +     String &operator +=(const String &rhs) {
> +         concat(rhs);
> +         return (*this);
> +     }
> +     String &operator +=(const char *cstr) {
> +         concat(cstr);
> +         return (*this);
> +     }
> +     String &operator +=(char c) {
> +         concat(c);
> +         return (*this);
> +     }
> +     String &operator +=(unsigned char num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(int num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(unsigned int num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(long num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(unsigned long num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(float num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator +=(double num) {
> +         concat(num);
> +         return (*this);
> +     }
> +     String &operator += (const __FlashStringHelper *str) {
> +         concat(str);
> +         return (*this);
> +     }
> + 
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, char c);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, int num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, long num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, float num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, double num);
> +     friend StringSumHelper &operator +(const StringSumHelper &lhs, const __FlashStringHelper *rhs);
> + 
> +     // comparison (only works w/ Strings and "strings")
> +     operator StringIfHelperType() const {
> +         return buffer() ? &String::StringIfHelper : 0;
> +     }
> +     unsigned char operator ==(char ch) const {
> +         return equals(ch);
> +     }
> +     unsigned char operator ==(const String &rhs) const {
> +         return equals(rhs);
> +     }
> +     unsigned char operator ==(const char *cstr) const {
> +         return equals(cstr);
> +     }
> +     unsigned char operator ==(const __FlashStringHelper *fstr) const {
> +         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) == 0;
> +     }
> +     unsigned char operator !=(char ch) const {
> +         return !equals(ch);
> +     }
> +     unsigned char operator !=(const String &rhs) const {
> +         return !equals(rhs);
> +     }
> +     unsigned char operator !=(const char *cstr) const {
> +         return !equals(cstr);
> +     }
> +     unsigned char operator !=(const __FlashStringHelper *fstr) const {
> +         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) != 0;
> +     }
> + 
> +     unsigned char operator <(const String &rhs) const;
> +     unsigned char operator >(const String &rhs) const;
> +     unsigned char operator <=(const String &rhs) const;
> +     unsigned char operator >=(const String &rhs) const;
> + 
> +     int compareTo(const String &s) const;
> + 
> +     //
> +     // equals()
> +     //
> +     // changed behaviour:
> +     // any nullptr argument will return false -> String.equals(nullptr) does not return true if String is empty
> + 
> +     // the terminating NUL byte is not considered part of the string
> +     // String.equals('\0') always returns false, even if String is empty
> +     // use length() == 0 to determine if a string is empty
> +     unsigned char equals(char ch) const {
> +         if (length() != 1 || !ch) {
> +             return false;
> +         }
> +         return buffer()[0] == ch;
> +     }
> + 
> +     unsigned char equals(const String &str) const {
> +         if (this == &str) {
> +             return true;
> +         }
> +         if (length() != str.length()) {
> +             return false;
> +         }
> +         return strcmp(buffer(), str.buffer()) == 0;
> +     }
> + 
> +     unsigned char equals(const char *cStr) const {
> +         if (!cStr) {
> +             return false;
> +         }
> +         if (length() == 0) {
> +             return (*cStr == 0);
> +         }
> +         return strcmp(buffer(), cStr) == 0;
> +     }
> + 
> +     unsigned char equals(const __FlashStringHelper *fStr) const {
> +         if (!fStr) {
> +             return false;
> +         }
> +         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fStr)) == 0;
> +     }
> + 
> +     // return true if String matches the end of str1
> +     // basically a.endsWith(b) = b.endEquals(a)
> +     //
> +     // String("123").endEquals("test123") == true
> +     // String("").endEquals(nullptr) == false
> +     bool endEquals(const char *str1) const {
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcmp(str1, buffer()) == 0;
> +         }
> +         return strcmp(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     bool endEquals(const __FlashStringHelper *fStr) const {
> +         PGM_P str1 = reinterpret_cast<PGM_P>(fStr);
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen_P(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcmp_P_P(str1, buffer()) == 0;
> +         }
> +         return strcmp_P_P(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     // we can use endsWith in this case
> +     inline bool endEquals(const String &str) const {
> +         return str.endsWith(*this);
> +     }
> + 
> +     // return true if String matches the end of str1
> +     // basically a.endsWith(b) = b.endEquals(a)
> +     //
> +     // String("abc").endEqualsIgnoreCase("TESTABC") == true
> +     // String("").endEqualsIgnoreCase(nullptr) == false
> +     bool endEqualsIgnoreCase(const char *str1) const {
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcasecmp(str1, buffer()) == 0;
> +         }
> +         return strcasecmp(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     bool endEqualsIgnoreCase(const __FlashStringHelper *fStr) const {
> +         PGM_P str1 = reinterpret_cast<PGM_P>(fStr);
> +         size_t len1;
> +         size_t len2;
> +         if (!str1 || (len2 = length()) > (len1 = strlen_P(str1))) {
> +             return false;
> +         }
> +         if (len2 == len1) {
> +             return strcasecmp_P_P(str1, buffer()) == 0;
> +         }
> +         return strcasecmp_P_P(str1 + len1 - len2, buffer()) == 0;
> +     }
> + 
> +     // we can just use endsWithIgnoreCase in this case
> +     inline bool endEqualsIgnoreCase(const String &str) const {
> +         return str.endsWithIgnoreCase(*this);
> +     }
> + 
> +     //
> +     // equals() with offset
> +     //
> + 
> +     unsigned char equals(const String &str, size_t offset) const {
> +         size_t len1;
> +         size_t len2;
> +         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
> +             return false;
> +         }
> +         return strcmp(buffer() + offset, str.c_str()) == 0;
> +     }
> + 
> +     unsigned char equals(const char *cStr, size_t offset) const {
> +         if (!cStr || !*cStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcmp(buffer() + offset, cStr) == 0;
> +     }
> + 
> +     unsigned char equals(const __FlashStringHelper *fStr, size_t offset) const {
> +         if (!fStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
> +     }
> + 
> +     //
> +     // equalsIgnoreCase() with offset
> +     //
> + 
> +     unsigned char equalsIgnoreCase(const String &str, size_t offset = 0) const {
> +         if (offset == 0 && this == &str) {
> +             return true;
> +         }
> +         size_t len1;
> +         size_t len2;
> +         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
> +             return false;
> +         }
> +         return strcasecmp(buffer() + offset, str.c_str()) == 0;
> +     }
> + 
> +     unsigned char equalsIgnoreCase(const char *cStr, size_t offset = 0) const {
> +         if (!cStr || !*cStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcasecmp(buffer() + offset, cStr) == 0;
> +     }
> + 
> +     unsigned char equalsIgnoreCase(const __FlashStringHelper *fStr, size_t offset = 0) const {
> +         if (!fStr || offset >= length()) {
> +             return false;
> +         }
> +         return strcasecmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
> +     }
> + 
> +     //
> +     // equalsConstantTime
> +     //
> + 
> +     unsigned char equalsConstantTime(const String &s) const;
> + 
> +     //
> +     // _startsWith
> +     //
> + 
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWith(const char *prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncmp(c_str() + offset, prefix, prefixLen);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWith_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncmp_P(c_str() + offset, prefix, prefixLen);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWithIgnoreCase(const char *prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp(c_str() + offset, prefix, prefixLen);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _startsWithIgnoreCase_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
> +         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp_P(c_str() + offset, prefix, prefixLen);
> +     }
> + 
> +     //
> +     // startsWith(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
> +     //
> + 
> +     unsigned char startsWith(char ch) const {
> +         return (length() != 0) && (buffer()[0] == ch);
> +     }
> +     unsigned char startsWith(char ch, size_t offset) const {
> +         return (length() > offset) && (buffer()[offset] == ch);
> +     }
> +     unsigned char startsWith(const char *prefix, size_t offset = 0) const {
> +         return prefix && _startsWith(prefix, strlen(prefix), offset);
> +     }
> +     unsigned char startsWith(const String &prefix, size_t offset = 0) const {
> +         size_t len;
> +         return ((len = prefix.length())) != 0 && _startsWith(prefix.buffer(), len, offset);
> +     }
> +     unsigned char startsWith(const __FlashStringHelper *prefix, size_t offset = 0) const {
> +         return prefix && _startsWith_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
> +     }
> + 
> +     //
> +     // startsWithIgnoreCase(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
> +     //
> + 
> +     unsigned char startsWithIgnoreCase(char ch, size_t offset = 0) const {
> +         return (length() > offset) && (tolower(buffer()[offset]) == tolower(ch));
> +     }
> +     unsigned char startsWithIgnoreCase(const char *prefix, size_t offset = 0) const {
> +         return prefix && _startsWithIgnoreCase(prefix, strlen(prefix), offset);
> +     }
> +     unsigned char startsWithIgnoreCase(const String &prefix, size_t offset = 0) const {
> +         size_t len;
> +         return ((len = prefix.length())) != 0 && _startsWithIgnoreCase(prefix.buffer(), len, offset);
> +     }
> +     unsigned char startsWithIgnoreCase(const __FlashStringHelper *prefix, size_t offset = 0) const {
> +         return prefix && _startsWithIgnoreCase_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
> +     }
> + 
> +     //
> +     // _endsWith
> +     //
> + 
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWith(const char *suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcmp(buffer() + len - suffixLen, suffix);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWith_P(PGM_P suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcmp_P(buffer() + len - suffixLen, suffix);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWithIgnoreCase(const char *suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp(buffer() + len - suffixLen, suffix);
> +     }
> +     inline __attribute__((__always_inline__))
> +         unsigned char _endsWithIgnoreCase_P(PGM_P suffix, size_t suffixLen) const {
> +         size_t len;
> +         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp_P(buffer() + len - suffixLen, suffix);
> +     }
> + 
> +     //
> +     // endsWith
> +     //
> + 
> +     unsigned char endsWith(char ch) const {
> +         auto len = length();
> +         return (len != 0) && (buffer()[len - 1] == ch);
> +     }
> +     unsigned char endsWith(const String &suffix) const {
> +         return _endsWith(suffix.buffer(), suffix.length());
> +     }
> +     unsigned char endsWith(const char *suffix) const {
> +         return suffix && _endsWith(suffix, strlen(suffix));
> +     }
> +     unsigned char endsWith(const __FlashStringHelper *suffix) const {
> +         return suffix && _endsWith_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
> +     }
> + 
> +     //
> +     // endsWithIgnoreCase
> +     //
> + 
> +     unsigned char endsWithIgnoreCase(char ch) const {
> +         auto len = length();
> +         return (len != 0) && (tolower(buffer()[len - 1]) == tolower(ch));
> +     }
> +     unsigned char endsWithIgnoreCase(const String &suffix) const {
> +         return _endsWithIgnoreCase(suffix.buffer(), suffix.length());
> +     }
> +     unsigned char endsWithIgnoreCase(const char *suffix) const {
> +         return suffix && _endsWithIgnoreCase(suffix, strlen(suffix));
> +     }
> +     unsigned char endsWithIgnoreCase(const __FlashStringHelper *suffix) const {
> +         return suffix && _endsWithIgnoreCase_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
> +     }
> + 
> +     // character access
> +     char charAt(unsigned int index) const;
> +     void setCharAt(unsigned int index, char c);
> +     char operator [](unsigned int index) const;
> +     char &operator [](unsigned int index);
> +     void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
> +     void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
> +         getBytes((unsigned char *)buf, bufsize, index);
> +     }
> +     const char *c_str() const { return buffer(); }
> +     char *begin() { return wbuffer(); }
> +     char *end() { return wbuffer() + length(); }
> +     const char *begin() const { return c_str(); }
> +     const char *end() const { return c_str() + length(); }
> + 
> + protected:
> +     // findLength is optional, provide only if available
> +     int _indexOf(const char *find, size_t fromIndex, size_t findLength = ~0) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
> +             return -1;
> +         }
> +         auto ptr = buffer();
> +         auto idxPtr = strstr(ptr + fromIndex, find);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 329,330
> -         StringSumHelper(const char *p) :
> -                 String(p) {
> --- 553,565 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _indexOfIgnoreCase(const char *find, size_t fromIndex, size_t findLength = ~0) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
> +             return -1;
> +         }
> +         auto ptr = wbuffer();
> +         auto idxPtr = stristr(ptr + fromIndex, find);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 332,333
> -         StringSumHelper(char c) :
> -                 String(c) {
> --- 567,579 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _indexOf_P(PGM_P find, size_t fromIndex, size_t findLength = ~0) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
> +             return -1;
> +         }
> +         auto ptr = buffer();
> +         auto idxPtr = strstr_P(ptr + fromIndex, find);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 335,336
> -         StringSumHelper(unsigned char num) :
> -                 String(num) {
> --- 581,593 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _indexOfIgnoreCase_P(PGM_P find, size_t fromIndex, size_t findLength) const
> +     {
> +         size_t len;
> +         if (!find || !findLength || ((len = length()) == 0) || (fromIndex + findLength >= len)) {
> +             return -1;
> +         }
> +         auto ptr = buffer();
> +         auto idxPtr = stristr_P(ptr + fromIndex, find, findLength);
> +         if (!idxPtr) {
> +             return -1;
> ***************
> *** 338,339
> -         StringSumHelper(int num) :
> -                 String(num) {
> --- 595,602 -----
> +         return idxPtr - ptr;
> +     }
> + 
> +     int _lastIndexOf(char find) const
> +     {
> +         auto ptr = strrchr(buffer(), find);
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 341,342
> -         StringSumHelper(unsigned int num) :
> -                 String(num) {
> --- 604,611 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf_P(char find) const
> +     {
> +         auto ptr = strrchr_P(buffer(), find);
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 344,345
> -         StringSumHelper(long num) :
> -                 String(num) {
> --- 613,630 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf(char find, size_t fromIndex) const
> +     {
> +         if (!find) {
> +             return -1;
> +         }
> +         auto len = length();
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex > len || fromIndex < 1) {
> +             return -1;
> +         }
> +         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 347,348
> -         StringSumHelper(unsigned long num) :
> -                 String(num) {
> --- 632,649 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf_P(char find, size_t fromIndex) const
> +     {
> +         if (!find) {
> +             return -1;
> +         }
> +         auto len = length();
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex > len || fromIndex < 1) {
> +             return -1;
> +         }
> +         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 350,351
> -         StringSumHelper(float num) :
> -                 String(num) {
> --- 651,668 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf_P(PGM_P find, size_t fromIndex, size_t findLen) const
> +     {
> +         size_t len;
> +         if (!find || !(len = length())) {
> +             return -1;
> +         }
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex < findLen || fromIndex > len) {
> +             return -1;
> +         }
> +         auto ptr = __strrstr_P(wbuffer(), fromIndex + findLen, find, findLen);
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 353,354
> -         StringSumHelper(double num) :
> -                 String(num) {
> --- 670,687 -----
> +         return ptr - buffer();
> +     }
> + 
> +     int _lastIndexOf(const char *find, size_t fromIndex, size_t findLen) const
> +     {
> +         size_t len;
> +         if (!find || !(len = length())) {
> +             return -1;
> +         }
> +         if (fromIndex == ~0U) {
> +             fromIndex = len;
> +         }
> +         else if (fromIndex < findLen || fromIndex > len) {
> +             return -1;
> +         }
> +         auto ptr = __strrstr(wbuffer(), fromIndex + findLen, find, findLen);
> +         if (!ptr) {
> +             return -1;
> ***************
> *** 0
> --- 689,1054 -----
> +         return ptr - buffer();
> +     }
> + 
> + 
> + public:
> +     // search
> +     int indexOf(char ch, unsigned int fromIndex) const;
> +     int indexOf(const String &str) const;
> +     int indexOf(const String &str, unsigned int fromIndex) const;
> + 
> +     int indexOf(char c) const {
> +         return indexOf(c, 0);
> +     }
> + 
> +     int indexOf(const char *str, unsigned int fromIndex = 0) const {
> +         return _indexOf(str, fromIndex, ~0U);
> +     }
> +     int indexOf(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
> +         return _indexOf_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
> +     }
> + 
> + 
> +     int indexOfIgnoreCase(char c) const {
> +         return indexOfIgnoreCase(c, 0);
> +     }
> + 
> +     int indexOfIgnoreCase(char ch, unsigned int fromIndex) const {
> +         if (fromIndex >= len())
> +             return -1;
> +         const char *temp = strichr(buffer() + fromIndex, ch);
> +         if (temp == NULL)
> +             return -1;
> +         return temp - buffer();
> +     }
> + 
> + 
> +     int indexOfIgnoreCase(const char *str, unsigned int fromIndex = 0) const {
> +         return _indexOfIgnoreCase(str, fromIndex, ~0U);
> +     }
> +     int indexOfIgnoreCase(const String &str, unsigned int fromIndex = 0) const {
> +         return _indexOfIgnoreCase(str.c_str(), fromIndex, str.length());
> +     }
> +     int indexOfIgnoreCase(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
> +         return _indexOfIgnoreCase_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
> +     }
> + 
> + 
> +     int lastIndexOf(char ch) const {
> +         return _lastIndexOf(ch);
> +     }
> +     int lastIndexOf(char ch, unsigned int fromIndex) const {
> +         return _lastIndexOf(ch, fromIndex);
> +     }
> +     int lastIndexOf(const String &str) const {
> +         auto strLen = str.length();
> +         return _lastIndexOf(str.buffer(), length() - strLen, strLen);
> +     }
> +     int lastIndexOf(const String &str, unsigned int fromIndex) const {
> +         auto findLength = str.length();
> +         return _lastIndexOf(str.buffer(), fromIndex - findLength, findLength);
> +     }
> +     int lastIndexOf(const __FlashStringHelper *str, unsigned int fromIndex) const {
> +         auto findLength = strlen_P(reinterpret_cast<PGM_P>(str));
> +         return _lastIndexOf_P(reinterpret_cast<PGM_P>(str), fromIndex - findLength, findLength);
> +     }
> + 
> +     String substring(unsigned int beginIndex) const {
> +         return substring(beginIndex, len());
> +     }
> +     String substring(unsigned int beginIndex, unsigned int endIndex) const;
> + 
> +     // PROGMEM safe
> +     // returns false on failure
> +     bool insert(size_t pos, PGM_P insert, size_t insertLen);
> + 
> +     inline bool insert(size_t pos, PGM_P str) {
> +         return insert(pos, str, strlen_P(str));
> +     }
> +     inline bool insert(size_t pos, const __FlashStringHelper *fstr) {
> +         return insert(pos, reinterpret_cast<PGM_P>(fstr), strlen_P(reinterpret_cast<PGM_P>(fstr)));
> +     }
> +     inline bool insert(size_t pos, const String &str) {
> +         return insert(pos, str.buffer(), str.length());
> +     }
> + 
> +     // modification
> +     bool replace(char find, char replace);
> + 
> + protected:
> +     bool _replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen);
> + 
> + public:
> +     inline __attribute__((__always_inline__))
> +         bool replace(const char *find, const char *replace) {
> +         return _replace(find, strlen(find), replace, strlen(replace));
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const char *find, const __FlashStringHelper *replace) {
> +         return _replace(find, strlen(find), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const char *find, const String &replace) {
> +         return _replace(find, strlen(find), replace.buffer(), replace.length());
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const String &find, const String &replace) {
> +         return _replace(find.buffer(), find.length(), replace.buffer(), replace.length());
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const String &find, const char *replace) {
> +         return _replace(find.buffer(), find.length(), replace, strlen(replace));
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const String &find, const __FlashStringHelper *replace) {
> +         return _replace(find.buffer(), find.length(), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const __FlashStringHelper *find, const String &replace) {
> +         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace.buffer(), replace.length());
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const __FlashStringHelper *find, const char *replace) {
> +         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace, strlen(replace));
> +     }
> +     inline __attribute__((__always_inline__))
> +         bool replace(const __FlashStringHelper *find, const __FlashStringHelper *replace) {
> +         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
> +     }
> + 
> +     void remove(unsigned int index);
> +     void remove(unsigned int index, unsigned int count);
> + 
> +     String &toLowerCase(void);
> +     String &toUpperCase(void);
> + 
> + protected:
> +     enum class TrimType : uint8_t {
> +         LEFT = 0x01,
> +         RIGHT = 0x02,
> +         BOTH = LEFT | RIGHT
> +     };
> + 
> +     String &_trim(TrimType type);
> +     inline String &_trim(TrimType type, char character) {
> +         char buf[2] = { character, 0 };
> +         return _trim(type, buf, 1);
> +     }
> +     String &_trim(TrimType type, PGM_P characters, size_t charLen);
> +     inline __attribute__((__always_inline__))
> +         String &_trim(TrimType type, const char *characters) {
> +         return _trim(type, characters, strlen(characters));
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &_trim(TrimType type, const __FlashStringHelper *characters) {
> +         return _trim(type, reinterpret_cast<PGM_P>(characters), strlen_P(reinterpret_cast<PGM_P>(characters)));
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &_trim(TrimType type, const String &characters) {
> +         return _trim(type, characters.c_str(), characters.length());
> +     }
> + 
> + public:
> +     inline __attribute__((__always_inline__))
> +         String &trim() {
> +         return _trim(TrimType::BOTH);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &rtrim() {
> +         return _trim(TrimType::RIGHT);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &ltrim() {
> +         return _trim(TrimType::LEFT);
> +     }
> + 
> +     inline __attribute__((__always_inline__))
> +         String &trim(char character) {
> +         return _trim(TrimType::BOTH, character);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &rtrim(char character) {
> +         return _trim(TrimType::RIGHT, character);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &ltrim(char character) {
> +         return _trim(TrimType::LEFT, character);
> +     }
> + 
> +     inline __attribute__((__always_inline__))
> +         String &trim(const char *characters) {
> +         return _trim(TrimType::BOTH, characters);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &trim(const String &characters) {
> +         return _trim(TrimType::BOTH, characters);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &trim(const __FlashStringHelper *characters) {
> +         return _trim(TrimType::BOTH, characters);
> +     }
> + 
> +     inline __attribute__((__always_inline__))
> +         String &rtrim(const char *characters) {
> +         return _trim(TrimType::RIGHT, characters);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &rtrim(const String &characters) {
> +         return _trim(TrimType::RIGHT, characters);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &rtrim(const __FlashStringHelper *characters) {
> +         return _trim(TrimType::RIGHT, characters);
> +     }
> + 
> +     inline __attribute__((__always_inline__))
> +         String &ltrim(const char *characters) {
> +         return _trim(TrimType::LEFT, characters);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &ltrim(const String &characters) {
> +         return _trim(TrimType::LEFT, characters);
> +     }
> +     inline __attribute__((__always_inline__))
> +         String &ltrim(const __FlashStringHelper *characters) {
> +         return _trim(TrimType::LEFT, characters);
> +     }
> + 
> +     // parsing/conversion
> +     long toInt(void) const;
> +     float toFloat(void) const;
> + 
> +     inline __attribute__((__always_inline__))
> +         double toDouble(void) const {
> +         return toFloat();
> +     }
> + 
> + 
> + public:
> +     // access to SSO and internals
> + 
> +     // returns allocated memory
> +     inline size_t __getAllocSize() const {
> + #if defined(ESP8266)
> +         if (isSSO()) {
> +             return 0;
> +         }
> +         return capacity() + 1;
> + #else
> +         return (length() + 8) & ~7;
> + #endif
> +     }
> + 
> +     // returns memory usage
> +     inline size_t __getMemorySize() const {
> +         return sizeof(String) + __getAllocSize();
> +     }
> + 
> +     // get pointer to allocated memory and release ownership
> +     // capacity is the size of the allocated block
> +     // if no memory is allocated, it returns nullptr and capacity is set to 0
> +     // the string is empty afterwards
> +     inline char *__release(size_t &capacity) {
> +         if (isSSO()) {
> +             capacity = 0;
> +             return nullptr;
> +         }
> +         capacity = this->capacity() + 1;
> +         auto rPtr = ptr.buff;
> +         ptr = {};
> +         invalidate();
> +         return rPtr;
> +     }
> + 
> +     // see __release(size_t &capacity)
> +     inline char *__release() {
> +         if (isSSO()) {
> +             return nullptr;
> +         }
> +         auto rPtr = ptr.buff;
> +         ptr = {};
> +         invalidate();
> +         return rPtr;
> +     }
> + 
> + 
> + protected:
> +     // Contains the string info when we're not in SSO mode
> +     struct _ptr {
> +         char *buff;
> +         uint16_t cap;
> +         uint16_t len;
> +     };
> +     // This allows strings up up to 11 (10 + \0 termination) without any extra space.
> +     enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
> +     struct _sso {
> +         char     buff[SSOSIZE];
> +         unsigned char len : 7; // Ensure only one byte is allocated by GCC for the bitfields
> +         unsigned char isSSO : 1;
> +     } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
> +     enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
> +     union {
> +         struct _ptr ptr;
> +         struct _sso sso;
> +     };
> +     // Accessor functions
> +     inline bool isSSO() const { return sso.isSSO; }
> +     inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
> +     inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
> +     inline void setSSO(bool set) { sso.isSSO = set; }
> +     inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
> +     inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
> +     inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
> +     // Buffer accessor functions
> +     inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
> +     inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> + 
> + protected:
> +     inline void init(void) {
> +         setSSO(true);
> +         setLen(0);
> +         wbuffer()[0] = 0;
> +     }
> + 
> +     void invalidate(void);
> +     unsigned char changeBuffer(unsigned int maxStrLen);
> + 
> +     // copy and move
> +     String &copy(const char *cstr, unsigned int length);
> +     String &copy(const __FlashStringHelper *pstr, unsigned int length);
> + #ifdef __GXX_EXPERIMENTAL_CXX0X__
> +     void move(String &rhs);
> + #endif
> + };
> + 
> + class StringSumHelper : public String {
> + public:
> +     StringSumHelper(const String &s) :
> +         String(s) {
> +     }
> +     StringSumHelper(const char *p) :
> +         String(p) {
> +     }
> +     StringSumHelper(char c) :
> +         String(c) {
> +     }
> +     StringSumHelper(unsigned char num) :
> +         String(num) {
> +     }
> +     StringSumHelper(int num) :
> +         String(num) {
> +     }
> +     StringSumHelper(unsigned int num) :
> +         String(num) {
> +     }
> +     StringSumHelper(long num) :
> +         String(num) {
> +     }
> +     StringSumHelper(unsigned long num) :
> +         String(num) {
> +     }
> +     StringSumHelper(float num) :
> +         String(num) {
> +     }
> +     StringSumHelper(double num) :
> +         String(num) {
> +     }
> *** /dev/null
> --- /dev/null
> ***************
> *** 0
> --- 24,27 -----
> + namespace WebServer{
> +     class Plugin;
> + }
> + 
> ***************
> *** 0
> --- 76,77 -----
> +     friend WebServer::Plugin;
> + 
> *** /dev/null
> --- /dev/null
> ***************
> *** 0
> --- 524,526 -----
> + #ifdef HAVE_KFC_FIRMWARE_VERSION
> +     public:
> + #endif
> ***************
> *** 0
> --- 1444,1446 -----
> + #ifdef HAVE_KFC_FIRMWARE_VERSION
> +     public:
> + #endif
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/core_esp8266_postmortem.cpp ./framework-arduinoespressif8266/cores/esp8266/core_esp8266_postmortem.cpp
86c86,91
< static void ets_printf_P(const char *str, ...) {
---
> 
> // exported for using in custom_crash_callback()
> extern void ___static_ets_printf_P(const char *str, ...);
> #define ets_printf_P ___static_ets_printf_P
> 
> void ___static_ets_printf_P(const char *str, ...) {
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/Esp.cpp ./framework-arduinoespressif8266/cores/esp8266/Esp.cpp
1006c1006
< #if defined(UMM_HEAP_EXTERNAL) && !defined(UMM_HEAP_IRAM)
---
> #if defined(UMM_HE1AP_EXTERNAL) && !defined(UMM_HEAP_IRAM)
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/HardwareSerial.h ./framework-arduinoespressif8266/cores/esp8266/HardwareSerial.h
235a236,238
> #ifdef HAVE_KFC_FIRMWARE_VERSION
> extern Stream &Serial;
> #else
236a240
> #endif
238d241
< 
239a243
> 
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/heap.cpp ./framework-arduinoespressif8266/cores/esp8266/heap.cpp
362c362
<     return heap_pvPortZalloc(size,  file, line);
---
>     return heap_pvPortZalloc(size, file, line);
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/time.cpp ./framework-arduinoespressif8266/cores/esp8266/time.cpp
227a228
>     ::printf(PSTR("settimeofday tv=%lld.%06ld tz=%p\n"), tv->tv_sec, tv->tv_usec, tz);
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString/WString.cpp ./framework-arduinoespressif8266/cores/esp8266/WString/WString.cpp
0a1,2
> 
> #include "WStringEx.cpp"
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString/WStringEx.cpp ./framework-arduinoespressif8266/cores/esp8266/WString/WStringEx.cpp
0a1,861
> /*
>  WString.cpp - String library for Wiring & Arduino
>  ...mostly rewritten by Paul Stoffregen...
>  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
>  Copyright 2011, Paul Stoffregen, paul@pjrc.com
>  Modified by Ivan Grokhotkov, 2014 - esp8266 support
>  Modified by Michael C. Miller, 2015 - esp8266 progmem support
> 
>  This library is free software; you can redistribute it and/or
>  modify it under the terms of the GNU Lesser General Public
>  License as published by the Free Software Foundation; either
>  version 2.1 of the License, or (at your option) any later version.
> 
>  This library is distributed in the hope that it will be useful,
>  but WITHOUT ANY WARRANTY; without even the implied warranty of
>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
>  Lesser General Public License for more details.
> 
>  You should have received a copy of the GNU Lesser General Public
>  License along with this library; if not, write to the Free Software
>  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
>  */
> 
> #ifdef _MSC_VER
> #include <Arduino_compat.h>
> #include "cores/esp8266/WString.h"
> #include "util/stdlib_noniso.h"
> #else
> #include <Arduino.h>
> #include "WString.h"
> #include "stdlib_noniso.h"
> #endif
> 
>  /*********************************************/
>  /*  Constructors                             */
>  /*********************************************/
> 
> String::String(const char *cstr) {
>     init();
>     if (cstr)
>         copy(cstr, strlen(cstr));
> }
> 
> String::String(const String &value) {
>     init();
>     *this = value;
> }
> 
> String::String(const __FlashStringHelper *pstr) {
>     init();
>     *this = pstr; // see operator =
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String::String(String &&rval) {
>     init();
>     move(rval);
> }
> 
> String::String(StringSumHelper &&rval) {
>     init();
>     move(rval);
> }
> #endif
> 
> String::String(char c) {
>     init();
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     *this = buf;
> }
> 
> String::String(unsigned char value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned char)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(int value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(int)];
>     if (base == 10) {
>         sprintf(buf, "%d", value);
>     }
>     else {
>         itoa(value, buf, base);
>     }
>     *this = buf;
> }
> 
> String::String(unsigned int value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned int)];
>     utoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(long value, unsigned char base) {
>     init();
>     char buf[2 + 8 * sizeof(long)];
>     if (base == 10) {
>         sprintf(buf, "%ld", value);
>     }
>     else {
>         ltoa(value, buf, base);
>     }
>     *this = buf;
> }
> 
> String::String(unsigned long value, unsigned char base) {
>     init();
>     char buf[1 + 8 * sizeof(unsigned long)];
>     ultoa(value, buf, base);
>     *this = buf;
> }
> 
> String::String(float value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::String(double value, unsigned char decimalPlaces) {
>     init();
>     char buf[33];
>     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
> }
> 
> String::~String() {
>     invalidate();
> }
> 
> // /*********************************************/
> // /*  Memory Management                        */
> // /*********************************************/
> 
> void String::invalidate(void) {
>     if (!isSSO() && wbuffer())
>         free(wbuffer());
>     init();
> }
> 
> unsigned char String::reserve(unsigned int size) {
>     if (buffer() && capacity() >= size)
>         return 1;
>     if (changeBuffer(size)) {
>         if (len() == 0)
>             wbuffer()[0] = 0;
>         return 1;
>     }
>     return 0;
> }
> 
> unsigned char String::changeBuffer(unsigned int maxStrLen) {
>     // Can we use SSO here to avoid allocation?
>     if (maxStrLen < sizeof(sso.buff) - 1) {
>         if (isSSO() || !buffer()) {
>             // Already using SSO, nothing to do
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             return 1;
>         }
>         else { // if bufptr && !isSSO()
>          // Using bufptr, need to shrink into sso.buff
>             char temp[sizeof(sso.buff)];
>             memcpy(temp, buffer(), maxStrLen);
>             free(wbuffer());
>             uint16_t oldLen = len();
>             setSSO(true);
>             setLen(oldLen);
>             memcpy(wbuffer(), temp, maxStrLen);
>             return 1;
>         }
>     }
>     // Fallthrough to normal allocator
>     size_t newSize = (maxStrLen + 16) & (~0xf);
>     // Make sure we can fit newsize in the buffer
>     if (newSize > CAPACITY_MAX) {
>         return false;
>     }
>     uint16_t oldLen = len();
>     char *newbuffer = (char *)realloc(isSSO() ? nullptr : wbuffer(), newSize);
>     if (newbuffer) {
>         size_t oldSize = capacity() + 1; // include NULL.
>         if (isSSO()) {
>             // Copy the SSO buffer into allocated space
>             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
>         }
>         if (newSize > oldSize)
>         {
>             memset(newbuffer + oldSize, 0, newSize - oldSize);
>         }
>         setSSO(false);
>         setCapacity(newSize - 1);
>         setLen(oldLen); // Needed in case of SSO where len() never existed
>         setBuffer(newbuffer);
>         return 1;
>     }
>     return 0;
> }
> 
> // /*********************************************/
> // /*  Copy and Move                            */
> // /*********************************************/
> 
> String &String::copy(const char *cstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memmove_P(wbuffer(), cstr, length + 1);
>     return *this;
> }
> 
> String &String::copy(const __FlashStringHelper *pstr, unsigned int length) {
>     if (!reserve(length)) {
>         invalidate();
>         return *this;
>     }
>     setLen(length);
>     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> void String::move(String &rhs) {
>     if (buffer()) {
>         if (capacity() >= rhs.len()) {
>             memmove_P(wbuffer(), rhs.buffer(), rhs.length() + 1);
>             setLen(rhs.len());
>             rhs.invalidate();
>             return;
>         }
>         else {
>             if (!isSSO()) {
>                 free(wbuffer());
>                 setBuffer(nullptr);
>             }
>         }
>     }
>     if (rhs.isSSO()) {
>         setSSO(true);
>         memmove_P(sso.buff, rhs.sso.buff, sizeof(sso.buff));
>     }
>     else {
>         setSSO(false);
>         setBuffer(rhs.wbuffer());
>     }
>     setCapacity(rhs.capacity());
>     setLen(rhs.len());
>     rhs.setSSO(false);
>     rhs.setCapacity(0);
>     rhs.setLen(0);
>     rhs.setBuffer(nullptr);
> }
> #endif
> 
> String &String::operator =(const String &rhs) {
>     if (this == &rhs)
>         return *this;
> 
>     if (rhs.buffer())
>         copy(rhs.buffer(), rhs.len());
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
> String &String::operator =(String &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> 
> String &String::operator =(StringSumHelper &&rval) {
>     if (this != &rval)
>         move(rval);
>     return *this;
> }
> #endif
> 
> String &String::operator =(const char *cstr) {
>     if (cstr)
>         copy(cstr, strlen(cstr));
>     else
>         invalidate();
> 
>     return *this;
> }
> 
> String &String::operator = (const __FlashStringHelper *pstr)
> {
>     if (pstr) copy(pstr, strlen_P((PGM_P)pstr));
>     else invalidate();
> 
>     return *this;
> }
> 
> // /*********************************************/
> // /*  concat                                   */
> // /*********************************************/
> 
> unsigned char String::concat(const String &s) {
>     // Special case if we're concatting ourself (s += s;) since we may end up
>     // realloc'ing the buffer and moving s.buffer in the method called
>     if (&s == this) {
>         unsigned int newlen = 2 * len();
>         if (!s.buffer())
>             return 0;
>         if (s.len() == 0)
>             return 1;
>         if (!reserve(newlen))
>             return 0;
>         memmove_P(wbuffer() + len(), buffer(), len());
>         setLen(newlen);
>         wbuffer()[len()] = 0;
>         return 1;
>     }
>     else {
>         return concat(s.buffer(), s.len());
>     }
> }
> 
> unsigned char String::concat(const char *cstr, unsigned int length) {
>     unsigned int newlen = len() + length;
>     if (!cstr)
>         return 0;
>     if (length == 0)
>         return 1;
>     if (!reserve(newlen))
>         return 0;
>     memmove_P(wbuffer() + len(), cstr, length + 1);
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return 1;
> }
> 
> unsigned char String::concat(const char *cstr) {
>     if (!cstr)
>         return 0;
>     return concat(cstr, strlen(cstr));
> }
> 
> unsigned char String::concat(char c) {
>     char buf[2];
>     buf[0] = c;
>     buf[1] = 0;
>     return concat(buf, 1);
> }
> 
> unsigned char String::concat(unsigned char num) {
>     char buf[1 + 3 * sizeof(unsigned char)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(int num) {
>     char buf[2 + 3 * sizeof(int)];
>     sprintf(buf, "%d", num);
>     return concat(buf, strlen(buf));
> }
> 
> unsigned char String::concat(unsigned int num) {
>     char buf[1 + 3 * sizeof(unsigned int)];
>     utoa(num, buf, 10);
>     return concat(buf, strlen(buf));
> }
> 
> #include <limits>
> 
> static constexpr auto xxx = __CHAR_BIT__; //std::numeric_limits<unsigned long>::digits;
> 
> unsigned char String::concat(long num) {
>     char buf[std::numeric_limits<long>::digits10 + 3]; // +1 for negative +1 for NUL +1 extra margin
>     return concat(buf, snprintf(buf, sizeof(buf), "%ld", num));
> }
> 
> unsigned char String::concat(unsigned long num) {
>     char buf[std::numeric_limits<unsigned long>::digits10 + 3];
>     return concat(buf, snprintf(buf, sizeof(buf), "%lu", num));
> }
> 
> unsigned char String::concat(float num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(double num) {
>     char buf[20];
>     char *string = dtostrf(num, 4, 2, buf);
>     return concat(string, strlen(string));
> }
> 
> unsigned char String::concat(const __FlashStringHelper *str) {
>     if (!str) return 0;
>     int length = strlen_P((PGM_P)str);
>     if (length == 0) return 1;
>     unsigned int newlen = len() + length;
>     if (!reserve(newlen)) return 0;
>     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
>     setLen(newlen);
>     return 1;
> }
> 
> /*********************************************/
> /*  Concatenate                              */
> /*********************************************/
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs.buffer(), rhs.len()))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!cstr || !a.concat(cstr, strlen(cstr)))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, char c) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(c))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, float num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator +(const StringSumHelper &lhs, double num) {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(num))
>         a.invalidate();
>     return a;
> }
> 
> StringSumHelper &operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs)
> {
>     StringSumHelper &a = const_cast<StringSumHelper &>(lhs);
>     if (!a.concat(rhs))
>         a.invalidate();
>     return a;
> }
> 
> // /*********************************************/
> // /*  Comparison                               */
> // /*********************************************/
> 
> int String::compareTo(const String &s) const {
>     if (!buffer() || !s.buffer()) {
>         if (s.buffer() && s.len() > 0)
>             return 0 - *(unsigned char *)s.buffer();
>         if (buffer() && len() > 0)
>             return *(unsigned char *)buffer();
>         return 0;
>     }
>     return strcmp(buffer(), s.buffer());
> }
> 
> 
> unsigned char String::operator<(const String &rhs) const {
>     return compareTo(rhs) < 0;
> }
> 
> unsigned char String::operator>(const String &rhs) const {
>     return compareTo(rhs) > 0;
> }
> 
> unsigned char String::operator<=(const String &rhs) const {
>     return compareTo(rhs) <= 0;
> }
> 
> unsigned char String::operator>=(const String &rhs) const {
>     return compareTo(rhs) >= 0;
> }
> 
> unsigned char String::equalsConstantTime(const String &s2) const {
>     // To avoid possible time-based attacks present function
>     // compares given strings in a constant time.
>     if (len() != s2.len())
>         return 0;
>     //at this point lengths are the same
>     if (len() == 0)
>         return 1;
>     //at this point lenghts are the same and non-zero
>     const char *p1 = buffer();
>     const char *p2 = s2.buffer();
>     unsigned int equalchars = 0;
>     unsigned int diffchars = 0;
>     while (*p1) {
>         if (*p1 == *p2)
>             ++equalchars;
>         else
>             ++diffchars;
>         ++p1;
>         ++p2;
>     }
>     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
>     unsigned char equalcond = (equalchars == len());
>     unsigned char diffcond = (diffchars == 0);
>     return (equalcond & diffcond); //bitwise AND
> }
> 
> // unsigned char String::startsWith(const String &s2) const {
> //     if(len() < s2.len())
> //         return 0;
> //     return startsWith(s2, 0);
> // }
> 
> // unsigned char String::startsWith(const String &s2, unsigned int offset) const {
> //     if(offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
> //         return 0;
> //     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
> // }
> 
> // /*********************************************/
> // /*  Character Access                         */
> // /*********************************************/
> 
> char String::charAt(unsigned int loc) const {
>     return operator[](loc);
> }
> 
> void String::setCharAt(unsigned int loc, char c) {
>     if (loc < len())
>         wbuffer()[loc] = c;
> }
> 
> char &String::operator[](unsigned int index) {
>     static char dummy_writable_char;
>     if (index >= len() || !buffer()) {
>         dummy_writable_char = 0;
>         return dummy_writable_char;
>     }
>     return wbuffer()[index];
> }
> 
> char String::operator[](unsigned int index) const {
>     if (index >= len() || !buffer())
>         return 0;
>     return buffer()[index];
> }
> 
> void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
>     if (!bufsize || !buf)
>         return;
>     if (index >= len()) {
>         buf[0] = 0;
>         return;
>     }
>     unsigned int n = bufsize - 1;
>     if (n > len() - index)
>         n = len() - index;
>     strncpy((char *)buf, buffer() + index, n);
>     buf[n] = 0;
> }
> 
> // /*********************************************/
> // /*  Search                                   */
> // /*********************************************/
> 
> int String::indexOf(char ch, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *temp = strchr(buffer() + fromIndex, ch);
>     if (temp == NULL)
>         return -1;
>     return temp - buffer();
> }
> 
> int String::indexOf(const String &s2) const {
>     return indexOf(s2, 0);
> }
> 
> int String::indexOf(const String &s2, unsigned int fromIndex) const {
>     if (fromIndex >= len())
>         return -1;
>     const char *found = strstr(buffer() + fromIndex, s2.buffer());
>     if (found == NULL)
>         return -1;
>     return found - buffer();
> }
> 
> String String::substring(unsigned int left, unsigned int right) const {
>     if (left > right) {
>         unsigned int temp = right;
>         right = left;
>         left = temp;
>     }
>     String out;
>     if (left >= len())
>         return out;
>     if (right > len())
>         right = len();
>     char temp = buffer()[right];  // save the replaced character
>     wbuffer()[right] = '\0';
>     out = wbuffer() + left;  // pointer arithmetic
>     wbuffer()[right] = temp;  //restore character
>     return out;
> }
> 
> // /*********************************************/
> // /*  Modification                             */
> // /*********************************************/
> 
> bool String::insert(size_t pos, PGM_P insert, size_t insertLen) {
>     size_t len;
>     if (insertLen == 0 || (len = length()) == 0 || pos >= len) {
>         return false;
>     }
>     auto requiredLen = len + insertLen;
>     if (!reserve(requiredLen)) {
>         return false;
>     }
>     setLen(requiredLen);
>     memmove(wbuffer() + pos + insertLen, wbuffer() + pos, len - pos/* + 1 NUL byte*/);
>     memmove_P(wbuffer() + pos, insert, insertLen);
>     wbuffer()[requiredLen] = 0;
>     return true;
> }
> 
> 
> bool String::replace(char find, char replace)
> {
>     if (!buffer())
>         return true;
>     for (char *p = wbuffer(); *p; p++) {
>         if (*p == find) {
>             *p = replace;
>         }
>     }
>     return true;
> }
> 
> bool String::_replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen)
> {
>     if (length() == 0 || findLen == 0 || !find) {
>         return false;
>     }
>     int diff = replaceLen - findLen;
>     char *readFrom = wbuffer();
>     char *foundAt;
>     if (diff == 0) {
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             memmove_P(foundAt, replace, replaceLen);
>             readFrom = foundAt + replaceLen;
>         }
>     }
>     else if (diff < 0) {
>         char *writeTo = wbuffer();
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             unsigned int n = foundAt - readFrom;
>             memmove(writeTo, readFrom, n);
>             writeTo += n;
>             memmove_P(writeTo, replace, replaceLen);
>             writeTo += replaceLen;
>             readFrom = foundAt + findLen;
>             setLen(len() + diff);
>         }
>         memmove(writeTo, readFrom, strlen(readFrom) + 1);
>     }
>     else {
>         unsigned int size = len(); // compute size needed for result
>         while ((foundAt = strstr_P(readFrom, find)) != nullptr) {
>             readFrom = foundAt + findLen;
>             size += diff;
>         }
>         if (size == len()) {
>             return true;
>         }
>         if (size > capacity() && !changeBuffer(size)) {
>             return false;
>         }
>         int index = len() - 1;
>         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
>             readFrom = wbuffer() + index + findLen;
>             memmove(readFrom + diff, readFrom, len() - (readFrom - buffer()));
>             int newLen = len() + diff;
>             memmove_P(wbuffer() + index, replace, replaceLen);
>             setLen(newLen);
>             wbuffer()[newLen] = 0;
>             index--;
>         }
>     }
>     return true;
> }
> 
> void String::remove(unsigned int index) {
>     // Pass the biggest integer as the count. The remove method
>     // below will take care of truncating it at the end of the
>     // string.
>     remove(index, (unsigned int)-1);
> }
> 
> void String::remove(unsigned int index, unsigned int count) {
>     if (index >= len()) {
>         return;
>     }
>     if (count <= 0) {
>         return;
>     }
>     if (count > len() - index) {
>         count = len() - index;
>     }
>     char *writeTo = wbuffer() + index;
>     unsigned int newlen = len() - count;
>     setLen(newlen);
>     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
>     wbuffer()[newlen] = 0;
> }
> 
> String &String::toLowerCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = tolower(*p);
>     }
>     return *this;
> }
> 
> String &String::toUpperCase(void)
> {
>     if (!buffer()) {
>         return *this;
>     }
>     for (char *p = wbuffer(); *p; p++) {
>         *p = toupper(*p);
>     }
>     return *this;
> }
> 
> 
> String &String::_trim(TrimType type)
> {
>     auto len = length();
>     if (len == 0) {
>         return *this;
>     }
>     char *begin = wbuffer();
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         while (isspace(*begin)) {
>             begin++;
>         }
>     }
>     char *end = wbuffer() + len - 1;
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (isspace(*end) && end >= begin) {
>             end--;
>         }
>     }
>     unsigned int newlen = end + 1 - begin;
>     if (begin > buffer()) {
>         memmove(wbuffer(), begin, newlen);
>     }
>     setLen(newlen);
>     wbuffer()[newlen] = 0;
>     return *this;
> }
> 
> String &String::_trim(TrimType type, PGM_P characters, size_t charLen)
> {
>     auto len = length();
>     if (!len || !characters || !charLen) {
>         return *this;
>     }
>     charLen++; // use memchr instead of strchr to avoid additional NUL byte check
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::RIGHT)) {
>         while (len && memchr_P(characters, buffer()[len - 1], charLen)) {
>             len--;
>         }
>         setLen(len);
>     }
> 
>     if (static_cast<uint8_t>(type) & static_cast<uint8_t>(TrimType::LEFT)) {
>         size_t remove = 0;
>         while (memchr_P(characters, buffer()[remove], charLen)) {
>             remove++;
>         }
>         this->remove(0, remove); // remove adds NUL byte
>     }
>     else {
>         wbuffer()[len] = 0;
>     }
>     return *this;
> }
> 
> 
> // /*********************************************/
> // /*  Parsing / Conversion                     */
> // /*********************************************/
> 
> long String::toInt(void) const
> {
>     if (buffer()) {
>         return atol(buffer());
>     }
>     return 0;
> }
> 
> float String::toFloat(void) const
> {
>     if (buffer()) {
>         return atof(buffer());
>     }
>     return 0;
> }
> 
> // global empty string to allow returning const String& with nothing
> 
> const String emptyString;
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString.cpp ./framework-arduinoespressif8266/cores/esp8266/WString.cpp
1,7d0
< /*
<  WString.cpp - String library for Wiring & Arduino
<  ...mostly rewritten by Paul Stoffregen...
<  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
<  Copyright 2011, Paul Stoffregen, paul@pjrc.com
<  Modified by Ivan Grokhotkov, 2014 - esp8266 support
<  Modified by Michael C. Miller, 2015 - esp8266 progmem support
9,832c2
<  This library is free software; you can redistribute it and/or
<  modify it under the terms of the GNU Lesser General Public
<  License as published by the Free Software Foundation; either
<  version 2.1 of the License, or (at your option) any later version.
< 
<  This library is distributed in the hope that it will be useful,
<  but WITHOUT ANY WARRANTY; without even the implied warranty of
<  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<  Lesser General Public License for more details.
< 
<  You should have received a copy of the GNU Lesser General Public
<  License along with this library; if not, write to the Free Software
<  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
<  */
< 
< #include "Arduino.h"
< #include "WString.h"
< #include "stdlib_noniso.h"
< 
< #define OOM_STRING_BORDER_DISPLAY           10
< #define OOM_STRING_THRESHOLD_REALLOC_WARN  128
< 
< #define __STRHELPER(x) #x
< #define STR(x) __STRHELPER(x) // stringifier
< 
< /*********************************************/
< /*  Constructors                             */
< /*********************************************/
< 
< String::String(const char *cstr) {
<     init();
<     if (cstr)
<         copy(cstr, strlen_P(cstr));
< }
< 
< String::String(const String &value) {
<     init();
<     *this = value;
< }
< 
< String::String(const __FlashStringHelper *pstr) {
<     init();
<     *this = pstr; // see operator =
< }
< 
< String::String(String &&rval) noexcept {
<     init();
<     move(rval);
< }
< 
< String::String(unsigned char value, unsigned char base) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned char)];
<     utoa(value, buf, base);
<     *this = buf;
< }
< 
< String::String(int value, unsigned char base) {
<     init();
<     char buf[2 + 8 * sizeof(int)];
<     if (base == 10) {
<         sprintf(buf, "%d", value);
<     } else {
<         itoa(value, buf, base);
<     }
<     *this = buf;
< }
< 
< String::String(unsigned int value, unsigned char base) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned int)];
<     utoa(value, buf, base);
<     *this = buf;
< }
< 
< String::String(long value, unsigned char base) {
<     init();
<     char buf[2 + 8 * sizeof(long)];
<     if (base == 10) {
<         sprintf(buf, "%ld", value);
<     } else {
<         ltoa(value, buf, base);
<     }
<     *this = buf;
< }
< 
< String::String(unsigned long value, unsigned char base) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned long)];
<     ultoa(value, buf, base);
<     *this = buf;
< }
< 
< String::String(long long value) {
<     init();
<     char buf[2 + 8 * sizeof(long long)];
<     sprintf(buf, "%lld", value);
<     *this = buf;
< }
< 
< String::String(unsigned long long value) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned long long)];
<     sprintf(buf, "%llu", value);
<     *this = buf;
< }
< 
< String::String(long long value, unsigned char base) {
<     init();
<     char buf[2 + 8 * sizeof(long long)];
<     *this = lltoa(value, buf, sizeof(buf), base);
< }
< 
< String::String(unsigned long long value, unsigned char base) {
<     init();
<     char buf[1 + 8 * sizeof(unsigned long long)];
<     *this = ulltoa(value, buf, sizeof(buf), base);
< }
< 
< String::String(float value, unsigned char decimalPlaces) {
<     init();
<     char buf[33];
<     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
< }
< 
< String::String(double value, unsigned char decimalPlaces) {
<     init();
<     char buf[33];
<     *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
< }
< 
< /*********************************************/
< /*  Memory Management                        */
< /*********************************************/
< 
< void String::invalidate(void) {
<     if (!isSSO() && wbuffer())
<         free(wbuffer());
<     init();
< }
< 
< bool String::reserve(unsigned int size) {
<     if (buffer() && capacity() >= size)
<         return true;
<     if (changeBuffer(size)) {
<         if (len() == 0)
<             wbuffer()[0] = 0;
<         return true;
<     }
<     return false;
< }
< 
< bool String::changeBuffer(unsigned int maxStrLen) {
<     // Can we use SSO here to avoid allocation?
<     if (maxStrLen < sizeof(sso.buff) - 1) {
<         if (isSSO() || !buffer()) {
<             // Already using SSO, nothing to do
<             uint16_t oldLen = len();
<             setSSO(true);
<             setLen(oldLen);
<         } else { // if bufptr && !isSSO()
<             // Using bufptr, need to shrink into sso.buff
<             const char *temp = buffer();
<             uint16_t oldLen = len();
<             setSSO(true);
<             setLen(oldLen);
<             memcpy(wbuffer(), temp, maxStrLen);
<             free((void *)temp);
<         }
<         return true;
<     }
<     // Fallthrough to normal allocator
<     size_t newSize = (maxStrLen + 16) & (~0xf);
< #ifdef DEBUG_ESP_OOM
<     if (!isSSO() && capacity() >= OOM_STRING_THRESHOLD_REALLOC_WARN && maxStrLen > capacity()) {
<         // warn when badly re-allocating
<         DEBUGV("[offending String op %d->%d ('%." STR(OOM_STRING_BORDER_DISPLAY) "s ... %." STR(OOM_STRING_BORDER_DISPLAY) "s')]\n",
<             len(), maxStrLen, c_str(),
<             len() > OOM_STRING_BORDER_DISPLAY? c_str() + std::max((int)len() - OOM_STRING_BORDER_DISPLAY, OOM_STRING_BORDER_DISPLAY): "");
<     }
< #endif
<     // Make sure we can fit newsize in the buffer
<     if (newSize > CAPACITY_MAX) {
<         return false;
<     }
<     uint16_t oldLen = len();
<     char *newbuffer = (char *)realloc(isSSO() ? nullptr : wbuffer(), newSize);
<     if (newbuffer) {
<         size_t oldSize = capacity() + 1; // include NULL.
<         if (isSSO()) {
<             // Copy the SSO buffer into allocated space
<             memmove_P(newbuffer, sso.buff, sizeof(sso.buff));
<         }
<         if (newSize > oldSize) {
<             memset(newbuffer + oldSize, 0, newSize - oldSize);
<         }
<         setSSO(false);
<         setCapacity(newSize - 1);
<         setLen(oldLen); // Needed in case of SSO where len() never existed
<         setBuffer(newbuffer);
<         return true;
<     }
<     return false;
< }
< 
< /*********************************************/
< /*  Copy and Move                            */
< /*********************************************/
< 
< String &String::copy(const char *cstr, unsigned int length) {
<     if (!reserve(length)) {
<         invalidate();
<         return *this;
<     }
<     setLen(length);
<     memmove_P(wbuffer(), cstr, length + 1);
<     return *this;
< }
< 
< String &String::copy(const __FlashStringHelper *pstr, unsigned int length) {
<     if (!reserve(length)) {
<         invalidate();
<         return *this;
<     }
<     setLen(length);
<     memcpy_P(wbuffer(), (PGM_P)pstr, length + 1); // We know wbuffer() cannot ever be in PROGMEM, so memcpy safe here
<     return *this;
< }
< 
< void String::move(String &rhs) noexcept {
<     invalidate();
<     sso = rhs.sso;
<     rhs.init();
< }
< 
< String &String::operator =(const String &rhs) {
<     if (this == &rhs)
<         return *this;
<     if (rhs.buffer())
<         copy(rhs.buffer(), rhs.len());
<     else
<         invalidate();
<     return *this;
< }
< 
< String &String::operator =(String &&rval) noexcept {
<     if (this != &rval)
<         move(rval);
<     return *this;
< }
< 
< String &String::operator =(const char *cstr) {
<     if (cstr)
<         copy(cstr, strlen(cstr));
<     else
<         invalidate();
<     return *this;
< }
< 
< String &String::operator =(const __FlashStringHelper *pstr) {
<     if (pstr)
<         copy(pstr, strlen_P((PGM_P)pstr));
<     else
<         invalidate();
<     return *this;
< }
< 
< /*********************************************/
< /*  concat                                   */
< /*********************************************/
< 
< bool String::concat(const String &s) {
<     // Special case if we're concatting ourself (s += s;) since we may end up
<     // realloc'ing the buffer and moving s.buffer in the method called
<     if (&s == this) {
<         unsigned int newlen = 2 * len();
<         if (!s.buffer())
<             return false;
<         if (s.len() == 0)
<             return true;
<         if (!reserve(newlen))
<             return false;
<         memmove_P(wbuffer() + len(), buffer(), len());
<         setLen(newlen);
<         wbuffer()[newlen] = 0;
<         return true;
<     } else {
<         return concat(s.buffer(), s.len());
<     }
< }
< 
< bool String::concat(const char *cstr, unsigned int length) {
<     unsigned int newlen = len() + length;
<     if (!cstr)
<         return false;
<     if (length == 0)
<         return true;
<     if (!reserve(newlen))
<         return false;
<     memmove_P(wbuffer() + len(), cstr, length + 1);
<     setLen(newlen);
<     wbuffer()[newlen] = 0;
<     return true;
< }
< 
< bool String::concat(const char *cstr) {
<     if (!cstr)
<         return false;
<     return concat(cstr, strlen(cstr));
< }
< 
< bool String::concat(char c) {
<     return concat(&c, 1);
< }
< 
< bool String::concat(unsigned char num) {
<     char buf[1 + 3 * sizeof(unsigned char)];
<     return concat(buf, sprintf(buf, "%d", num));
< }
< 
< bool String::concat(int num) {
<     char buf[2 + 3 * sizeof(int)];
<     return concat(buf, sprintf(buf, "%d", num));
< }
< 
< bool String::concat(unsigned int num) {
<     char buf[1 + 3 * sizeof(unsigned int)];
<     utoa(num, buf, 10);
<     return concat(buf, strlen(buf));
< }
< 
< bool String::concat(long num) {
<     char buf[2 + 3 * sizeof(long)];
<     return concat(buf, sprintf(buf, "%ld", num));
< }
< 
< bool String::concat(unsigned long num) {
<     char buf[1 + 3 * sizeof(unsigned long)];
<     ultoa(num, buf, 10);
<     return concat(buf, strlen(buf));
< }
< 
< bool String::concat(long long num) {
<     char buf[2 + 3 * sizeof(long long)];
<     return concat(buf, sprintf(buf, "%lld", num));
< }
< 
< bool String::concat(unsigned long long num) {
<     char buf[1 + 3 * sizeof(unsigned long long)];
<     return concat(buf, sprintf(buf, "%llu", num));
< }
< 
< bool String::concat(float num) {
<     char buf[20];
<     char *string = dtostrf(num, 4, 2, buf);
<     return concat(string, strlen(string));
< }
< 
< bool String::concat(double num) {
<     char buf[20];
<     char *string = dtostrf(num, 4, 2, buf);
<     return concat(string, strlen(string));
< }
< 
< bool String::concat(const __FlashStringHelper *str) {
<     if (!str)
<         return false;
<     int length = strlen_P((PGM_P)str);
<     if (length == 0)
<         return true;
<     unsigned int newlen = len() + length;
<     if (!reserve(newlen))
<         return false;
<     memcpy_P(wbuffer() + len(), (PGM_P)str, length + 1);
<     setLen(newlen);
<     return true;
< }
< 
< /*********************************************/
< /*  Insert                                   */
< /*********************************************/
< 
< String &String::insert(size_t position, const char *other, size_t other_length) {
<     if (position > length())
<         return *this;
< 
<     auto len = length();
<     auto total = len + other_length;
<     if (!reserve(total))
<         return *this;
< 
<     auto left = len - position;
<     setLen(total);
< 
<     auto *start = wbuffer() + position;
<     memmove(start + other_length, start, left);
<     memmove_P(start, other, other_length);
<     wbuffer()[total] = '\0';
< 
<     return *this;
< }
< 
< String &String::insert(size_t position, const __FlashStringHelper *other) {
<     auto *p = reinterpret_cast<const char*>(other);
<     return insert(position, p, strlen_P(p));
< }
< 
< String &String::insert(size_t position, char other) {
<     char tmp[2] { other, '\0' };
<     return insert(position, tmp, 1);
< }
< 
< String &String::insert(size_t position, const char *other) {
<     return insert(position, other, strlen(other));
< }
< 
< String &String::insert(size_t position, const String &other) {
<     return insert(position, other.c_str(), other.length());
< }
< 
< String operator +(const String &lhs, String &&rhs) {
<     String res;
<     auto total = lhs.length() + rhs.length();
<     if (rhs.capacity() > total) {
<         rhs.insert(0, lhs);
<         res = std::move(rhs);
<     } else {
<         res.reserve(total);
<         res += lhs;
<         res += rhs;
<         rhs.invalidate();
<     }
< 
<     return res;
< }
< 
< String operator +(String &&lhs, String &&rhs) {
<     String res;
<     auto total = lhs.length() + rhs.length();
<     if ((total > lhs.capacity()) && (total < rhs.capacity())) {
<         rhs.insert(0, lhs);
<         res = std::move(rhs);
<     } else {
<         lhs += rhs;
<         rhs.invalidate();
<         res = std::move(lhs);
<     }
< 
<     return res;
< }
< 
< String operator +(char lhs, const String &rhs) {
<     String res;
<     res.reserve(rhs.length() + 1);
<     res += lhs;
<     res += rhs;
<     return res;
< }
< 
< String operator +(const char *lhs, const String &rhs) {
<     String res;
<     res.reserve(strlen_P(lhs) + rhs.length());
<     res += lhs;
<     res += rhs;
<     return res;
< }
< 
< /*********************************************/
< /*  Comparison                               */
< /*********************************************/
< 
< int String::compareTo(const String &s) const {
<     if (!buffer() || !s.buffer()) {
<         if (s.buffer() && s.len() > 0)
<             return 0 - *(unsigned char *)s.buffer();
<         if (buffer() && len() > 0)
<             return *(unsigned char *)buffer();
<         return 0;
<     }
<     return strcmp(buffer(), s.buffer());
< }
< 
< bool String::equals(const String &s2) const {
<     return (len() == s2.len() && compareTo(s2) == 0);
< }
< 
< bool String::equals(const char *cstr) const {
<     if (len() == 0)
<         return (cstr == NULL || *cstr == 0);
<     if (cstr == NULL)
<         return buffer()[0] == 0;
<     return strcmp(buffer(), cstr) == 0;
< }
< 
< bool String::operator<(const String &rhs) const {
<     return compareTo(rhs) < 0;
< }
< 
< bool String::operator>(const String &rhs) const {
<     return compareTo(rhs) > 0;
< }
< 
< bool String::operator<=(const String &rhs) const {
<     return compareTo(rhs) <= 0;
< }
< 
< bool String::operator>=(const String &rhs) const {
<     return compareTo(rhs) >= 0;
< }
< 
< bool String::equalsIgnoreCase(const String &s2) const {
<     if (this == &s2)
<         return true;
<     if (len() != s2.len())
<         return false;
<     if (len() == 0)
<         return true;
<     const char *p1 = buffer();
<     const char *p2 = s2.buffer();
<     while (*p1) {
<         if (tolower(*p1++) != tolower(*p2++))
<             return false;
<     }
<     return true;
< }
< 
< unsigned char String::equalsConstantTime(const String &s2) const {
<     // To avoid possible time-based attacks present function
<     // compares given strings in a constant time.
<     if (len() != s2.len())
<         return 0;
<     //at this point lengths are the same
<     if (len() == 0)
<         return 1;
<     //at this point lengths are the same and non-zero
<     const char *p1 = buffer();
<     const char *p2 = s2.buffer();
<     unsigned int equalchars = 0;
<     unsigned int diffchars = 0;
<     while (*p1) {
<         if (*p1 == *p2)
<             ++equalchars;
<         else
<             ++diffchars;
<         ++p1;
<         ++p2;
<     }
<     //the following should force a constant time eval of the condition without a compiler "logical shortcut"
<     unsigned char equalcond = (equalchars == len());
<     unsigned char diffcond = (diffchars == 0);
<     return (equalcond & diffcond); //bitwise AND
< }
< 
< bool String::startsWith(const String &s2) const {
<     if (len() < s2.len())
<         return false;
<     return startsWith(s2, 0);
< }
< 
< bool String::startsWith(const String &s2, unsigned int offset) const {
<     if (offset > (unsigned)(len() - s2.len()) || !buffer() || !s2.buffer())
<         return false;
<     return strncmp(&buffer()[offset], s2.buffer(), s2.len()) == 0;
< }
< 
< bool String::endsWith(const String &s2) const {
<     if (len() < s2.len() || !buffer() || !s2.buffer())
<         return false;
<     return strcmp(&buffer()[len() - s2.len()], s2.buffer()) == 0;
< }
< 
< /*********************************************/
< /*  Character Access                         */
< /*********************************************/
< 
< void String::setCharAt(unsigned int loc, char c) {
<     if (loc < len())
<         wbuffer()[loc] = c;
< }
< 
< char &String::operator[](unsigned int index) {
<     static char dummy_writable_char;
<     if (index >= len() || !buffer()) {
<         dummy_writable_char = 0;
<         return dummy_writable_char;
<     }
<     return wbuffer()[index];
< }
< 
< char String::operator[](unsigned int index) const {
<     if (index >= len() || !buffer())
<         return '\0';
<     return buffer()[index];
< }
< 
< void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const {
<     if (!bufsize || !buf)
<         return;
<     if (index >= len()) {
<         buf[0] = 0;
<         return;
<     }
<     unsigned int n = bufsize - 1;
<     if (n > len() - index)
<         n = len() - index;
<     strncpy((char *)buf, buffer() + index, n);
<     buf[n] = 0;
< }
< 
< /*********************************************/
< /*  Search                                   */
< /*********************************************/
< 
< int String::indexOf(char ch, unsigned int fromIndex) const {
<     if (fromIndex >= len())
<         return -1;
<     const char *temp = strchr(buffer() + fromIndex, ch);
<     if (temp == NULL)
<         return -1;
<     return temp - buffer();
< }
< 
< int String::indexOf(const char *s2, unsigned int fromIndex) const {
<     if (fromIndex >= len())
<         return -1;
<     const char *found = strstr_P(buffer() + fromIndex, s2);
<     if (found == NULL)
<         return -1;
<     return found - buffer();
< }
< 
< int String::indexOf(const String &s2, unsigned int fromIndex) const {
<     return indexOf(s2.c_str(), fromIndex);
< }
< 
< int String::lastIndexOf(char ch) const {
<     return lastIndexOf(ch, len() - 1);
< }
< 
< int String::lastIndexOf(char ch, unsigned int fromIndex) const {
<     if (fromIndex >= len())
<         return -1;
<     char *writeTo = wbuffer();
<     char tempchar = writeTo[fromIndex + 1]; // save the replaced character
<     writeTo[fromIndex + 1] = '\0';
<     char *temp = strrchr(writeTo, ch);
<     writeTo[fromIndex + 1] = tempchar; // restore character
<     if (temp == NULL)
<         return -1;
<     return temp - writeTo;
< }
< 
< int String::lastIndexOf(const String &s2) const {
<     return lastIndexOf(s2, len() - s2.len());
< }
< 
< int String::lastIndexOf(const String &s2, unsigned int fromIndex) const {
<     if (s2.len() == 0 || len() == 0 || s2.len() > len())
<         return -1;
<     if (fromIndex >= len())
<         fromIndex = len() - 1;
<     int found = -1;
<     for (const char *p = buffer(); p <= buffer() + fromIndex; p++) {
<         p = strstr(p, s2.buffer());
<         if (!p)
<             break;
<         if ((unsigned int)(p - buffer()) <= fromIndex)
<             found = p - buffer();
<     }
<     return found;
< }
< 
< String String::substring(unsigned int left, unsigned int right) const {
<     if (left > right) {
<         unsigned int temp = right;
<         right = left;
<         left = temp;
<     }
<     String out;
<     if (left >= len())
<         return out;
<     if (right > len())
<         right = len();
<     char *writeTo = wbuffer();
<     char tempchar = writeTo[right]; // save the replaced character
<     writeTo[right] = '\0';
<     out = writeTo + left; // pointer arithmetic
<     writeTo[right] = tempchar; // restore character
<     return out;
< }
< 
< /*********************************************/
< /*  Modification                             */
< /*********************************************/
< 
< void String::replace(char find, char replace) {
<     if (!buffer())
<         return;
<     for (char *p = wbuffer(); *p; p++) {
<         if (*p == find)
<             *p = replace;
<     }
< }
< 
< void String::replace(const String &find, const String &replace) {
<     if (len() == 0 || find.len() == 0)
<         return;
<     int diff = replace.len() - find.len();
<     char *readFrom = wbuffer();
<     char *foundAt;
<     if (diff == 0) {
<         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
<             memmove_P(foundAt, replace.buffer(), replace.len());
<             readFrom = foundAt + replace.len();
<         }
<     } else if (diff < 0) {
<         char *writeTo = wbuffer();
<         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
<             unsigned int n = foundAt - readFrom;
<             memmove_P(writeTo, readFrom, n);
<             writeTo += n;
<             memmove_P(writeTo, replace.buffer(), replace.len());
<             writeTo += replace.len();
<             readFrom = foundAt + find.len();
<             setLen(len() + diff);
<         }
<         memmove_P(writeTo, readFrom, strlen(readFrom) + 1);
<     } else {
<         unsigned int size = len(); // compute size needed for result
<         while ((foundAt = strstr(readFrom, find.buffer())) != NULL) {
<             readFrom = foundAt + find.len();
<             size += diff;
<         }
<         if (size == len())
<             return;
<         if (size > capacity() && !changeBuffer(size))
<             return; // XXX: tell user!
<         int index = len() - 1;
<         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
<             readFrom = wbuffer() + index + find.len();
<             memmove_P(readFrom + diff, readFrom, len() - (readFrom - buffer()));
<             int newLen = len() + diff;
<             memmove_P(wbuffer() + index, replace.buffer(), replace.len());
<             setLen(newLen);
<             wbuffer()[newLen] = 0;
<             index--;
<         }
<     }
< }
< 
< void String::remove(unsigned int index, unsigned int count) {
<     if (index >= len()) {
<         return;
<     }
<     if (count <= 0) {
<         return;
<     }
<     if (count > len() - index) {
<         count = len() - index;
<     }
<     char *writeTo = wbuffer() + index;
<     unsigned int newlen = len() - count;
<     setLen(newlen);
<     memmove_P(writeTo, wbuffer() + index + count, newlen - index);
<     wbuffer()[newlen] = 0;
< }
< 
< void String::toLowerCase(void) {
<     if (!buffer())
<         return;
<     for (char *p = wbuffer(); *p; p++) {
<         *p = tolower(*p);
<     }
< }
< 
< void String::toUpperCase(void) {
<     if (!buffer())
<         return;
<     for (char *p = wbuffer(); *p; p++) {
<         *p = toupper(*p);
<     }
< }
< 
< void String::trim(void) {
<     if (!buffer() || len() == 0)
<         return;
<     char *begin = wbuffer();
<     while (isspace(*begin))
<         begin++;
<     char *end = wbuffer() + len() - 1;
<     while (isspace(*end) && end >= begin)
<         end--;
<     unsigned int newlen = end + 1 - begin;
<     setLen(newlen);
<     if (begin > buffer())
<         memmove_P(wbuffer(), begin, newlen);
<     wbuffer()[newlen] = 0;
< }
< 
< /*********************************************/
< /*  Parsing / Conversion                     */
< /*********************************************/
< 
< long String::toInt(void) const {
<     if (buffer())
<         return atol(buffer());
<     return 0;
< }
< 
< float String::toFloat(void) const {
<     if (buffer())
<         return atof(buffer());
<     return 0.0F;
< }
< 
< double String::toDouble(void) const {
<     if (buffer())
<         return atof(buffer());
<     return 0.0;
< }
< 
< // global empty string to allow returning const String& with nothing
< 
< const String emptyString;
---
> #include "WString/WStringEX.cpp"
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/cores/esp8266/WString.h ./framework-arduinoespressif8266/cores/esp8266/WString.h
21a22,23
> #pragma once
> 
25a28,33
> #ifdef _MSC_VER
> #include <misc_wstring.h>
> #else
> #include <stdlib.h>
> #include <string.h>
> #include <ctype.h>
26a35,36
> #include "KFCBaseLibrary/include/misc_wstring.h"
> #endif
28,34c38,40
< #include <cstdlib>
< #include <cstdint>
< #include <cstring>
< #include <cctype>
< 
< #include <utility>
< #include <type_traits>
---
>  // An inherited class for holding the result of a concatenation.  These
>  // result objects are assumed to be writable by subsequent concatenations.
> class StringSumHelper;
38a45
> #ifndef FPSTR
39a47,48
> #endif
> #ifndef F
41,44c50
< 
< // support libraries that expect this name to be available
< // replace with `using StringSumHelper = String;` in case something wants this constructible
< class StringSumHelper;
---
> #endif
48,319c54,1020
<     public:
<         // constructors
<         // creates a copy of the initial value.
<         // if the initial value is null or invalid, or if memory allocation
<         // fails, the string will be marked as invalid (i.e. "if (s)" will
<         // be false).
<         String() __attribute__((always_inline)) { // See init()
<             init();
<         }
<         String(const char *cstr);
<         String(const String &str);
<         String(const __FlashStringHelper *str);
<         String(String &&rval) noexcept;
<         explicit String(char c) {
<             sso.buff[0] = c;
<             sso.buff[1] = 0;
<             sso.len     = 1;
<             sso.isHeap  = 0;
<         }
<         explicit String(unsigned char, unsigned char base = 10);
<         explicit String(int, unsigned char base = 10);
<         explicit String(unsigned int, unsigned char base = 10);
<         explicit String(long, unsigned char base = 10);
<         explicit String(unsigned long, unsigned char base = 10);
<         explicit String(long long /* base 10 */);
<         explicit String(long long, unsigned char base);
<         explicit String(unsigned long long /* base 10 */);
<         explicit String(unsigned long long, unsigned char base);
<         explicit String(float, unsigned char decimalPlaces = 2);
<         explicit String(double, unsigned char decimalPlaces = 2);
<         ~String() {
<             invalidate();
<         }
< 
<         // memory management
<         // return true on success, false on failure (in which case, the string
<         // is left unchanged).  reserve(0), if successful, will validate an
<         // invalid string (i.e., "if (s)" will be true afterwards)
<         bool reserve(unsigned int size);
<         unsigned int length(void) const {
<             return buffer() ? len() : 0;
<         }
<         void clear(void) {
<             setLen(0);
<         }
<         bool isEmpty(void) const {
<             return length() == 0;
<         }
< 
<         // creates a copy of the assigned value.  if the value is null or
<         // invalid, or if the memory allocation fails, the string will be
<         // marked as invalid ("if (s)" will be false).
<         String &operator =(const String &rhs);
<         String &operator =(const char *cstr);
<         String &operator =(const __FlashStringHelper *str);
<         String &operator =(String &&rval) noexcept;
<         String &operator =(char c) {
<             char buffer[2] { c, '\0' };
<             *this = buffer;
<             return *this;
<         }
< 
<         // concatenate (works w/ built-in types)
< 
<         // returns true on success, false on failure (in which case, the string
<         // is left unchanged).  if the argument is null or invalid, the
<         // concatenation is considered unsuccessful.
<         bool concat(const String &str);
<         bool concat(const char *cstr);
<         bool concat(char c);
<         bool concat(unsigned char c);
<         bool concat(int num);
<         bool concat(unsigned int num);
<         bool concat(long num);
<         bool concat(unsigned long num);
<         bool concat(long long num);
<         bool concat(unsigned long long num);
<         bool concat(float num);
<         bool concat(double num);
<         bool concat(const __FlashStringHelper *str);
<         bool concat(const char *cstr, unsigned int length);
< 
<         // if there's not enough memory for the concatenated value, the string
<         // will be left unchanged (but this isn't signalled in any way)
<         template <typename T>
<         String &operator +=(const T &rhs) {
<             concat(rhs);
<             return *this;
<         }
< 
<         explicit operator bool() const {
<             return buffer() != nullptr;
<         }
< 
<         int compareTo(const String &s) const;
<         bool equals(const String &s) const;
<         bool equals(const char *cstr) const;
<         bool operator ==(const String &rhs) const {
<             return equals(rhs);
<         }
<         bool operator ==(const char *cstr) const {
<             return equals(cstr);
<         }
<         bool operator !=(const String &rhs) const {
<             return !equals(rhs);
<         }
<         bool operator !=(const char *cstr) const {
<             return !equals(cstr);
<         }
<         bool operator <(const String &rhs) const;
<         bool operator >(const String &rhs) const;
<         bool operator <=(const String &rhs) const;
<         bool operator >=(const String &rhs) const;
<         bool equalsIgnoreCase(const String &s) const;
<         unsigned char equalsConstantTime(const String &s) const;
<         bool startsWith(const String &prefix) const;
<         bool startsWith(const char *prefix) const {
<             return this->startsWith(String(prefix));
<         }
<         bool startsWith(const __FlashStringHelper *prefix) const {
<             return this->startsWith(String(prefix));
<         }
<         bool startsWith(const String &prefix, unsigned int offset) const;
<         bool endsWith(const String &suffix) const;
<         bool endsWith(const char *suffix) const {
<             return this->endsWith(String(suffix));
<         }
<         bool endsWith(const __FlashStringHelper *suffix) const {
<             return this->endsWith(String(suffix));
<         }
< 
<         // character access
<         char charAt(unsigned int index) const {
<             return operator [](index);
<         }
<         void setCharAt(unsigned int index, char c);
<         char operator [](unsigned int index) const;
<         char &operator [](unsigned int index);
<         void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
<         void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
<             getBytes((unsigned char *) buf, bufsize, index);
<         }
<         const char *c_str() const { return buffer(); }
<         char *begin() { return wbuffer(); }
<         char *end() { return wbuffer() + length(); }
<         const char *begin() const { return c_str(); }
<         const char *end() const { return c_str() + length(); }
< 
<         // search
<         int indexOf(char ch, unsigned int fromIndex = 0) const;
<         int indexOf(const char *str, unsigned int fromIndex = 0) const;
<         int indexOf(const __FlashStringHelper *str, unsigned int fromIndex = 0) const {
<             return indexOf((const char*)str, fromIndex);
<         }
<         int indexOf(const String &str, unsigned int fromIndex = 0) const;
<         int lastIndexOf(char ch) const;
<         int lastIndexOf(char ch, unsigned int fromIndex) const;
<         int lastIndexOf(const String &str) const;
<         int lastIndexOf(const String &str, unsigned int fromIndex) const;
<         String substring(unsigned int beginIndex) const {
<             return substring(beginIndex, len());
<         }
<         String substring(unsigned int beginIndex, unsigned int endIndex) const;
< 
<         // modification
<         void replace(char find, char replace);
<         void replace(const String &find, const String &replace);
<         void replace(const char *find, const String &replace) {
<             this->replace(String(find), replace);
<         }
<         void replace(const __FlashStringHelper *find, const String &replace) {
<             this->replace(String(find), replace);
<         }
<         void replace(const char *find, const char *replace) {
<             this->replace(String(find), String(replace));
<         }
<         void replace(const __FlashStringHelper *find, const char *replace) {
<             this->replace(String(find), String(replace));
<         }
<         void replace(const __FlashStringHelper *find, const __FlashStringHelper *replace) {
<             this->replace(String(find), String(replace));
<         }
<         // Pass the biggest integer if the count is not specified.
<         // The remove method below will take care of truncating it at the end of the string.
<         void remove(unsigned int index, unsigned int count = (unsigned int)-1);
<         void toLowerCase(void);
<         void toUpperCase(void);
<         void trim(void);
< 
<         // parsing/conversion
<         long toInt(void) const;
<         float toFloat(void) const;
<         double toDouble(void) const;
< 
<     protected:
<         // Contains the string info when we're not in SSO mode
<         struct _ptr {
<             char *   buff;
<             uint16_t cap;
<             uint16_t len;
<         };
<         // This allows strings up up to 11 (10 + \0 termination) without any extra space.
<         enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
<         struct _sso {
<             char     buff[SSOSIZE];
<             unsigned char len    : 7; // Ensure only one byte is allocated by GCC for the bitfields
<             unsigned char isHeap : 1;
<         } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
<         enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
<         union {
<             struct _ptr ptr;
<             struct _sso sso;
<         };
<         // Accessor functions
<         bool isSSO() const { return !sso.isHeap; }
<         unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
<         unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
<         void setSSO(bool set) { sso.isHeap = !set; }
<         void setLen(int len) {
<             if (isSSO()) {
<                 setSSO(true); // Avoid emitting of bitwise EXTRACT-AND-OR ops (store-merging optimization)
<                 sso.len = len;
<             } else
<                 ptr.len = len;
<         }
<         void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
<         void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
<         // Buffer accessor functions
<         const char *buffer() const { return wbuffer(); }
<         char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
< 
<         // concatenation is done via non-member functions
<         // make sure we still have access to internal methods, since we optimize based on capacity of both sides and want to manipulate internal buffers directly
<         friend String operator +(const String &lhs, String &&rhs);
<         friend String operator +(String &&lhs, String &&rhs);
<         friend String operator +(char lhs, String &&rhs);
<         friend String operator +(const char *lhs, String &&rhs);
<         friend String operator +(const __FlashStringHelper *lhs, String &&rhs);
< 
<     protected:
<         void init(void) __attribute__((always_inline)) {
<             sso.buff[0] = 0;
<             sso.len     = 0;
<             sso.isHeap  = 0;
<             // Without the 6 statements shown below, GCC simply emits such as: "MOVI.N aX,0", "S8I aX,a2,0" and "S8I aX,a2,11" (8 bytes in total)
<             sso.buff[1]  = 0;
<             sso.buff[2]  = 0;
<             sso.buff[3]  = 0;
<             sso.buff[8]  = 0;
<             sso.buff[9]  = 0;
<             sso.buff[10] = 0;
<             // With the above, thanks to store-merging, GCC can use the narrow form of 32-bit store insn ("S32I.N") and emits:
<             //   "MOVI.N aX,0", "S32I.N aX,a2,0" and "S32I.N aX,a2,8" (6 bytes in total)
<             // (Literature: Xtensa(R) Instruction Set Reference Manual, "S8I - Store 8-bit" [p.504] and "S32I.N - Narrow Store 32-bit" [p.512])
<             // Unfortunately, GCC seems not to re-evaluate the cost of inlining after the store-merging optimizer stage,
<             // `always_inline` attribute is necessary in order to keep inlining.
<         }
<         void invalidate(void);
<         bool changeBuffer(unsigned int maxStrLen);
< 
<         // copy or insert at a specific position
<         String &copy(const char *cstr, unsigned int length);
<         String &copy(const __FlashStringHelper *pstr, unsigned int length);
< 
<         String &insert(size_t position, char);
<         String &insert(size_t position, const char *);
<         String &insert(size_t position, const __FlashStringHelper *);
<         String &insert(size_t position, const char *, size_t length);
<         String &insert(size_t position, const String &);
< 
<         // rvalue helper
<         void move(String &rhs) noexcept;
---
>     // use a function pointer to allow for "if (s)" without the
>     // complications of an operator bool(). for more information, see:
>     // http://www.artima.com/cppsource/safebool.html
>     typedef void (String:: *StringIfHelperType)() const;
>     void StringIfHelper() const {
>     }
> 
> public:
>     // constructors
>     // creates a copy of the initial value.
>     // if the initial value is null or invalid, or if memory allocation
>     // fails, the string will be marked as invalid (i.e. "if (s)" will
>     // be false).
>     String(const char *cstr = nullptr);
>     String(const String &str);
>     String(const __FlashStringHelper *str);
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
>     String(String &&rval);
>     String(StringSumHelper &&rval);
> #endif
>     explicit String(char c);
>     explicit String(unsigned char, unsigned char base = 10);
>     explicit String(int, unsigned char base = 10);
>     explicit String(unsigned int, unsigned char base = 10);
>     explicit String(long, unsigned char base = 10);
>     explicit String(unsigned long, unsigned char base = 10);
>     explicit String(float, unsigned char decimalPlaces = 2);
>     explicit String(double, unsigned char decimalPlaces = 2);
>     ~String(void);
> 
>     // memory management
>     // return true on success, false on failure (in which case, the string
>     // is left unchanged).  reserve(0), if successful, will validate an
>     // invalid string (i.e., "if (s)" will be true afterwards)
>     unsigned char reserve(unsigned int size);
>     inline unsigned int length(void) const {
>         if (buffer()) {
>             return len();
>         }
>         else {
>             return 0;
>         }
>     }
>     inline void clear(void) {
>         setLen(0);
>     }
>     inline bool isEmpty(void) const {
>         return length() == 0;
>     }
> 
>     // creates a copy of the assigned value.  if the value is null or
>     // invalid, or if the memory allocation fails, the string will be
>     // marked as invalid ("if (s)" will be false).
>     String &operator =(const String &rhs);
>     String &operator =(const char *cstr);
>     String &operator = (const __FlashStringHelper *str);
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
>     String &operator =(String &&rval);
>     String &operator =(StringSumHelper &&rval);
> #endif
> 
>     // concatenate (works w/ built-in types)
> 
>     // returns true on success, false on failure (in which case, the string
>     // is left unchanged).  if the argument is null or invalid, the
>     // concatenation is considered unsuccessful.
>     unsigned char concat(const String &str);
>     unsigned char concat(const char *cstr);
>     unsigned char concat(char c);
>     unsigned char concat(unsigned char c);
>     unsigned char concat(int num);
>     unsigned char concat(unsigned int num);
>     unsigned char concat(long num);
>     unsigned char concat(unsigned long num);
>     unsigned char concat(float num);
>     unsigned char concat(double num);
>     unsigned char concat(const __FlashStringHelper *str);
>     unsigned char concat(const char *cstr, unsigned int length);
> 
>     // if there's not enough memory for the concatenated value, the string
>     // will be left unchanged (but this isn't signalled in any way)
>     String &operator +=(const String &rhs) {
>         concat(rhs);
>         return (*this);
>     }
>     String &operator +=(const char *cstr) {
>         concat(cstr);
>         return (*this);
>     }
>     String &operator +=(char c) {
>         concat(c);
>         return (*this);
>     }
>     String &operator +=(unsigned char num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(int num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(unsigned int num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(long num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(unsigned long num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(float num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator +=(double num) {
>         concat(num);
>         return (*this);
>     }
>     String &operator += (const __FlashStringHelper *str) {
>         concat(str);
>         return (*this);
>     }
> 
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, const String &rhs);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, const char *cstr);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, char c);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned char num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, int num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned int num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, long num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, unsigned long num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, float num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, double num);
>     friend StringSumHelper &operator +(const StringSumHelper &lhs, const __FlashStringHelper *rhs);
> 
>     // comparison (only works w/ Strings and "strings")
>     operator StringIfHelperType() const {
>         return buffer() ? &String::StringIfHelper : 0;
>     }
>     unsigned char operator ==(char ch) const {
>         return equals(ch);
>     }
>     unsigned char operator ==(const String &rhs) const {
>         return equals(rhs);
>     }
>     unsigned char operator ==(const char *cstr) const {
>         return equals(cstr);
>     }
>     unsigned char operator ==(const __FlashStringHelper *fstr) const {
>         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) == 0;
>     }
>     unsigned char operator !=(char ch) const {
>         return !equals(ch);
>     }
>     unsigned char operator !=(const String &rhs) const {
>         return !equals(rhs);
>     }
>     unsigned char operator !=(const char *cstr) const {
>         return !equals(cstr);
>     }
>     unsigned char operator !=(const __FlashStringHelper *fstr) const {
>         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fstr)) != 0;
>     }
> 
>     unsigned char operator <(const String &rhs) const;
>     unsigned char operator >(const String &rhs) const;
>     unsigned char operator <=(const String &rhs) const;
>     unsigned char operator >=(const String &rhs) const;
> 
>     int compareTo(const String &s) const;
> 
>     //
>     // equals()
>     //
>     // changed behaviour:
>     // any nullptr argument will return false -> String.equals(nullptr) does not return true if String is empty
> 
>     // the terminating NUL byte is not considered part of the string
>     // String.equals('\0') always returns false, even if String is empty
>     // use length() == 0 to determine if a string is empty
>     unsigned char equals(char ch) const {
>         if (length() != 1 || !ch) {
>             return false;
>         }
>         return buffer()[0] == ch;
>     }
> 
>     unsigned char equals(const String &str) const {
>         if (this == &str) {
>             return true;
>         }
>         if (length() != str.length()) {
>             return false;
>         }
>         return strcmp(buffer(), str.buffer()) == 0;
>     }
> 
>     unsigned char equals(const char *cStr) const {
>         if (!cStr) {
>             return false;
>         }
>         if (length() == 0) {
>             return (*cStr == 0);
>         }
>         return strcmp(buffer(), cStr) == 0;
>     }
> 
>     unsigned char equals(const __FlashStringHelper *fStr) const {
>         if (!fStr) {
>             return false;
>         }
>         return strcmp_P(buffer(), reinterpret_cast<PGM_P>(fStr)) == 0;
>     }
> 
>     // return true if String matches the end of str1
>     // basically a.endsWith(b) = b.endEquals(a)
>     //
>     // String("123").endEquals("test123") == true
>     // String("").endEquals(nullptr) == false
>     bool endEquals(const char *str1) const {
>         size_t len1;
>         size_t len2;
>         if (!str1 || (len2 = length()) > (len1 = strlen(str1))) {
>             return false;
>         }
>         if (len2 == len1) {
>             return strcmp(str1, buffer()) == 0;
>         }
>         return strcmp(str1 + len1 - len2, buffer()) == 0;
>     }
> 
>     bool endEquals(const __FlashStringHelper *fStr) const {
>         PGM_P str1 = reinterpret_cast<PGM_P>(fStr);
>         size_t len1;
>         size_t len2;
>         if (!str1 || (len2 = length()) > (len1 = strlen_P(str1))) {
>             return false;
>         }
>         if (len2 == len1) {
>             return strcmp_P_P(str1, buffer()) == 0;
>         }
>         return strcmp_P_P(str1 + len1 - len2, buffer()) == 0;
>     }
> 
>     // we can use endsWith in this case
>     inline bool endEquals(const String &str) const {
>         return str.endsWith(*this);
>     }
> 
>     // return true if String matches the end of str1
>     // basically a.endsWith(b) = b.endEquals(a)
>     //
>     // String("abc").endEqualsIgnoreCase("TESTABC") == true
>     // String("").endEqualsIgnoreCase(nullptr) == false
>     bool endEqualsIgnoreCase(const char *str1) const {
>         size_t len1;
>         size_t len2;
>         if (!str1 || (len2 = length()) > (len1 = strlen(str1))) {
>             return false;
>         }
>         if (len2 == len1) {
>             return strcasecmp(str1, buffer()) == 0;
>         }
>         return strcasecmp(str1 + len1 - len2, buffer()) == 0;
>     }
> 
>     bool endEqualsIgnoreCase(const __FlashStringHelper *fStr) const {
>         PGM_P str1 = reinterpret_cast<PGM_P>(fStr);
>         size_t len1;
>         size_t len2;
>         if (!str1 || (len2 = length()) > (len1 = strlen_P(str1))) {
>             return false;
>         }
>         if (len2 == len1) {
>             return strcasecmp_P_P(str1, buffer()) == 0;
>         }
>         return strcasecmp_P_P(str1 + len1 - len2, buffer()) == 0;
>     }
> 
>     // we can just use endsWithIgnoreCase in this case
>     inline bool endEqualsIgnoreCase(const String &str) const {
>         return str.endsWithIgnoreCase(*this);
>     }
> 
>     //
>     // equals() with offset
>     //
> 
>     unsigned char equals(const String &str, size_t offset) const {
>         size_t len1;
>         size_t len2;
>         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
>             return false;
>         }
>         return strcmp(buffer() + offset, str.c_str()) == 0;
>     }
> 
>     unsigned char equals(const char *cStr, size_t offset) const {
>         if (!cStr || !*cStr || offset >= length()) {
>             return false;
>         }
>         return strcmp(buffer() + offset, cStr) == 0;
>     }
> 
>     unsigned char equals(const __FlashStringHelper *fStr, size_t offset) const {
>         if (!fStr || offset >= length()) {
>             return false;
>         }
>         return strcmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
>     }
> 
>     //
>     // equalsIgnoreCase() with offset
>     //
> 
>     unsigned char equalsIgnoreCase(const String &str, size_t offset = 0) const {
>         if (offset == 0 && this == &str) {
>             return true;
>         }
>         size_t len1;
>         size_t len2;
>         if (((len1 = length()) == 0) || (offset >= len1) || ((len2 = str.length()) == 0) || ((len1 + offset) != len2)) {
>             return false;
>         }
>         return strcasecmp(buffer() + offset, str.c_str()) == 0;
>     }
> 
>     unsigned char equalsIgnoreCase(const char *cStr, size_t offset = 0) const {
>         if (!cStr || !*cStr || offset >= length()) {
>             return false;
>         }
>         return strcasecmp(buffer() + offset, cStr) == 0;
>     }
> 
>     unsigned char equalsIgnoreCase(const __FlashStringHelper *fStr, size_t offset = 0) const {
>         if (!fStr || offset >= length()) {
>             return false;
>         }
>         return strcasecmp_P(buffer() + offset, reinterpret_cast<PGM_P>(fStr)) == 0;
>     }
> 
>     //
>     // equalsConstantTime
>     //
> 
>     unsigned char equalsConstantTime(const String &s) const;
> 
>     //
>     // _startsWith
>     //
> 
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWith(const char *prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncmp(c_str() + offset, prefix, prefixLen);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWith_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncmp_P(c_str() + offset, prefix, prefixLen);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWithIgnoreCase(const char *prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp(c_str() + offset, prefix, prefixLen);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _startsWithIgnoreCase_P(PGM_P prefix, size_t prefixLen, size_t offset) const {
>         return prefixLen && (length() >= prefixLen + offset) && !strncasecmp_P(c_str() + offset, prefix, prefixLen);
>     }
> 
>     //
>     // startsWith(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
>     //
> 
>     unsigned char startsWith(char ch) const {
>         return (length() != 0) && (buffer()[0] == ch);
>     }
>     unsigned char startsWith(char ch, size_t offset) const {
>         return (length() > offset) && (buffer()[offset] == ch);
>     }
>     unsigned char startsWith(const char *prefix, size_t offset = 0) const {
>         return prefix && _startsWith(prefix, strlen(prefix), offset);
>     }
>     unsigned char startsWith(const String &prefix, size_t offset = 0) const {
>         size_t len;
>         return ((len = prefix.length())) != 0 && _startsWith(prefix.buffer(), len, offset);
>     }
>     unsigned char startsWith(const __FlashStringHelper *prefix, size_t offset = 0) const {
>         return prefix && _startsWith_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
>     }
> 
>     //
>     // startsWithIgnoreCase(<char|const char *|const String &|const __FlashStringHelper *>[,offset]])
>     //
> 
>     unsigned char startsWithIgnoreCase(char ch, size_t offset = 0) const {
>         return (length() > offset) && (tolower(buffer()[offset]) == tolower(ch));
>     }
>     unsigned char startsWithIgnoreCase(const char *prefix, size_t offset = 0) const {
>         return prefix && _startsWithIgnoreCase(prefix, strlen(prefix), offset);
>     }
>     unsigned char startsWithIgnoreCase(const String &prefix, size_t offset = 0) const {
>         size_t len;
>         return ((len = prefix.length())) != 0 && _startsWithIgnoreCase(prefix.buffer(), len, offset);
>     }
>     unsigned char startsWithIgnoreCase(const __FlashStringHelper *prefix, size_t offset = 0) const {
>         return prefix && _startsWithIgnoreCase_P(reinterpret_cast<PGM_P>(prefix), strlen_P(reinterpret_cast<PGM_P>(prefix)), offset);
>     }
> 
>     //
>     // _endsWith
>     //
> 
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWith(const char *suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcmp(buffer() + len - suffixLen, suffix);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWith_P(PGM_P suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcmp_P(buffer() + len - suffixLen, suffix);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWithIgnoreCase(const char *suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp(buffer() + len - suffixLen, suffix);
>     }
>     inline __attribute__((__always_inline__))
>         unsigned char _endsWithIgnoreCase_P(PGM_P suffix, size_t suffixLen) const {
>         size_t len;
>         return suffixLen && ((len = length()) >= suffixLen) && !strcasecmp_P(buffer() + len - suffixLen, suffix);
>     }
> 
>     //
>     // endsWith
>     //
> 
>     unsigned char endsWith(char ch) const {
>         auto len = length();
>         return (len != 0) && (buffer()[len - 1] == ch);
>     }
>     unsigned char endsWith(const String &suffix) const {
>         return _endsWith(suffix.buffer(), suffix.length());
>     }
>     unsigned char endsWith(const char *suffix) const {
>         return suffix && _endsWith(suffix, strlen(suffix));
>     }
>     unsigned char endsWith(const __FlashStringHelper *suffix) const {
>         return suffix && _endsWith_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
>     }
> 
>     //
>     // endsWithIgnoreCase
>     //
> 
>     unsigned char endsWithIgnoreCase(char ch) const {
>         auto len = length();
>         return (len != 0) && (tolower(buffer()[len - 1]) == tolower(ch));
>     }
>     unsigned char endsWithIgnoreCase(const String &suffix) const {
>         return _endsWithIgnoreCase(suffix.buffer(), suffix.length());
>     }
>     unsigned char endsWithIgnoreCase(const char *suffix) const {
>         return suffix && _endsWithIgnoreCase(suffix, strlen(suffix));
>     }
>     unsigned char endsWithIgnoreCase(const __FlashStringHelper *suffix) const {
>         return suffix && _endsWithIgnoreCase_P(reinterpret_cast<PGM_P>(suffix), strlen_P(reinterpret_cast<PGM_P>(suffix)));
>     }
> 
>     // character access
>     char charAt(unsigned int index) const;
>     void setCharAt(unsigned int index, char c);
>     char operator [](unsigned int index) const;
>     char &operator [](unsigned int index);
>     void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index = 0) const;
>     void toCharArray(char *buf, unsigned int bufsize, unsigned int index = 0) const {
>         getBytes((unsigned char *)buf, bufsize, index);
>     }
>     const char *c_str() const { return buffer(); }
>     char *begin() { return wbuffer(); }
>     char *end() { return wbuffer() + length(); }
>     const char *begin() const { return c_str(); }
>     const char *end() const { return c_str() + length(); }
> 
> protected:
>     // findLength is optional, provide only if available
>     int _indexOf(const char *find, size_t fromIndex, size_t findLength = ~0) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
>             return -1;
>         }
>         auto ptr = buffer();
>         auto idxPtr = strstr(ptr + fromIndex, find);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _indexOfIgnoreCase(const char *find, size_t fromIndex, size_t findLength = ~0) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
>             return -1;
>         }
>         auto ptr = wbuffer();
>         auto idxPtr = stristr(ptr + fromIndex, find);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _indexOf_P(PGM_P find, size_t fromIndex, size_t findLength = ~0) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (findLength != ~0U && (fromIndex + findLength >= len))) {
>             return -1;
>         }
>         auto ptr = buffer();
>         auto idxPtr = strstr_P(ptr + fromIndex, find);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _indexOfIgnoreCase_P(PGM_P find, size_t fromIndex, size_t findLength) const
>     {
>         size_t len;
>         if (!find || !findLength || ((len = length()) == 0) || (fromIndex + findLength >= len)) {
>             return -1;
>         }
>         auto ptr = buffer();
>         auto idxPtr = stristr_P(ptr + fromIndex, find, findLength);
>         if (!idxPtr) {
>             return -1;
>         }
>         return idxPtr - ptr;
>     }
> 
>     int _lastIndexOf(char find) const
>     {
>         auto ptr = strrchr(buffer(), find);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf_P(char find) const
>     {
>         auto ptr = strrchr_P(buffer(), find);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf(char find, size_t fromIndex) const
>     {
>         if (!find) {
>             return -1;
>         }
>         auto len = length();
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex > len || fromIndex < 1) {
>             return -1;
>         }
>         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf_P(char find, size_t fromIndex) const
>     {
>         if (!find) {
>             return -1;
>         }
>         auto len = length();
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex > len || fromIndex < 1) {
>             return -1;
>         }
>         auto ptr = reinterpret_cast<const char *>(memrchr(buffer(), find, fromIndex));
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf_P(PGM_P find, size_t fromIndex, size_t findLen) const
>     {
>         size_t len;
>         if (!find || !(len = length())) {
>             return -1;
>         }
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex < findLen || fromIndex > len) {
>             return -1;
>         }
>         auto ptr = __strrstr_P(wbuffer(), fromIndex + findLen, find, findLen);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
>     int _lastIndexOf(const char *find, size_t fromIndex, size_t findLen) const
>     {
>         size_t len;
>         if (!find || !(len = length())) {
>             return -1;
>         }
>         if (fromIndex == ~0U) {
>             fromIndex = len;
>         }
>         else if (fromIndex < findLen || fromIndex > len) {
>             return -1;
>         }
>         auto ptr = __strrstr(wbuffer(), fromIndex + findLen, find, findLen);
>         if (!ptr) {
>             return -1;
>         }
>         return ptr - buffer();
>     }
> 
> 
> public:
>     // search
>     int indexOf(char ch, unsigned int fromIndex) const;
>     int indexOf(const String &str) const;
>     int indexOf(const String &str, unsigned int fromIndex) const;
> 
>     int indexOf(char c) const {
>         return indexOf(c, 0);
>     }
> 
>     int indexOf(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOf(str, fromIndex, ~0U);
>     }
>     int indexOf(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOf_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int indexOfIgnoreCase(char c) const {
>         return indexOfIgnoreCase(c, 0);
>     }
> 
>     int indexOfIgnoreCase(char ch, unsigned int fromIndex) const {
>         if (fromIndex >= len())
>             return -1;
>         const char *temp = strichr(buffer() + fromIndex, ch);
>         if (temp == NULL)
>             return -1;
>         return temp - buffer();
>     }
> 
> 
>     int indexOfIgnoreCase(const char *str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str, fromIndex, ~0U);
>     }
>     int indexOfIgnoreCase(const String &str, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase(str.c_str(), fromIndex, str.length());
>     }
>     int indexOfIgnoreCase(const __FlashStringHelper *fstr, unsigned int fromIndex = 0) const {
>         return _indexOfIgnoreCase_P(reinterpret_cast<PGM_P>(fstr), fromIndex, ~0U);
>     }
> 
> 
>     int lastIndexOf(char ch) const {
>         return _lastIndexOf(ch);
>     }
>     int lastIndexOf(char ch, unsigned int fromIndex) const {
>         return _lastIndexOf(ch, fromIndex);
>     }
>     int lastIndexOf(const String &str) const {
>         auto strLen = str.length();
>         return _lastIndexOf(str.buffer(), length() - strLen, strLen);
>     }
>     int lastIndexOf(const String &str, unsigned int fromIndex) const {
>         auto findLength = str.length();
>         return _lastIndexOf(str.buffer(), fromIndex - findLength, findLength);
>     }
>     int lastIndexOf(const __FlashStringHelper *str, unsigned int fromIndex) const {
>         auto findLength = strlen_P(reinterpret_cast<PGM_P>(str));
>         return _lastIndexOf_P(reinterpret_cast<PGM_P>(str), fromIndex - findLength, findLength);
>     }
> 
>     String substring(unsigned int beginIndex) const {
>         return substring(beginIndex, len());
>     }
>     String substring(unsigned int beginIndex, unsigned int endIndex) const;
> 
>     // PROGMEM safe
>     // returns false on failure
>     bool insert(size_t pos, PGM_P insert, size_t insertLen);
> 
>     inline bool insert(size_t pos, PGM_P str) {
>         return insert(pos, str, strlen_P(str));
>     }
>     inline bool insert(size_t pos, const __FlashStringHelper *fstr) {
>         return insert(pos, reinterpret_cast<PGM_P>(fstr), strlen_P(reinterpret_cast<PGM_P>(fstr)));
>     }
>     inline bool insert(size_t pos, const String &str) {
>         return insert(pos, str.buffer(), str.length());
>     }
> 
>     // modification
>     bool replace(char find, char replace);
> 
> protected:
>     bool _replace(PGM_P find, size_t findLen, PGM_P replace, size_t replaceLen);
> 
> public:
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const char *replace) {
>         return _replace(find, strlen(find), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const __FlashStringHelper *replace) {
>         return _replace(find, strlen(find), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const char *find, const String &replace) {
>         return _replace(find, strlen(find), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const String &replace) {
>         return _replace(find.buffer(), find.length(), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const char *replace) {
>         return _replace(find.buffer(), find.length(), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const String &find, const __FlashStringHelper *replace) {
>         return _replace(find.buffer(), find.length(), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const String &replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace.buffer(), replace.length());
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const char *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), replace, strlen(replace));
>     }
>     inline __attribute__((__always_inline__))
>         bool replace(const __FlashStringHelper *find, const __FlashStringHelper *replace) {
>         return _replace(reinterpret_cast<PGM_P>(find), strlen_P(reinterpret_cast<PGM_P>(find)), reinterpret_cast<PGM_P>(replace), strlen_P(reinterpret_cast<PGM_P>(replace)));
>     }
> 
>     void remove(unsigned int index);
>     void remove(unsigned int index, unsigned int count);
> 
>     String &toLowerCase(void);
>     String &toUpperCase(void);
> 
> protected:
>     enum class TrimType : uint8_t {
>         LEFT = 0x01,
>         RIGHT = 0x02,
>         BOTH = LEFT | RIGHT
>     };
> 
>     String &_trim(TrimType type);
>     inline String &_trim(TrimType type, char character) {
>         char buf[2] = { character, 0 };
>         return _trim(type, buf, 1);
>     }
>     String &_trim(TrimType type, PGM_P characters, size_t charLen);
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const char *characters) {
>         return _trim(type, characters, strlen(characters));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const __FlashStringHelper *characters) {
>         return _trim(type, reinterpret_cast<PGM_P>(characters), strlen_P(reinterpret_cast<PGM_P>(characters)));
>     }
>     inline __attribute__((__always_inline__))
>         String &_trim(TrimType type, const String &characters) {
>         return _trim(type, characters.c_str(), characters.length());
>     }
> 
> public:
>     inline __attribute__((__always_inline__))
>         String &trim() {
>         return _trim(TrimType::BOTH);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim() {
>         return _trim(TrimType::RIGHT);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim() {
>         return _trim(TrimType::LEFT);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(char character) {
>         return _trim(TrimType::BOTH, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(char character) {
>         return _trim(TrimType::RIGHT, character);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(char character) {
>         return _trim(TrimType::LEFT, character);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &trim(const char *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const String &characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &trim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::BOTH, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &rtrim(const char *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const String &characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &rtrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::RIGHT, characters);
>     }
> 
>     inline __attribute__((__always_inline__))
>         String &ltrim(const char *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const String &characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
>     inline __attribute__((__always_inline__))
>         String &ltrim(const __FlashStringHelper *characters) {
>         return _trim(TrimType::LEFT, characters);
>     }
> 
>     // parsing/conversion
>     long toInt(void) const;
>     float toFloat(void) const;
> 
>     inline __attribute__((__always_inline__))
>         double toDouble(void) const {
>         return toFloat();
>     }
> 
> 
> public:
>     // access to SSO and internals
> 
>     // returns allocated memory
>     inline size_t __getAllocSize() const {
> #if defined(ESP8266)
>         if (isSSO()) {
>             return 0;
>         }
>         return capacity() + 1;
> #else
>         return (length() + 8) & ~7;
> #endif
>     }
> 
>     // returns memory usage
>     inline size_t __getMemorySize() const {
>         return sizeof(String) + __getAllocSize();
>     }
> 
>     // get pointer to allocated memory and release ownership
>     // capacity is the size of the allocated block
>     // if no memory is allocated, it returns nullptr and capacity is set to 0
>     // the string is empty afterwards
>     inline char *__release(size_t &capacity) {
>         if (isSSO()) {
>             capacity = 0;
>             return nullptr;
>         }
>         capacity = this->capacity() + 1;
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
>     // see __release(size_t &capacity)
>     inline char *__release() {
>         if (isSSO()) {
>             return nullptr;
>         }
>         auto rPtr = ptr.buff;
>         ptr = {};
>         invalidate();
>         return rPtr;
>     }
> 
> 
> protected:
>     // Contains the string info when we're not in SSO mode
>     struct _ptr {
>         char *buff;
>         uint16_t cap;
>         uint16_t len;
>     };
>     // This allows strings up up to 11 (10 + \0 termination) without any extra space.
>     enum { SSOSIZE = sizeof(struct _ptr) + 4 - 1 }; // Characters to allocate space for SSO, must be 12 or more
>     struct _sso {
>         char     buff[SSOSIZE];
>         unsigned char len : 7; // Ensure only one byte is allocated by GCC for the bitfields
>         unsigned char isSSO : 1;
>     } __attribute__((packed)); // Ensure that GCC doesn't expand the flag byte to a 32-bit word for alignment issues
>     enum { CAPACITY_MAX = 65535 }; // If typeof(cap) changed from uint16_t, be sure to update this enum to the max value storable in the type
>     union {
>         struct _ptr ptr;
>         struct _sso sso;
>     };
>     // Accessor functions
>     inline bool isSSO() const { return sso.isSSO; }
>     inline unsigned int len() const { return isSSO() ? sso.len : ptr.len; }
>     inline unsigned int capacity() const { return isSSO() ? (unsigned int)SSOSIZE - 1 : ptr.cap; } // Size of max string not including terminal NUL
>     inline void setSSO(bool set) { sso.isSSO = set; }
>     inline void setLen(int len) { if (isSSO()) sso.len = len; else ptr.len = len; }
>     inline void setCapacity(int cap) { if (!isSSO()) ptr.cap = cap; }
>     inline void setBuffer(char *buff) { if (!isSSO()) ptr.buff = buff; }
>     // Buffer accessor functions
>     inline const char *buffer() const { return (const char *)(isSSO() ? sso.buff : ptr.buff); }
>     inline char *wbuffer() const { return isSSO() ? const_cast<char *>(sso.buff) : ptr.buff; } // Writable version of buffer
> 
> protected:
>     inline void init(void) {
>         setSSO(true);
>         setLen(0);
>         wbuffer()[0] = 0;
>     }
> 
>     void invalidate(void);
>     unsigned char changeBuffer(unsigned int maxStrLen);
> 
>     // copy and move
>     String &copy(const char *cstr, unsigned int length);
>     String &copy(const __FlashStringHelper *pstr, unsigned int length);
> #ifdef __GXX_EXPERIMENTAL_CXX0X__
>     void move(String &rhs);
> #endif
322,382c1023,1055
< // concatenation (note that it's done using non-method operators to handle both possible type refs)
< 
< inline String operator +(const String &lhs, const String &rhs) {
<     String res;
<     res.reserve(lhs.length() + rhs.length());
<     res += lhs;
<     res += rhs;
<     return res;
< }
< 
< inline String operator +(String &&lhs, const String &rhs) {
<     lhs += rhs;
<     return std::move(lhs);
< }
< 
< String operator +(const String &lhs, String &&rhs);
< String operator +(String &&lhs, String &&rhs);
< 
< template <typename T,
<     typename = std::enable_if_t<!std::is_same_v<String, std::decay_t<T>>>>
< inline String operator +(const String &lhs, const T &value) {
<     String res(lhs);
<     res += value;
<     return res;
< }
< 
< template <typename T,
<     typename = std::enable_if_t<!std::is_same_v<String, std::decay_t<T>>>>
< inline String operator +(String &&lhs, const T &value) {
<     lhs += value;
<     return std::move(lhs);
< }
< 
< // `String(char)` is explicit, but we used to have StringSumHelper silently allowing the following:
< // `String x; x = 'a' + String('b') + 'c';`
< // For comparison, `std::string(char)` does not exist. However, we are allowed to chain `char` as both lhs and rhs
< 
< String operator +(char lhs, const String &rhs);
< 
< inline String operator +(char lhs, String &&rhs) {
<     return std::move(rhs.insert(0, lhs));
< }
< 
< // both `char*` and `__FlashStringHelper*` are implicitly converted into `String()`, calling the `operator+(const String& ...);`
< // however, here we:
< // - do an automatic `reserve(total length)` for the resulting string
< // - possibly do rhs.insert(0, ...), when &&rhs capacity could fit both
< 
< String operator +(const char *lhs, const String &rhs);
< 
< inline String operator +(const char *lhs, String &&rhs) {
<     return std::move(rhs.insert(0, lhs));
< }
< 
< inline String operator +(const __FlashStringHelper *lhs, const String &rhs) {
<     return reinterpret_cast<const char*>(lhs) + rhs;
< }
< 
< inline String operator +(const __FlashStringHelper *lhs, String &&rhs) {
<     return std::move(rhs.insert(0, lhs));
< }
---
> class StringSumHelper : public String {
> public:
>     StringSumHelper(const String &s) :
>         String(s) {
>     }
>     StringSumHelper(const char *p) :
>         String(p) {
>     }
>     StringSumHelper(char c) :
>         String(c) {
>     }
>     StringSumHelper(unsigned char num) :
>         String(num) {
>     }
>     StringSumHelper(int num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned int num) :
>         String(num) {
>     }
>     StringSumHelper(long num) :
>         String(num) {
>     }
>     StringSumHelper(unsigned long num) :
>         String(num) {
>     }
>     StringSumHelper(float num) :
>         String(num) {
>     }
>     StringSumHelper(double num) :
>         String(num) {
>     }
> };
diff -r -Z -P4 ./framework-arduinoespressif8266_orig/libraries/ESP8266mDNS/src/LEAmDNS.h ./framework-arduinoespressif8266/libraries/ESP8266mDNS/src/LEAmDNS.h
531c531,532
<     protected:
---
>     // protected:
>     public:
612c613,614
< protected:
---
> // protected:
> public:
