/**
 * Author: sascha_lammers@gmx.de
 */

#if ESP32

// this is for the INMP441 MEMS microphone, other I2S microphones might work too

#include <Arduino_compat.h>
#include <arduinoFFT.h>
#include "i2s_microphone.h"
#include "clock.h"

#if 0
#    include <debug_helper_enable.h>
#else
#    include <debug_helper_disable.h>
#endif


// generated by scripts\tools\i2s_microphone_band_gen.py

static constexpr uint16_t BW(const uint8_t lo, const uint8_t hi)
{
    return lo | (hi << 8);
}

// band 1 = 0-49 Hz
// band 2 = 50-107 Hz
// band 3 = 108-172 Hz
// band 4 = 173-245 Hz
// band 5 = 246-327 Hz
// band 6 = 328-420 Hz
// band 7 = 421-523 Hz
// band 8 = 524-639 Hz
// band 9 = 640-767 Hz
// band 10 = 768-911 Hz
// band 11 = 912-1070 Hz
// band 12 = 1071-1247 Hz
// band 13 = 1248-1443 Hz
// band 14 = 1444-1660 Hz
// band 15 = 1661-1900 Hz
// band 16 = 1901-2164 Hz
// band 17 = 2165-2456 Hz
// band 18 = 2457-2777 Hz
// band 19 = 2778-3131 Hz
// band 20 = 3132-3520 Hz
// band 21 = 3521-3947 Hz
// band 22 = 3948-4417 Hz
// band 23 = 4418-4932 Hz
// band 24 = 4933-5496 Hz
// band 25 = 5497-6115 Hz
// band 26 = 6116-6792 Hz
// band 27 = 6793-7533 Hz
// band 28 = 7534-8343 Hz
// band 29 = 8344-9229 Hz
// band 30 = 9230-10196 Hz
// band 31 = 10197-11252 Hz
// band 32 = 11253-12405 Hz
static constexpr uint16_t bands[] = {BW(0, 0), BW(0, 0), BW(0, 1), BW(1, 1), BW(1, 2), BW(2, 3), BW(3, 4), BW(4, 4), BW(4, 6), BW(6, 7), BW(7, 8), BW(8, 9), BW(9, 11), BW(11, 12), BW(12, 14), BW(14, 16), BW(16, 19), BW(19, 21), BW(21, 24), BW(24, 27), BW(27, 30), BW(30, 34), BW(34, 38), BW(38, 42), BW(42, 47), BW(47, 53), BW(53, 58), BW(58, 65), BW(65, 72), BW(72, 79), BW(79, 87), BW(87, 96)};
static constexpr float factors1[] = {0.0, 0.0, 0.1640625, 0.0, 0.0859375, 0.4375, 0.71875, 0.0, 0.0078125, 1.0, 0.8828125, 0.6328125, 0.25, 0.71875, 0.03125, 0.15625, 0.0859375, 0.8125, 0.296875, 0.53125, 0.4921875, 0.15625, 0.4921875, 0.46875, 0.0546875, 0.2265625, 0.9375, 0.1484375, 0.8203125, 0.8984375, 0.3359375, 0.0859375};
static constexpr float factors2[] = {0.390625, 0.4453125, 0.34375, 0.5703125, 0.5625, 0.28125, 0.0859375, 0.90625, 0.0, 0.1171875, 0.3671875, 0.75, 0.28125, 0.96875, 0.84375, 0.9140625, 0.1875, 0.703125, 0.46875, 0.5078125, 0.84375, 0.5078125, 0.53125, 0.9453125, 0.7734375, 0.0625, 0.8515625, 0.1796875, 0.1015625, 0.6640625, 0.9140625, 0.921875};

inline static uint8_t getBandStart(uint8_t band)
{
    return bands[band] & 0xff;
}

inline static uint8_t getBandEnd(uint8_t band)
{
    return bands[band] >> 8;
}

inline static float getBandFactor1(uint8_t band)
{
    return factors1[band];
}

inline static float getBandFactor2(uint8_t band)
{
    return factors2[band];
}

inline static float getDivider(uint8_t start, uint8_t end, float f1, float f2)
{
    return (end - start + 1) - (f1 + f2);
}

void IRAM_ATTR I2SMicrophoneHandler(void *clsPtr)
{
    reinterpret_cast<I2SMicrophone *>(clsPtr)->task();
}

I2SMicrophone::I2SMicrophone(i2s_port_t i2sPort, uint8_t i2sSd, uint8_t i2sWs, uint8_t i2sSck, uint8_t *data, size_t dataSize, uint8_t &loudnessLeft, uint8_t &loudnessRight, float loudnessGain, float bandGain) :
    _taskHandle(nullptr),
    _i2sPort(i2sPort),
    _data(data),
    _dataSize(dataSize),
    _loudnessLeft(loudnessLeft),
    _loudnessRight(loudnessRight),
    _loudnessGain(loudnessGain),
    _bandGain(bandGain)
{
    i2s_driver_uninstall(_i2sPort);

    _vReal.reset(new _sampleBufferType());
    if (!_vReal) {
        __LDBG_printf("out of memory");
        return;
    }

    _vImag.reset(new _fftBufferType());
    if (!_vImag) {
        __LDBG_printf("out of memory");
        return;
    }

    _output.reset(new _outputBufferType());
    if (!_output) {
        __LDBG_printf("out of memory");
        return;
    }

    const i2s_config_t i2s_config =
    {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = kSampleRate,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = 2,
        .dma_buf_len = kMaxSamples,
        .use_apll = false
    };

    // install driver
    esp_err_t err = i2s_driver_install(_i2sPort, &i2s_config, 0, NULL);
    if (err != ESP_OK) {
        __LDBG_printf("i2s_driver_install err=%x", err);
        return;
    }

    const i2s_pin_config_t rx_pin_config = {
        .bck_io_num = i2sSck,
        .ws_io_num = i2sWs,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = i2sSd
    };

    // set pins
    err = i2s_set_pin(_i2sPort, &rx_pin_config);
    if (err != ESP_OK) {
        __LDBG_printf("i2s_set_pin err=%x", err);
        return;
    }

    // start i2s
    err = i2s_start(_i2sPort);
    if (err != ESP_OK) {
        __LDBG_printf("i2s_start err=%x", err);
        return;
    }

    std::fill_n(_data, _dataSize, 0); // clear all bands
    _dataSize = std::min<size_t>(_dataSize, kNumBands); // only process available bands

    // start audio processor task
    xTaskCreatePinnedToCore(I2SMicrophoneHandler, "I2SMicrophone", 1024 * 2, this, tskIDLE_PRIORITY + 2, &_taskHandle, 0);
    __LDBG_printf("microphone task=%p", _taskHandle);
}

I2SMicrophone::~I2SMicrophone()
{
    __LDBG_printf("microphone removed task=%p", _taskHandle);
    if (_taskHandle) {
        // remove task
        vTaskDelete(_taskHandle);
        _taskHandle = nullptr;

        // stop i2s
        i2s_stop(_i2sPort);
    }

    // remove driver...
    i2s_driver_uninstall(_i2sPort);
}

bool I2SMicrophone::_i2s_read_double(float &loudness)
{
    esp_err_t err;
    size_t readBytes = 0;
    int16_t sampleBuffer[kMaxSamples];
    if ((err = i2s_read(_i2sPort, sampleBuffer, sizeof(sampleBuffer), &readBytes, 100 / portTICK_RATE_MS)) == ESP_OK) {
        if (readBytes == sizeof(sampleBuffer)) {

            // clear data
            _vReal->fill(0.0);

            // copy 16bit sample buffer to double array and calculate loudness
            auto src = sampleBuffer;
            auto dst = _vReal->data();
            auto count = kMaxSamples;
            while(count--) {
                const auto val = *src++;
                loudness += powf(val, 2.0);
                *dst++ = val;
            }

            // get mean value and adjust level to fit into 8bit
            const auto kLoudnessGain = kMaxSamples * _loudnessGain;
            loudness = std::min(loudness / kLoudnessGain, 255.0f);

            return true;
        }
        else {
            __LDBG_printf("not enough data %d!=%d", readBytes, sizeof(sampleBuffer));
        }
    }
    else {
        __LDBG_printf("i2s_read failed err=%x", err);
    }
   return false;
}

void I2SMicrophone::task()
{
    for(;;) {
        auto start = millis();

        readI2S();

        constexpr unsigned long kReadRateMillis = Clock::kUpdateRate;
        const uint32_t dly = std::clamp(kReadRateMillis - (millis() - start), 1UL, kReadRateMillis);
        delay(dly);
    }
}

void I2SMicrophone::readI2S()
{
    auto &vReal = *_vReal.get();
    auto &vImag = *_vImag.get();
    auto &output = *_output.get();
    float loudness;

    // read i2s data and convert it to double
    if (_i2s_read_double(loudness)) {

        // clear data
        vImag.fill(0.0);
        output.fill(0.0);

        // run FFT
        arduinoFFT _fft(vReal.data(), vImag.data(), kMaxSamples, kSampleRate);
        _fft.DCRemoval();
        // _fft.Windowing(FFTWindow::Blackman_Harris, FFTDirection::Forward); // this is slower than Hamming (3ms)
        _fft.Windowing(FFTWindow::Hamming, FFTDirection::Forward);
        _fft.Compute(FFTDirection::Forward);
        _fft.ComplexToMagnitude();

        // get peak values per band
        for(uint8_t i = 0; i < _dataSize; i++) {
            // float sum = 0;
            float peak = 0;
            auto start = getBandStart(i);
            auto end = getBandEnd(i);
            auto f1 = getBandFactor1(i);
            auto f2 = getBandFactor2(i);
            for(uint8_t j = start; j <= end; j++) {
                float val = vReal[j];
                if (val < kNoiseLevel) { // filter noise
                    if (j == start && f1 != 0.0) {
                        val *= f1; // use partial part of first sample
                    }
                    if (j == end) {
                        val *= f2; // use partial part of last sample
                    }
                    peak = std::max(peak, val);
                    // sum += val;
                }
            }
            // store average value
            // output[i] = sum / getDivider(start, end, f1, f2);
            output[i] = peak;
        }

        // copy processed output
        const auto peak = 255.0f * _bandGain / 32768.0f;
        for(uint8_t i = 0; i < _dataSize; i++) {
            _data[i] = output[i] * peak;
        }

        // we have mono only
        _loudnessLeft = (_loudnessLeft + loudness) / 2.0;
        _loudnessRight = _loudnessLeft;

    }
}

#endif
