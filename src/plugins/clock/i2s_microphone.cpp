/**
 * Author: sascha_lammers@gmx.de
 */

#if ESP32

// this is for the INMP441 MEMS microphone, other I2S microphones might work too

#include <Arduino_compat.h>
#include <arduinoFFT.h>
#include "i2s_microphone.h"

#if 0
#    include <debug_helper_enable.h>
#else
#    include <debug_helper_disable.h>
#endif


// generated by scripts\tools\i2s_microphone_band_gen.py

// band 1 = 0-51 Hz
// band 2 = 52-111 Hz
// band 3 = 112-179 Hz
// band 4 = 180-257 Hz
// band 5 = 258-345 Hz
// band 6 = 346-446 Hz
// band 7 = 447-560 Hz
// band 8 = 561-688 Hz
// band 9 = 689-832 Hz
// band 10 = 833-994 Hz
// band 11 = 995-1175 Hz
// band 12 = 1176-1379 Hz
// band 13 = 1380-1606 Hz
// band 14 = 1607-1859 Hz
// band 15 = 1860-2141 Hz
// band 16 = 2142-2456 Hz
// band 17 = 2457-2805 Hz
// band 18 = 2806-3193 Hz
// band 19 = 3194-3623 Hz
// band 20 = 3624-4100 Hz
// band 21 = 4101-4628 Hz
// band 22 = 4629-5212 Hz
// band 23 = 5213-5858 Hz
// band 24 = 5859-6571 Hz
// band 25 = 6572-7358 Hz
// band 26 = 7359-8227 Hz
// band 27 = 8228-9184 Hz
// band 28 = 9185-10238 Hz
// band 29 = 10239-11399 Hz
// band 30 = 11400-12677 Hz
// band 31 = 12678-14082 Hz
// band 32 = 14083-15627 Hz

static constexpr uint16_t bands[] = {0, 256, 513, 1026, 1284, 1541, 2054, 2568, 3338, 3853, 4623, 5394, 6421, 7449, 8477, 9761, 11046, 12587, 14385, 16440, 18496, 20808, 23377, 26203, 29286, 32882, 36736, 40847, 45727, 50866, 56518, 62684}; // start=low byte, end=high byte
static constexpr float factors1[] = {0.0, 0.203125, 0.265625, 0.203125, 0.984375, 0.59375, 0.03125, 0.25, 0.25, 1.0, 0.46875, 0.625, 0.453125, 0.90625, 0.9375, 0.53125, 0.625, 0.171875, 0.109375, 0.375, 0.9375, 0.6875, 0.546875, 0.46875, 0.328125, 0.015625, 0.453125, 0.5, 0.015625, 0.875, 0.90625, 0.953125};
static constexpr float factors2[] = {0.796875, 0.734375, 0.796875, 0.015625, 0.40625, 0.96875, 0.75, 0.75, 0.0, 0.53125, 0.375, 0.546875, 0.09375, 0.0625, 0.46875, 0.375, 0.828125, 0.890625, 0.625, 0.0625, 0.3125, 0.453125, 0.53125, 0.671875, 0.984375, 0.546875, 0.5, 0.984375, 0.125, 0.09375, 0.046875, 0.171875};

inline static uint8_t getBandStart(uint8_t band)
{
    return bands[band] & 0xff;
}

inline static uint8_t getBandEnd(uint8_t band)
{
    return bands[band] >> 8;
}

inline static float getBandFactor1(uint8_t band)
{
    return factors1[band];
}

inline static float getBandFactor2(uint8_t band)
{
    return factors2[band];
}

inline static float getDivider(uint8_t start, uint8_t end, float f1, float f2)
{
    return (end - start + 1) - (f1 + f2);
}

void IRAM_ATTR I2SMicrophoneHandler(void *clsPtr)
{
    reinterpret_cast<I2SMicrophone *>(clsPtr)->task();
}

I2SMicrophone::I2SMicrophone(i2s_port_t i2sPort, uint8_t i2sSd, uint8_t i2sWs, uint8_t i2sSck, uint8_t *data, size_t dataSize, uint8_t &loudnessLeft, uint8_t &loudnessRight, float loudnessGain, float bandGain) :
    _taskHandle(nullptr),
    _i2sPort(i2sPort),
    _data(data),
    _dataSize(dataSize),
    _loudnessLeft(loudnessLeft),
    _loudnessRight(loudnessRight),
    _loudnessGain(loudnessGain),
    _bandGain(bandGain)
{
    i2s_driver_uninstall(_i2sPort);

    _vReal.reset(new _sampleBufferType());
    if (!_vReal) {
        __LDBG_printf("out of memory");
        return;
    }

    _vImag.reset(new _fftBufferType());
    if (!_vImag) {
        __LDBG_printf("out of memory");
        return;
    }

    _output.reset(new _outputBufferType());
    if (!_output) {
        __LDBG_printf("out of memory");
        return;
    }

    const i2s_config_t i2s_config =
    {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = kSampleRate,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = 2,
        .dma_buf_len = kMaxSamples,
        .use_apll = false
    };

    // install driver
    esp_err_t err = i2s_driver_install(_i2sPort, &i2s_config, 0, NULL);
    if (err != ESP_OK) {
        __LDBG_printf("i2s_driver_install err=%x", err);
        return;
    }

    const i2s_pin_config_t rx_pin_config = {
        .bck_io_num = i2sSck,
        .ws_io_num = i2sWs,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = i2sSd
    };

    // set pins
    err = i2s_set_pin(_i2sPort, &rx_pin_config);
    if (err != ESP_OK) {
        __LDBG_printf("i2s_set_pin err=%x", err);
        return;
    }

    // start i2s
    err = i2s_start(_i2sPort);
    if (err != ESP_OK) {
        __LDBG_printf("i2s_start err=%x", err);
        return;
    }

    std::fill_n(_data, _dataSize, 0); // clear all bands
    _dataSize = std::min<size_t>(_dataSize, kNumBands); // only process available bands

    // start audio processor task
    xTaskCreatePinnedToCore(I2SMicrophoneHandler, "I2SMicrophone", 1024 * 2, this, tskIDLE_PRIORITY + 2, &_taskHandle, 0);
    __LDBG_printf("microphone task=%p", _taskHandle);
}

I2SMicrophone::~I2SMicrophone()
{
    __LDBG_printf("microphone removed task=%p", _taskHandle);
    if (_taskHandle) {
        // remove task
        vTaskDelete(_taskHandle);
        _taskHandle = nullptr;

        // stop i2s
        i2s_stop(_i2sPort);
    }

    // remove driver...
    i2s_driver_uninstall(_i2sPort);
}

bool I2SMicrophone::_i2s_read_double(float &loudness)
{
    esp_err_t err;
    size_t readBytes = 0;
    int16_t sampleBuffer[kMaxSamples];
    if ((err = i2s_read(_i2sPort, sampleBuffer, sizeof(sampleBuffer), &readBytes, 100 / portTICK_RATE_MS)) == ESP_OK) {
        if (readBytes == sizeof(sampleBuffer)) {

            // clear data
            _vReal->fill(0.0);

            // copy 16bit sample buffer to double array and calculate loudness
            auto src = sampleBuffer;
            auto dst = _vReal->data();
            auto count = kMaxSamples;
            while(count--) {
                const auto val = *src++;
                loudness += powf(val, 2.0);
                *dst++ = val;
            }

            // get mean value and adjust level to fit into 8bit
            const auto kLoudnessGain = kMaxSamples * _loudnessGain;
            loudness = std::min(loudness / kLoudnessGain, 255.0f);

            return true;
        }
        else {
            __LDBG_printf("not enough data %d!=%d", readBytes, sizeof(sampleBuffer));
        }
    }
    else {
        __LDBG_printf("i2s_read failed err=%x", err);
    }
   return false;
}

void I2SMicrophone::task()
{
    auto &vReal = *_vReal.get();
    auto &vImag = *_vImag.get();
    auto &output = *_output.get();

    for(;;) {
        auto start = millis();
        float loudness;

        // read i2s data and convert it to double
        if (_i2s_read_double(loudness)) {

            // clear data
            vImag.fill(0.0);
            output.fill(0.0);

            // run FFT
            arduinoFFT _fft(vReal.data(), vImag.data(), kMaxSamples, kSampleRate);
            _fft.DCRemoval();
            _fft.Windowing(FFTWindow::Blackman_Harris, FFTDirection::Forward);
            // _fft.Windowing(FFTWindow::Hamming, FFTDirection::Forward);
            _fft.Compute(FFTDirection::Forward);
            _fft.ComplexToMagnitude();

            // get peak values per band
            for(uint8_t i = 0; i < _dataSize; i++) {
                float sum = 0;
                auto start = getBandStart(i);
                auto end = getBandEnd(i);
                auto f1 = getBandFactor1(i);
                auto f2 = getBandFactor2(i);
                for(uint8_t j = start; j <= end; j++) {
                    float val = vReal[j];
                    if (val < kNoiseLevel) { // filter noise
                        if (j == start && f1 != 0.0) {
                            val *= f1; // use partial part of first sample
                        }
                        if (j == end) {
                            val *= f2; // use partial part of last sample
                        }
                        sum += val;
                    }
                }
                // store average value
                output[i] = sum / getDivider(start, end, f1, f2);
            }

            // copy processed output
            const auto peak = 255.0f * _bandGain / 32768.0f;
            for(uint8_t i = 0; i < _dataSize; i++) {
                _data[i] = output[i] * peak;
            }

            // we have mono only
            _loudnessLeft = loudness;
            _loudnessRight = loudness;

        }

        constexpr unsigned long kReadRateMillis = 1000 / 50;
        delay(std::clamp(kReadRateMillis - (millis() - start), 1UL, kReadRateMillis));
    }
}

#endif
